// Code generated by Prisma (prisma@1.34.12). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  ads: (where?: AdsWhereInput) => Promise<boolean>;
  blog: (where?: BlogWhereInput) => Promise<boolean>;
  brandTile: (where?: BrandTileWhereInput) => Promise<boolean>;
  contacts: (where?: ContactsWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  friday: (where?: FridayWhereInput) => Promise<boolean>;
  hotDeals: (where?: HotDealsWhereInput) => Promise<boolean>;
  misc: (where?: MiscWhereInput) => Promise<boolean>;
  monday: (where?: MondayWhereInput) => Promise<boolean>;
  orders: (where?: OrdersWhereInput) => Promise<boolean>;
  restaurantType: (where?: RestaurantTypeWhereInput) => Promise<boolean>;
  restaurants: (where?: RestaurantsWhereInput) => Promise<boolean>;
  saturday: (where?: SaturdayWhereInput) => Promise<boolean>;
  sunday: (where?: SundayWhereInput) => Promise<boolean>;
  thursday: (where?: ThursdayWhereInput) => Promise<boolean>;
  timeDiscount: (where?: TimeDiscountWhereInput) => Promise<boolean>;
  tuesday: (where?: TuesdayWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userReviews: (where?: UserReviewsWhereInput) => Promise<boolean>;
  wednesday: (where?: WednesdayWhereInput) => Promise<boolean>;
  city: (where?: cityWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  ads: (where: AdsWhereUniqueInput) => AdsNullablePromise;
  adses: (args?: {
    where?: AdsWhereInput;
    orderBy?: AdsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Ads>;
  adsesConnection: (args?: {
    where?: AdsWhereInput;
    orderBy?: AdsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AdsConnectionPromise;
  blog: (where: BlogWhereUniqueInput) => BlogNullablePromise;
  blogs: (args?: {
    where?: BlogWhereInput;
    orderBy?: BlogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Blog>;
  blogsConnection: (args?: {
    where?: BlogWhereInput;
    orderBy?: BlogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BlogConnectionPromise;
  brandTile: (where: BrandTileWhereUniqueInput) => BrandTileNullablePromise;
  brandTiles: (args?: {
    where?: BrandTileWhereInput;
    orderBy?: BrandTileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BrandTile>;
  brandTilesConnection: (args?: {
    where?: BrandTileWhereInput;
    orderBy?: BrandTileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BrandTileConnectionPromise;
  contacts: (where: ContactsWhereUniqueInput) => ContactsNullablePromise;
  contactses: (args?: {
    where?: ContactsWhereInput;
    orderBy?: ContactsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Contacts>;
  contactsesConnection: (args?: {
    where?: ContactsWhereInput;
    orderBy?: ContactsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContactsConnectionPromise;
  file: (where: FileWhereUniqueInput) => FileNullablePromise;
  files: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<File>;
  filesConnection: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FileConnectionPromise;
  friday: (where: FridayWhereUniqueInput) => FridayNullablePromise;
  fridays: (args?: {
    where?: FridayWhereInput;
    orderBy?: FridayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Friday>;
  fridaysConnection: (args?: {
    where?: FridayWhereInput;
    orderBy?: FridayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FridayConnectionPromise;
  hotDeals: (where: HotDealsWhereUniqueInput) => HotDealsNullablePromise;
  hotDealses: (args?: {
    where?: HotDealsWhereInput;
    orderBy?: HotDealsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<HotDeals>;
  hotDealsesConnection: (args?: {
    where?: HotDealsWhereInput;
    orderBy?: HotDealsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HotDealsConnectionPromise;
  misc: (where: MiscWhereUniqueInput) => MiscNullablePromise;
  miscs: (args?: {
    where?: MiscWhereInput;
    orderBy?: MiscOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Misc>;
  miscsConnection: (args?: {
    where?: MiscWhereInput;
    orderBy?: MiscOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MiscConnectionPromise;
  monday: (where: MondayWhereUniqueInput) => MondayNullablePromise;
  mondays: (args?: {
    where?: MondayWhereInput;
    orderBy?: MondayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Monday>;
  mondaysConnection: (args?: {
    where?: MondayWhereInput;
    orderBy?: MondayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MondayConnectionPromise;
  orders: (where: OrdersWhereUniqueInput) => OrdersNullablePromise;
  orderses: (args?: {
    where?: OrdersWhereInput;
    orderBy?: OrdersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Orders>;
  ordersesConnection: (args?: {
    where?: OrdersWhereInput;
    orderBy?: OrdersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrdersConnectionPromise;
  restaurantType: (
    where: RestaurantTypeWhereUniqueInput
  ) => RestaurantTypeNullablePromise;
  restaurantTypes: (args?: {
    where?: RestaurantTypeWhereInput;
    orderBy?: RestaurantTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<RestaurantType>;
  restaurantTypesConnection: (args?: {
    where?: RestaurantTypeWhereInput;
    orderBy?: RestaurantTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RestaurantTypeConnectionPromise;
  restaurants: (
    where: RestaurantsWhereUniqueInput
  ) => RestaurantsNullablePromise;
  restaurantses: (args?: {
    where?: RestaurantsWhereInput;
    orderBy?: RestaurantsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Restaurants>;
  restaurantsesConnection: (args?: {
    where?: RestaurantsWhereInput;
    orderBy?: RestaurantsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RestaurantsConnectionPromise;
  saturday: (where: SaturdayWhereUniqueInput) => SaturdayNullablePromise;
  saturdays: (args?: {
    where?: SaturdayWhereInput;
    orderBy?: SaturdayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Saturday>;
  saturdaysConnection: (args?: {
    where?: SaturdayWhereInput;
    orderBy?: SaturdayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SaturdayConnectionPromise;
  sunday: (where: SundayWhereUniqueInput) => SundayNullablePromise;
  sundays: (args?: {
    where?: SundayWhereInput;
    orderBy?: SundayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Sunday>;
  sundaysConnection: (args?: {
    where?: SundayWhereInput;
    orderBy?: SundayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SundayConnectionPromise;
  thursday: (where: ThursdayWhereUniqueInput) => ThursdayNullablePromise;
  thursdays: (args?: {
    where?: ThursdayWhereInput;
    orderBy?: ThursdayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Thursday>;
  thursdaysConnection: (args?: {
    where?: ThursdayWhereInput;
    orderBy?: ThursdayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ThursdayConnectionPromise;
  timeDiscount: (
    where: TimeDiscountWhereUniqueInput
  ) => TimeDiscountNullablePromise;
  timeDiscounts: (args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TimeDiscount>;
  timeDiscountsConnection: (args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TimeDiscountConnectionPromise;
  tuesday: (where: TuesdayWhereUniqueInput) => TuesdayNullablePromise;
  tuesdays: (args?: {
    where?: TuesdayWhereInput;
    orderBy?: TuesdayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tuesday>;
  tuesdaysConnection: (args?: {
    where?: TuesdayWhereInput;
    orderBy?: TuesdayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TuesdayConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  userReviews: (
    where: UserReviewsWhereUniqueInput
  ) => UserReviewsNullablePromise;
  userReviewses: (args?: {
    where?: UserReviewsWhereInput;
    orderBy?: UserReviewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserReviews>;
  userReviewsesConnection: (args?: {
    where?: UserReviewsWhereInput;
    orderBy?: UserReviewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserReviewsConnectionPromise;
  wednesday: (where: WednesdayWhereUniqueInput) => WednesdayNullablePromise;
  wednesdays: (args?: {
    where?: WednesdayWhereInput;
    orderBy?: WednesdayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Wednesday>;
  wednesdaysConnection: (args?: {
    where?: WednesdayWhereInput;
    orderBy?: WednesdayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WednesdayConnectionPromise;
  city: (where: cityWhereUniqueInput) => cityNullablePromise;
  cities: (args?: {
    where?: cityWhereInput;
    orderBy?: cityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<city>;
  citiesConnection: (args?: {
    where?: cityWhereInput;
    orderBy?: cityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => cityConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAds: (data: AdsCreateInput) => AdsPromise;
  updateAds: (args: {
    data: AdsUpdateInput;
    where: AdsWhereUniqueInput;
  }) => AdsPromise;
  updateManyAdses: (args: {
    data: AdsUpdateManyMutationInput;
    where?: AdsWhereInput;
  }) => BatchPayloadPromise;
  upsertAds: (args: {
    where: AdsWhereUniqueInput;
    create: AdsCreateInput;
    update: AdsUpdateInput;
  }) => AdsPromise;
  deleteAds: (where: AdsWhereUniqueInput) => AdsPromise;
  deleteManyAdses: (where?: AdsWhereInput) => BatchPayloadPromise;
  createBlog: (data: BlogCreateInput) => BlogPromise;
  updateBlog: (args: {
    data: BlogUpdateInput;
    where: BlogWhereUniqueInput;
  }) => BlogPromise;
  updateManyBlogs: (args: {
    data: BlogUpdateManyMutationInput;
    where?: BlogWhereInput;
  }) => BatchPayloadPromise;
  upsertBlog: (args: {
    where: BlogWhereUniqueInput;
    create: BlogCreateInput;
    update: BlogUpdateInput;
  }) => BlogPromise;
  deleteBlog: (where: BlogWhereUniqueInput) => BlogPromise;
  deleteManyBlogs: (where?: BlogWhereInput) => BatchPayloadPromise;
  createBrandTile: (data: BrandTileCreateInput) => BrandTilePromise;
  updateBrandTile: (args: {
    data: BrandTileUpdateInput;
    where: BrandTileWhereUniqueInput;
  }) => BrandTilePromise;
  updateManyBrandTiles: (args: {
    data: BrandTileUpdateManyMutationInput;
    where?: BrandTileWhereInput;
  }) => BatchPayloadPromise;
  upsertBrandTile: (args: {
    where: BrandTileWhereUniqueInput;
    create: BrandTileCreateInput;
    update: BrandTileUpdateInput;
  }) => BrandTilePromise;
  deleteBrandTile: (where: BrandTileWhereUniqueInput) => BrandTilePromise;
  deleteManyBrandTiles: (where?: BrandTileWhereInput) => BatchPayloadPromise;
  createContacts: (data: ContactsCreateInput) => ContactsPromise;
  updateContacts: (args: {
    data: ContactsUpdateInput;
    where: ContactsWhereUniqueInput;
  }) => ContactsPromise;
  updateManyContactses: (args: {
    data: ContactsUpdateManyMutationInput;
    where?: ContactsWhereInput;
  }) => BatchPayloadPromise;
  upsertContacts: (args: {
    where: ContactsWhereUniqueInput;
    create: ContactsCreateInput;
    update: ContactsUpdateInput;
  }) => ContactsPromise;
  deleteContacts: (where: ContactsWhereUniqueInput) => ContactsPromise;
  deleteManyContactses: (where?: ContactsWhereInput) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (args: {
    data: FileUpdateInput;
    where: FileWhereUniqueInput;
  }) => FilePromise;
  updateManyFiles: (args: {
    data: FileUpdateManyMutationInput;
    where?: FileWhereInput;
  }) => BatchPayloadPromise;
  upsertFile: (args: {
    where: FileWhereUniqueInput;
    create: FileCreateInput;
    update: FileUpdateInput;
  }) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createFriday: (data: FridayCreateInput) => FridayPromise;
  updateFriday: (args: {
    data: FridayUpdateInput;
    where: FridayWhereUniqueInput;
  }) => FridayPromise;
  updateManyFridays: (args: {
    data: FridayUpdateManyMutationInput;
    where?: FridayWhereInput;
  }) => BatchPayloadPromise;
  upsertFriday: (args: {
    where: FridayWhereUniqueInput;
    create: FridayCreateInput;
    update: FridayUpdateInput;
  }) => FridayPromise;
  deleteFriday: (where: FridayWhereUniqueInput) => FridayPromise;
  deleteManyFridays: (where?: FridayWhereInput) => BatchPayloadPromise;
  createHotDeals: (data: HotDealsCreateInput) => HotDealsPromise;
  updateHotDeals: (args: {
    data: HotDealsUpdateInput;
    where: HotDealsWhereUniqueInput;
  }) => HotDealsPromise;
  updateManyHotDealses: (args: {
    data: HotDealsUpdateManyMutationInput;
    where?: HotDealsWhereInput;
  }) => BatchPayloadPromise;
  upsertHotDeals: (args: {
    where: HotDealsWhereUniqueInput;
    create: HotDealsCreateInput;
    update: HotDealsUpdateInput;
  }) => HotDealsPromise;
  deleteHotDeals: (where: HotDealsWhereUniqueInput) => HotDealsPromise;
  deleteManyHotDealses: (where?: HotDealsWhereInput) => BatchPayloadPromise;
  createMisc: (data: MiscCreateInput) => MiscPromise;
  updateMisc: (args: {
    data: MiscUpdateInput;
    where: MiscWhereUniqueInput;
  }) => MiscPromise;
  updateManyMiscs: (args: {
    data: MiscUpdateManyMutationInput;
    where?: MiscWhereInput;
  }) => BatchPayloadPromise;
  upsertMisc: (args: {
    where: MiscWhereUniqueInput;
    create: MiscCreateInput;
    update: MiscUpdateInput;
  }) => MiscPromise;
  deleteMisc: (where: MiscWhereUniqueInput) => MiscPromise;
  deleteManyMiscs: (where?: MiscWhereInput) => BatchPayloadPromise;
  createMonday: (data: MondayCreateInput) => MondayPromise;
  updateMonday: (args: {
    data: MondayUpdateInput;
    where: MondayWhereUniqueInput;
  }) => MondayPromise;
  updateManyMondays: (args: {
    data: MondayUpdateManyMutationInput;
    where?: MondayWhereInput;
  }) => BatchPayloadPromise;
  upsertMonday: (args: {
    where: MondayWhereUniqueInput;
    create: MondayCreateInput;
    update: MondayUpdateInput;
  }) => MondayPromise;
  deleteMonday: (where: MondayWhereUniqueInput) => MondayPromise;
  deleteManyMondays: (where?: MondayWhereInput) => BatchPayloadPromise;
  createOrders: (data: OrdersCreateInput) => OrdersPromise;
  updateOrders: (args: {
    data: OrdersUpdateInput;
    where: OrdersWhereUniqueInput;
  }) => OrdersPromise;
  updateManyOrderses: (args: {
    data: OrdersUpdateManyMutationInput;
    where?: OrdersWhereInput;
  }) => BatchPayloadPromise;
  upsertOrders: (args: {
    where: OrdersWhereUniqueInput;
    create: OrdersCreateInput;
    update: OrdersUpdateInput;
  }) => OrdersPromise;
  deleteOrders: (where: OrdersWhereUniqueInput) => OrdersPromise;
  deleteManyOrderses: (where?: OrdersWhereInput) => BatchPayloadPromise;
  createRestaurantType: (
    data: RestaurantTypeCreateInput
  ) => RestaurantTypePromise;
  updateRestaurantType: (args: {
    data: RestaurantTypeUpdateInput;
    where: RestaurantTypeWhereUniqueInput;
  }) => RestaurantTypePromise;
  updateManyRestaurantTypes: (args: {
    data: RestaurantTypeUpdateManyMutationInput;
    where?: RestaurantTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertRestaurantType: (args: {
    where: RestaurantTypeWhereUniqueInput;
    create: RestaurantTypeCreateInput;
    update: RestaurantTypeUpdateInput;
  }) => RestaurantTypePromise;
  deleteRestaurantType: (
    where: RestaurantTypeWhereUniqueInput
  ) => RestaurantTypePromise;
  deleteManyRestaurantTypes: (
    where?: RestaurantTypeWhereInput
  ) => BatchPayloadPromise;
  createRestaurants: (data: RestaurantsCreateInput) => RestaurantsPromise;
  updateRestaurants: (args: {
    data: RestaurantsUpdateInput;
    where: RestaurantsWhereUniqueInput;
  }) => RestaurantsPromise;
  updateManyRestaurantses: (args: {
    data: RestaurantsUpdateManyMutationInput;
    where?: RestaurantsWhereInput;
  }) => BatchPayloadPromise;
  upsertRestaurants: (args: {
    where: RestaurantsWhereUniqueInput;
    create: RestaurantsCreateInput;
    update: RestaurantsUpdateInput;
  }) => RestaurantsPromise;
  deleteRestaurants: (where: RestaurantsWhereUniqueInput) => RestaurantsPromise;
  deleteManyRestaurantses: (
    where?: RestaurantsWhereInput
  ) => BatchPayloadPromise;
  createSaturday: (data: SaturdayCreateInput) => SaturdayPromise;
  updateSaturday: (args: {
    data: SaturdayUpdateInput;
    where: SaturdayWhereUniqueInput;
  }) => SaturdayPromise;
  updateManySaturdays: (args: {
    data: SaturdayUpdateManyMutationInput;
    where?: SaturdayWhereInput;
  }) => BatchPayloadPromise;
  upsertSaturday: (args: {
    where: SaturdayWhereUniqueInput;
    create: SaturdayCreateInput;
    update: SaturdayUpdateInput;
  }) => SaturdayPromise;
  deleteSaturday: (where: SaturdayWhereUniqueInput) => SaturdayPromise;
  deleteManySaturdays: (where?: SaturdayWhereInput) => BatchPayloadPromise;
  createSunday: (data: SundayCreateInput) => SundayPromise;
  updateSunday: (args: {
    data: SundayUpdateInput;
    where: SundayWhereUniqueInput;
  }) => SundayPromise;
  updateManySundays: (args: {
    data: SundayUpdateManyMutationInput;
    where?: SundayWhereInput;
  }) => BatchPayloadPromise;
  upsertSunday: (args: {
    where: SundayWhereUniqueInput;
    create: SundayCreateInput;
    update: SundayUpdateInput;
  }) => SundayPromise;
  deleteSunday: (where: SundayWhereUniqueInput) => SundayPromise;
  deleteManySundays: (where?: SundayWhereInput) => BatchPayloadPromise;
  createThursday: (data: ThursdayCreateInput) => ThursdayPromise;
  updateThursday: (args: {
    data: ThursdayUpdateInput;
    where: ThursdayWhereUniqueInput;
  }) => ThursdayPromise;
  updateManyThursdays: (args: {
    data: ThursdayUpdateManyMutationInput;
    where?: ThursdayWhereInput;
  }) => BatchPayloadPromise;
  upsertThursday: (args: {
    where: ThursdayWhereUniqueInput;
    create: ThursdayCreateInput;
    update: ThursdayUpdateInput;
  }) => ThursdayPromise;
  deleteThursday: (where: ThursdayWhereUniqueInput) => ThursdayPromise;
  deleteManyThursdays: (where?: ThursdayWhereInput) => BatchPayloadPromise;
  createTimeDiscount: (data: TimeDiscountCreateInput) => TimeDiscountPromise;
  updateTimeDiscount: (args: {
    data: TimeDiscountUpdateInput;
    where: TimeDiscountWhereUniqueInput;
  }) => TimeDiscountPromise;
  updateManyTimeDiscounts: (args: {
    data: TimeDiscountUpdateManyMutationInput;
    where?: TimeDiscountWhereInput;
  }) => BatchPayloadPromise;
  upsertTimeDiscount: (args: {
    where: TimeDiscountWhereUniqueInput;
    create: TimeDiscountCreateInput;
    update: TimeDiscountUpdateInput;
  }) => TimeDiscountPromise;
  deleteTimeDiscount: (
    where: TimeDiscountWhereUniqueInput
  ) => TimeDiscountPromise;
  deleteManyTimeDiscounts: (
    where?: TimeDiscountWhereInput
  ) => BatchPayloadPromise;
  createTuesday: (data: TuesdayCreateInput) => TuesdayPromise;
  updateTuesday: (args: {
    data: TuesdayUpdateInput;
    where: TuesdayWhereUniqueInput;
  }) => TuesdayPromise;
  updateManyTuesdays: (args: {
    data: TuesdayUpdateManyMutationInput;
    where?: TuesdayWhereInput;
  }) => BatchPayloadPromise;
  upsertTuesday: (args: {
    where: TuesdayWhereUniqueInput;
    create: TuesdayCreateInput;
    update: TuesdayUpdateInput;
  }) => TuesdayPromise;
  deleteTuesday: (where: TuesdayWhereUniqueInput) => TuesdayPromise;
  deleteManyTuesdays: (where?: TuesdayWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserReviews: (data: UserReviewsCreateInput) => UserReviewsPromise;
  updateUserReviews: (args: {
    data: UserReviewsUpdateInput;
    where: UserReviewsWhereUniqueInput;
  }) => UserReviewsPromise;
  updateManyUserReviewses: (args: {
    data: UserReviewsUpdateManyMutationInput;
    where?: UserReviewsWhereInput;
  }) => BatchPayloadPromise;
  upsertUserReviews: (args: {
    where: UserReviewsWhereUniqueInput;
    create: UserReviewsCreateInput;
    update: UserReviewsUpdateInput;
  }) => UserReviewsPromise;
  deleteUserReviews: (where: UserReviewsWhereUniqueInput) => UserReviewsPromise;
  deleteManyUserReviewses: (
    where?: UserReviewsWhereInput
  ) => BatchPayloadPromise;
  createWednesday: (data: WednesdayCreateInput) => WednesdayPromise;
  updateWednesday: (args: {
    data: WednesdayUpdateInput;
    where: WednesdayWhereUniqueInput;
  }) => WednesdayPromise;
  updateManyWednesdays: (args: {
    data: WednesdayUpdateManyMutationInput;
    where?: WednesdayWhereInput;
  }) => BatchPayloadPromise;
  upsertWednesday: (args: {
    where: WednesdayWhereUniqueInput;
    create: WednesdayCreateInput;
    update: WednesdayUpdateInput;
  }) => WednesdayPromise;
  deleteWednesday: (where: WednesdayWhereUniqueInput) => WednesdayPromise;
  deleteManyWednesdays: (where?: WednesdayWhereInput) => BatchPayloadPromise;
  createcity: (data: cityCreateInput) => cityPromise;
  updatecity: (args: {
    data: cityUpdateInput;
    where: cityWhereUniqueInput;
  }) => cityPromise;
  updateManycities: (args: {
    data: cityUpdateManyMutationInput;
    where?: cityWhereInput;
  }) => BatchPayloadPromise;
  upsertcity: (args: {
    where: cityWhereUniqueInput;
    create: cityCreateInput;
    update: cityUpdateInput;
  }) => cityPromise;
  deletecity: (where: cityWhereUniqueInput) => cityPromise;
  deleteManycities: (where?: cityWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  ads: (
    where?: AdsSubscriptionWhereInput
  ) => AdsSubscriptionPayloadSubscription;
  blog: (
    where?: BlogSubscriptionWhereInput
  ) => BlogSubscriptionPayloadSubscription;
  brandTile: (
    where?: BrandTileSubscriptionWhereInput
  ) => BrandTileSubscriptionPayloadSubscription;
  contacts: (
    where?: ContactsSubscriptionWhereInput
  ) => ContactsSubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  friday: (
    where?: FridaySubscriptionWhereInput
  ) => FridaySubscriptionPayloadSubscription;
  hotDeals: (
    where?: HotDealsSubscriptionWhereInput
  ) => HotDealsSubscriptionPayloadSubscription;
  misc: (
    where?: MiscSubscriptionWhereInput
  ) => MiscSubscriptionPayloadSubscription;
  monday: (
    where?: MondaySubscriptionWhereInput
  ) => MondaySubscriptionPayloadSubscription;
  orders: (
    where?: OrdersSubscriptionWhereInput
  ) => OrdersSubscriptionPayloadSubscription;
  restaurantType: (
    where?: RestaurantTypeSubscriptionWhereInput
  ) => RestaurantTypeSubscriptionPayloadSubscription;
  restaurants: (
    where?: RestaurantsSubscriptionWhereInput
  ) => RestaurantsSubscriptionPayloadSubscription;
  saturday: (
    where?: SaturdaySubscriptionWhereInput
  ) => SaturdaySubscriptionPayloadSubscription;
  sunday: (
    where?: SundaySubscriptionWhereInput
  ) => SundaySubscriptionPayloadSubscription;
  thursday: (
    where?: ThursdaySubscriptionWhereInput
  ) => ThursdaySubscriptionPayloadSubscription;
  timeDiscount: (
    where?: TimeDiscountSubscriptionWhereInput
  ) => TimeDiscountSubscriptionPayloadSubscription;
  tuesday: (
    where?: TuesdaySubscriptionWhereInput
  ) => TuesdaySubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userReviews: (
    where?: UserReviewsSubscriptionWhereInput
  ) => UserReviewsSubscriptionPayloadSubscription;
  wednesday: (
    where?: WednesdaySubscriptionWhereInput
  ) => WednesdaySubscriptionPayloadSubscription;
  city: (
    where?: citySubscriptionWhereInput
  ) => citySubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AdsOrderByInput =
  | "city_ASC"
  | "city_DESC"
  | "id_ASC"
  | "id_DESC"
  | "imageurl_ASC"
  | "imageurl_DESC"
  | "visible_ASC"
  | "visible_DESC";

export type BlogOrderByInput =
  | "authorImg_ASC"
  | "authorImg_DESC"
  | "authorName_ASC"
  | "authorName_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdon_ASC"
  | "createdon_DESC"
  | "id_ASC"
  | "id_DESC"
  | "summary_ASC"
  | "summary_DESC"
  | "title_ASC"
  | "title_DESC"
  | "titleImg_ASC"
  | "titleImg_DESC";

export type RestaurantsOrderByInput =
  | "city_ASC"
  | "city_DESC"
  | "id_ASC"
  | "id_DESC"
  | "enableLoginAccess_ASC"
  | "enableLoginAccess_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "rating_ASC"
  | "rating_DESC"
  | "imageurl_ASC"
  | "imageurl_DESC"
  | "googlemapsurl_ASC"
  | "googlemapsurl_DESC"
  | "state_ASC"
  | "state_DESC"
  | "about_ASC"
  | "about_DESC"
  | "address_ASC"
  | "address_DESC"
  | "conditions_ASC"
  | "conditions_DESC"
  | "remail_ASC"
  | "remail_DESC"
  | "latitude_ASC"
  | "latitude_DESC"
  | "longitude_ASC"
  | "longitude_DESC"
  | "acceptsRenoPay_ASC"
  | "acceptsRenoPay_DESC"
  | "renoCommision_ASC"
  | "renoCommision_DESC";

export type OrdersOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "totalDiscount_ASC"
  | "totalDiscount_DESC"
  | "people_ASC"
  | "people_DESC"
  | "bookingid_ASC"
  | "bookingid_DESC"
  | "mobile_ASC"
  | "mobile_DESC"
  | "unlockActive_ASC"
  | "unlockActive_DESC"
  | "name_ASC"
  | "name_DESC"
  | "geolocation_ASC"
  | "geolocation_DESC"
  | "referrer_ASC"
  | "referrer_DESC"
  | "confirmed_ASC"
  | "confirmed_DESC"
  | "cancelled_ASC"
  | "cancelled_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "receipt_ASC"
  | "receipt_DESC"
  | "paymentId_ASC"
  | "paymentId_DESC"
  | "paymentOrderId_ASC"
  | "paymentOrderId_DESC"
  | "paymentDescription_ASC"
  | "paymentDescription_DESC";

export type TimeDiscountOrderByInput =
  | "discount_ASC"
  | "discount_DESC"
  | "id_ASC"
  | "id_DESC"
  | "time_ASC"
  | "time_DESC"
  | "daychange_ASC"
  | "daychange_DESC"
  | "day_ASC"
  | "day_DESC"
  | "newtime_ASC"
  | "newtime_DESC"
  | "newdiscount_ASC"
  | "newdiscount_DESC"
  | "exhausted_ASC"
  | "exhausted_DESC"
  | "tueExhaust_ASC"
  | "tueExhaust_DESC"
  | "monExhaust_ASC"
  | "monExhaust_DESC"
  | "wedExhaust_ASC"
  | "wedExhaust_DESC"
  | "thuExhaust_ASC"
  | "thuExhaust_DESC"
  | "friExhaust_ASC"
  | "friExhaust_DESC"
  | "satExhaust_ASC"
  | "satExhaust_DESC"
  | "sunExhaust_ASC"
  | "sunExhaust_DESC"
  | "monDiscount_ASC"
  | "monDiscount_DESC"
  | "tueDiscount_ASC"
  | "tueDiscount_DESC"
  | "wedDiscount_ASC"
  | "wedDiscount_DESC"
  | "thuDiscount_ASC"
  | "thuDiscount_DESC"
  | "friDiscount_ASC"
  | "friDiscount_DESC"
  | "satDiscount_ASC"
  | "satDiscount_DESC"
  | "sunDiscount_ASC"
  | "sunDiscount_DESC";

export type UserReviewsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "review_ASC"
  | "review_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "rating_ASC"
  | "rating_DESC";

export type RestaurantTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "imageurl_ASC"
  | "imageurl_DESC"
  | "order_ASC"
  | "order_DESC"
  | "typeName_ASC"
  | "typeName_DESC"
  | "cityImage_ASC"
  | "cityImage_DESC"
  | "activatePremium_ASC"
  | "activatePremium_DESC"
  | "premiumPrice_ASC"
  | "premiumPrice_DESC";

export type HotDealsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "imageurl_ASC"
  | "imageurl_DESC";

export type BrandTileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "imageurl_ASC"
  | "imageurl_DESC"
  | "order_ASC"
  | "order_DESC"
  | "brandTileName_ASC"
  | "brandTileName_DESC";

export type ContactsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "name_ASC"
  | "name_DESC"
  | "address_ASC"
  | "address_DESC"
  | "email_ASC"
  | "email_DESC";

export type FileOrderByInput =
  | "contentType_ASC"
  | "contentType_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "secret_ASC"
  | "secret_DESC"
  | "size_ASC"
  | "size_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "url_ASC"
  | "url_DESC";

export type FridayOrderByInput =
  | "exhausted_ASC"
  | "exhausted_DESC"
  | "id_ASC"
  | "id_DESC"
  | "order_ASC"
  | "order_DESC";

export type MiscOrderByInput =
  | "faq_ASC"
  | "faq_DESC"
  | "fup_ASC"
  | "fup_DESC"
  | "id_ASC"
  | "id_DESC";

export type MondayOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "exhausted_ASC"
  | "exhausted_DESC"
  | "order_ASC"
  | "order_DESC";

export type SaturdayOrderByInput =
  | "exhausted_ASC"
  | "exhausted_DESC"
  | "id_ASC"
  | "id_DESC"
  | "order_ASC"
  | "order_DESC";

export type SundayOrderByInput =
  | "exhausted_ASC"
  | "exhausted_DESC"
  | "id_ASC"
  | "id_DESC"
  | "order_ASC"
  | "order_DESC";

export type ThursdayOrderByInput =
  | "exhausted_ASC"
  | "exhausted_DESC"
  | "id_ASC"
  | "id_DESC"
  | "order_ASC"
  | "order_DESC";

export type TuesdayOrderByInput =
  | "exhausted_ASC"
  | "exhausted_DESC"
  | "id_ASC"
  | "id_DESC"
  | "order_ASC"
  | "order_DESC";

export type UserOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "firstname_ASC"
  | "firstname_DESC"
  | "id_ASC"
  | "id_DESC"
  | "facebookID_ASC"
  | "facebookID_DESC"
  | "lastname_ASC"
  | "lastname_DESC"
  | "mobile_ASC"
  | "mobile_DESC"
  | "totalOrders_ASC"
  | "totalOrders_DESC"
  | "contactSync_ASC"
  | "contactSync_DESC"
  | "isBlocked_ASC"
  | "isBlocked_DESC"
  | "promoCode_ASC"
  | "promoCode_DESC"
  | "userPromoCount_ASC"
  | "userPromoCount_DESC"
  | "typeAccess_ASC"
  | "typeAccess_DESC"
  | "password_ASC"
  | "password_DESC"
  | "installLocation_ASC"
  | "installLocation_DESC"
  | "isPremiumUser_ASC"
  | "isPremiumUser_DESC"
  | "currentLocation_ASC"
  | "currentLocation_DESC"
  | "profileImage_ASC"
  | "profileImage_DESC"
  | "bookingOtp_ASC"
  | "bookingOtp_DESC"
  | "otpExpires_ASC"
  | "otpExpires_DESC"
  | "premiumStartDate_ASC"
  | "premiumStartDate_DESC"
  | "premiumExpireDate_ASC"
  | "premiumExpireDate_DESC";

export type WednesdayOrderByInput =
  | "exhausted_ASC"
  | "exhausted_DESC"
  | "id_ASC"
  | "id_DESC"
  | "order_ASC"
  | "order_DESC";

export type cityOrderByInput =
  | "city_ASC"
  | "city_DESC"
  | "isPremium_ASC"
  | "isPremium_DESC"
  | "id_ASC"
  | "id_DESC"
  | "premiumAmmount90_ASC"
  | "premiumAmmount90_DESC"
  | "premiumAmmount180_ASC"
  | "premiumAmmount180_DESC"
  | "premiumAmmount360_ASC"
  | "premiumAmmount360_DESC"
  | "imageUrl_ASC"
  | "imageUrl_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AdsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AdsWhereInput {
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  imageurl?: Maybe<String>;
  imageurl_not?: Maybe<String>;
  imageurl_in?: Maybe<String[] | String>;
  imageurl_not_in?: Maybe<String[] | String>;
  imageurl_lt?: Maybe<String>;
  imageurl_lte?: Maybe<String>;
  imageurl_gt?: Maybe<String>;
  imageurl_gte?: Maybe<String>;
  imageurl_contains?: Maybe<String>;
  imageurl_not_contains?: Maybe<String>;
  imageurl_starts_with?: Maybe<String>;
  imageurl_not_starts_with?: Maybe<String>;
  imageurl_ends_with?: Maybe<String>;
  imageurl_not_ends_with?: Maybe<String>;
  visible?: Maybe<Boolean>;
  visible_not?: Maybe<Boolean>;
  AND?: Maybe<AdsWhereInput[] | AdsWhereInput>;
  OR?: Maybe<AdsWhereInput[] | AdsWhereInput>;
  NOT?: Maybe<AdsWhereInput[] | AdsWhereInput>;
}

export type BlogWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BlogWhereInput {
  authorImg?: Maybe<String>;
  authorImg_not?: Maybe<String>;
  authorImg_in?: Maybe<String[] | String>;
  authorImg_not_in?: Maybe<String[] | String>;
  authorImg_lt?: Maybe<String>;
  authorImg_lte?: Maybe<String>;
  authorImg_gt?: Maybe<String>;
  authorImg_gte?: Maybe<String>;
  authorImg_contains?: Maybe<String>;
  authorImg_not_contains?: Maybe<String>;
  authorImg_starts_with?: Maybe<String>;
  authorImg_not_starts_with?: Maybe<String>;
  authorImg_ends_with?: Maybe<String>;
  authorImg_not_ends_with?: Maybe<String>;
  authorName?: Maybe<String>;
  authorName_not?: Maybe<String>;
  authorName_in?: Maybe<String[] | String>;
  authorName_not_in?: Maybe<String[] | String>;
  authorName_lt?: Maybe<String>;
  authorName_lte?: Maybe<String>;
  authorName_gt?: Maybe<String>;
  authorName_gte?: Maybe<String>;
  authorName_contains?: Maybe<String>;
  authorName_not_contains?: Maybe<String>;
  authorName_starts_with?: Maybe<String>;
  authorName_not_starts_with?: Maybe<String>;
  authorName_ends_with?: Maybe<String>;
  authorName_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdon?: Maybe<DateTimeInput>;
  createdon_not?: Maybe<DateTimeInput>;
  createdon_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdon_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdon_lt?: Maybe<DateTimeInput>;
  createdon_lte?: Maybe<DateTimeInput>;
  createdon_gt?: Maybe<DateTimeInput>;
  createdon_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  summary?: Maybe<String>;
  summary_not?: Maybe<String>;
  summary_in?: Maybe<String[] | String>;
  summary_not_in?: Maybe<String[] | String>;
  summary_lt?: Maybe<String>;
  summary_lte?: Maybe<String>;
  summary_gt?: Maybe<String>;
  summary_gte?: Maybe<String>;
  summary_contains?: Maybe<String>;
  summary_not_contains?: Maybe<String>;
  summary_starts_with?: Maybe<String>;
  summary_not_starts_with?: Maybe<String>;
  summary_ends_with?: Maybe<String>;
  summary_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  titleImg?: Maybe<String>;
  titleImg_not?: Maybe<String>;
  titleImg_in?: Maybe<String[] | String>;
  titleImg_not_in?: Maybe<String[] | String>;
  titleImg_lt?: Maybe<String>;
  titleImg_lte?: Maybe<String>;
  titleImg_gt?: Maybe<String>;
  titleImg_gte?: Maybe<String>;
  titleImg_contains?: Maybe<String>;
  titleImg_not_contains?: Maybe<String>;
  titleImg_starts_with?: Maybe<String>;
  titleImg_not_starts_with?: Maybe<String>;
  titleImg_ends_with?: Maybe<String>;
  titleImg_not_ends_with?: Maybe<String>;
  AND?: Maybe<BlogWhereInput[] | BlogWhereInput>;
  OR?: Maybe<BlogWhereInput[] | BlogWhereInput>;
  NOT?: Maybe<BlogWhereInput[] | BlogWhereInput>;
}

export type BrandTileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RestaurantsWhereInput {
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  enableLoginAccess?: Maybe<Boolean>;
  enableLoginAccess_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  orderses_every?: Maybe<OrdersWhereInput>;
  orderses_some?: Maybe<OrdersWhereInput>;
  orderses_none?: Maybe<OrdersWhereInput>;
  rating?: Maybe<Float>;
  rating_not?: Maybe<Float>;
  rating_in?: Maybe<Float[] | Float>;
  rating_not_in?: Maybe<Float[] | Float>;
  rating_lt?: Maybe<Float>;
  rating_lte?: Maybe<Float>;
  rating_gt?: Maybe<Float>;
  rating_gte?: Maybe<Float>;
  imageurl?: Maybe<String>;
  imageurl_not?: Maybe<String>;
  imageurl_in?: Maybe<String[] | String>;
  imageurl_not_in?: Maybe<String[] | String>;
  imageurl_lt?: Maybe<String>;
  imageurl_lte?: Maybe<String>;
  imageurl_gt?: Maybe<String>;
  imageurl_gte?: Maybe<String>;
  imageurl_contains?: Maybe<String>;
  imageurl_not_contains?: Maybe<String>;
  imageurl_starts_with?: Maybe<String>;
  imageurl_not_starts_with?: Maybe<String>;
  imageurl_ends_with?: Maybe<String>;
  imageurl_not_ends_with?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  googlemapsurl_not?: Maybe<String>;
  googlemapsurl_in?: Maybe<String[] | String>;
  googlemapsurl_not_in?: Maybe<String[] | String>;
  googlemapsurl_lt?: Maybe<String>;
  googlemapsurl_lte?: Maybe<String>;
  googlemapsurl_gt?: Maybe<String>;
  googlemapsurl_gte?: Maybe<String>;
  googlemapsurl_contains?: Maybe<String>;
  googlemapsurl_not_contains?: Maybe<String>;
  googlemapsurl_starts_with?: Maybe<String>;
  googlemapsurl_not_starts_with?: Maybe<String>;
  googlemapsurl_ends_with?: Maybe<String>;
  googlemapsurl_not_ends_with?: Maybe<String>;
  restaurantTypes_every?: Maybe<RestaurantTypeWhereInput>;
  restaurantTypes_some?: Maybe<RestaurantTypeWhereInput>;
  restaurantTypes_none?: Maybe<RestaurantTypeWhereInput>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  timeDiscounts_every?: Maybe<TimeDiscountWhereInput>;
  timeDiscounts_some?: Maybe<TimeDiscountWhereInput>;
  timeDiscounts_none?: Maybe<TimeDiscountWhereInput>;
  about?: Maybe<String>;
  about_not?: Maybe<String>;
  about_in?: Maybe<String[] | String>;
  about_not_in?: Maybe<String[] | String>;
  about_lt?: Maybe<String>;
  about_lte?: Maybe<String>;
  about_gt?: Maybe<String>;
  about_gte?: Maybe<String>;
  about_contains?: Maybe<String>;
  about_not_contains?: Maybe<String>;
  about_starts_with?: Maybe<String>;
  about_not_starts_with?: Maybe<String>;
  about_ends_with?: Maybe<String>;
  about_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  userReviewses_every?: Maybe<UserReviewsWhereInput>;
  userReviewses_some?: Maybe<UserReviewsWhereInput>;
  userReviewses_none?: Maybe<UserReviewsWhereInput>;
  hotDealses_every?: Maybe<HotDealsWhereInput>;
  hotDealses_some?: Maybe<HotDealsWhereInput>;
  hotDealses_none?: Maybe<HotDealsWhereInput>;
  conditions?: Maybe<String>;
  conditions_not?: Maybe<String>;
  conditions_in?: Maybe<String[] | String>;
  conditions_not_in?: Maybe<String[] | String>;
  conditions_lt?: Maybe<String>;
  conditions_lte?: Maybe<String>;
  conditions_gt?: Maybe<String>;
  conditions_gte?: Maybe<String>;
  conditions_contains?: Maybe<String>;
  conditions_not_contains?: Maybe<String>;
  conditions_starts_with?: Maybe<String>;
  conditions_not_starts_with?: Maybe<String>;
  conditions_ends_with?: Maybe<String>;
  conditions_not_ends_with?: Maybe<String>;
  remail?: Maybe<String>;
  remail_not?: Maybe<String>;
  remail_in?: Maybe<String[] | String>;
  remail_not_in?: Maybe<String[] | String>;
  remail_lt?: Maybe<String>;
  remail_lte?: Maybe<String>;
  remail_gt?: Maybe<String>;
  remail_gte?: Maybe<String>;
  remail_contains?: Maybe<String>;
  remail_not_contains?: Maybe<String>;
  remail_starts_with?: Maybe<String>;
  remail_not_starts_with?: Maybe<String>;
  remail_ends_with?: Maybe<String>;
  remail_not_ends_with?: Maybe<String>;
  friday?: Maybe<FridayWhereInput>;
  monday?: Maybe<MondayWhereInput>;
  saturday?: Maybe<SaturdayWhereInput>;
  sunday?: Maybe<SundayWhereInput>;
  thursday?: Maybe<ThursdayWhereInput>;
  tuesday?: Maybe<TuesdayWhereInput>;
  wednesday?: Maybe<WednesdayWhereInput>;
  latitude?: Maybe<Float>;
  latitude_not?: Maybe<Float>;
  latitude_in?: Maybe<Float[] | Float>;
  latitude_not_in?: Maybe<Float[] | Float>;
  latitude_lt?: Maybe<Float>;
  latitude_lte?: Maybe<Float>;
  latitude_gt?: Maybe<Float>;
  latitude_gte?: Maybe<Float>;
  longitude?: Maybe<Float>;
  longitude_not?: Maybe<Float>;
  longitude_in?: Maybe<Float[] | Float>;
  longitude_not_in?: Maybe<Float[] | Float>;
  longitude_lt?: Maybe<Float>;
  longitude_lte?: Maybe<Float>;
  longitude_gt?: Maybe<Float>;
  longitude_gte?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  acceptsRenoPay_not?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  renoCommision_not?: Maybe<Int>;
  renoCommision_in?: Maybe<Int[] | Int>;
  renoCommision_not_in?: Maybe<Int[] | Int>;
  renoCommision_lt?: Maybe<Int>;
  renoCommision_lte?: Maybe<Int>;
  renoCommision_gt?: Maybe<Int>;
  renoCommision_gte?: Maybe<Int>;
  brandTile?: Maybe<BrandTileWhereInput>;
  AND?: Maybe<RestaurantsWhereInput[] | RestaurantsWhereInput>;
  OR?: Maybe<RestaurantsWhereInput[] | RestaurantsWhereInput>;
  NOT?: Maybe<RestaurantsWhereInput[] | RestaurantsWhereInput>;
}

export interface OrdersWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsWhereInput>;
  timeDiscount?: Maybe<TimeDiscountWhereInput>;
  user?: Maybe<UserWhereInput>;
  date?: Maybe<String>;
  date_not?: Maybe<String>;
  date_in?: Maybe<String[] | String>;
  date_not_in?: Maybe<String[] | String>;
  date_lt?: Maybe<String>;
  date_lte?: Maybe<String>;
  date_gt?: Maybe<String>;
  date_gte?: Maybe<String>;
  date_contains?: Maybe<String>;
  date_not_contains?: Maybe<String>;
  date_starts_with?: Maybe<String>;
  date_not_starts_with?: Maybe<String>;
  date_ends_with?: Maybe<String>;
  date_not_ends_with?: Maybe<String>;
  totalDiscount?: Maybe<Int>;
  totalDiscount_not?: Maybe<Int>;
  totalDiscount_in?: Maybe<Int[] | Int>;
  totalDiscount_not_in?: Maybe<Int[] | Int>;
  totalDiscount_lt?: Maybe<Int>;
  totalDiscount_lte?: Maybe<Int>;
  totalDiscount_gt?: Maybe<Int>;
  totalDiscount_gte?: Maybe<Int>;
  people?: Maybe<Int>;
  people_not?: Maybe<Int>;
  people_in?: Maybe<Int[] | Int>;
  people_not_in?: Maybe<Int[] | Int>;
  people_lt?: Maybe<Int>;
  people_lte?: Maybe<Int>;
  people_gt?: Maybe<Int>;
  people_gte?: Maybe<Int>;
  bookingid?: Maybe<String>;
  bookingid_not?: Maybe<String>;
  bookingid_in?: Maybe<String[] | String>;
  bookingid_not_in?: Maybe<String[] | String>;
  bookingid_lt?: Maybe<String>;
  bookingid_lte?: Maybe<String>;
  bookingid_gt?: Maybe<String>;
  bookingid_gte?: Maybe<String>;
  bookingid_contains?: Maybe<String>;
  bookingid_not_contains?: Maybe<String>;
  bookingid_starts_with?: Maybe<String>;
  bookingid_not_starts_with?: Maybe<String>;
  bookingid_ends_with?: Maybe<String>;
  bookingid_not_ends_with?: Maybe<String>;
  mobile?: Maybe<String>;
  mobile_not?: Maybe<String>;
  mobile_in?: Maybe<String[] | String>;
  mobile_not_in?: Maybe<String[] | String>;
  mobile_lt?: Maybe<String>;
  mobile_lte?: Maybe<String>;
  mobile_gt?: Maybe<String>;
  mobile_gte?: Maybe<String>;
  mobile_contains?: Maybe<String>;
  mobile_not_contains?: Maybe<String>;
  mobile_starts_with?: Maybe<String>;
  mobile_not_starts_with?: Maybe<String>;
  mobile_ends_with?: Maybe<String>;
  mobile_not_ends_with?: Maybe<String>;
  unlockActive?: Maybe<Boolean>;
  unlockActive_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  geolocation?: Maybe<String>;
  geolocation_not?: Maybe<String>;
  geolocation_in?: Maybe<String[] | String>;
  geolocation_not_in?: Maybe<String[] | String>;
  geolocation_lt?: Maybe<String>;
  geolocation_lte?: Maybe<String>;
  geolocation_gt?: Maybe<String>;
  geolocation_gte?: Maybe<String>;
  geolocation_contains?: Maybe<String>;
  geolocation_not_contains?: Maybe<String>;
  geolocation_starts_with?: Maybe<String>;
  geolocation_not_starts_with?: Maybe<String>;
  geolocation_ends_with?: Maybe<String>;
  geolocation_not_ends_with?: Maybe<String>;
  referrer?: Maybe<String>;
  referrer_not?: Maybe<String>;
  referrer_in?: Maybe<String[] | String>;
  referrer_not_in?: Maybe<String[] | String>;
  referrer_lt?: Maybe<String>;
  referrer_lte?: Maybe<String>;
  referrer_gt?: Maybe<String>;
  referrer_gte?: Maybe<String>;
  referrer_contains?: Maybe<String>;
  referrer_not_contains?: Maybe<String>;
  referrer_starts_with?: Maybe<String>;
  referrer_not_starts_with?: Maybe<String>;
  referrer_ends_with?: Maybe<String>;
  referrer_not_ends_with?: Maybe<String>;
  confirmed?: Maybe<Boolean>;
  confirmed_not?: Maybe<Boolean>;
  cancelled?: Maybe<Boolean>;
  cancelled_not?: Maybe<Boolean>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  receipt?: Maybe<String>;
  receipt_not?: Maybe<String>;
  receipt_in?: Maybe<String[] | String>;
  receipt_not_in?: Maybe<String[] | String>;
  receipt_lt?: Maybe<String>;
  receipt_lte?: Maybe<String>;
  receipt_gt?: Maybe<String>;
  receipt_gte?: Maybe<String>;
  receipt_contains?: Maybe<String>;
  receipt_not_contains?: Maybe<String>;
  receipt_starts_with?: Maybe<String>;
  receipt_not_starts_with?: Maybe<String>;
  receipt_ends_with?: Maybe<String>;
  receipt_not_ends_with?: Maybe<String>;
  paymentId?: Maybe<String>;
  paymentId_not?: Maybe<String>;
  paymentId_in?: Maybe<String[] | String>;
  paymentId_not_in?: Maybe<String[] | String>;
  paymentId_lt?: Maybe<String>;
  paymentId_lte?: Maybe<String>;
  paymentId_gt?: Maybe<String>;
  paymentId_gte?: Maybe<String>;
  paymentId_contains?: Maybe<String>;
  paymentId_not_contains?: Maybe<String>;
  paymentId_starts_with?: Maybe<String>;
  paymentId_not_starts_with?: Maybe<String>;
  paymentId_ends_with?: Maybe<String>;
  paymentId_not_ends_with?: Maybe<String>;
  paymentOrderId?: Maybe<String>;
  paymentOrderId_not?: Maybe<String>;
  paymentOrderId_in?: Maybe<String[] | String>;
  paymentOrderId_not_in?: Maybe<String[] | String>;
  paymentOrderId_lt?: Maybe<String>;
  paymentOrderId_lte?: Maybe<String>;
  paymentOrderId_gt?: Maybe<String>;
  paymentOrderId_gte?: Maybe<String>;
  paymentOrderId_contains?: Maybe<String>;
  paymentOrderId_not_contains?: Maybe<String>;
  paymentOrderId_starts_with?: Maybe<String>;
  paymentOrderId_not_starts_with?: Maybe<String>;
  paymentOrderId_ends_with?: Maybe<String>;
  paymentOrderId_not_ends_with?: Maybe<String>;
  paymentDescription?: Maybe<String>;
  paymentDescription_not?: Maybe<String>;
  paymentDescription_in?: Maybe<String[] | String>;
  paymentDescription_not_in?: Maybe<String[] | String>;
  paymentDescription_lt?: Maybe<String>;
  paymentDescription_lte?: Maybe<String>;
  paymentDescription_gt?: Maybe<String>;
  paymentDescription_gte?: Maybe<String>;
  paymentDescription_contains?: Maybe<String>;
  paymentDescription_not_contains?: Maybe<String>;
  paymentDescription_starts_with?: Maybe<String>;
  paymentDescription_not_starts_with?: Maybe<String>;
  paymentDescription_ends_with?: Maybe<String>;
  paymentDescription_not_ends_with?: Maybe<String>;
  AND?: Maybe<OrdersWhereInput[] | OrdersWhereInput>;
  OR?: Maybe<OrdersWhereInput[] | OrdersWhereInput>;
  NOT?: Maybe<OrdersWhereInput[] | OrdersWhereInput>;
}

export interface TimeDiscountWhereInput {
  discount?: Maybe<Float>;
  discount_not?: Maybe<Float>;
  discount_in?: Maybe<Float[] | Float>;
  discount_not_in?: Maybe<Float[] | Float>;
  discount_lt?: Maybe<Float>;
  discount_lte?: Maybe<Float>;
  discount_gt?: Maybe<Float>;
  discount_gte?: Maybe<Float>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  orderses_every?: Maybe<OrdersWhereInput>;
  orderses_some?: Maybe<OrdersWhereInput>;
  orderses_none?: Maybe<OrdersWhereInput>;
  restaurants?: Maybe<RestaurantsWhereInput>;
  time?: Maybe<String>;
  time_not?: Maybe<String>;
  time_in?: Maybe<String[] | String>;
  time_not_in?: Maybe<String[] | String>;
  time_lt?: Maybe<String>;
  time_lte?: Maybe<String>;
  time_gt?: Maybe<String>;
  time_gte?: Maybe<String>;
  time_contains?: Maybe<String>;
  time_not_contains?: Maybe<String>;
  time_starts_with?: Maybe<String>;
  time_not_starts_with?: Maybe<String>;
  time_ends_with?: Maybe<String>;
  time_not_ends_with?: Maybe<String>;
  daychange?: Maybe<Boolean>;
  daychange_not?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  day_not?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newtime_not?: Maybe<String>;
  newtime_in?: Maybe<String[] | String>;
  newtime_not_in?: Maybe<String[] | String>;
  newtime_lt?: Maybe<String>;
  newtime_lte?: Maybe<String>;
  newtime_gt?: Maybe<String>;
  newtime_gte?: Maybe<String>;
  newtime_contains?: Maybe<String>;
  newtime_not_contains?: Maybe<String>;
  newtime_starts_with?: Maybe<String>;
  newtime_not_starts_with?: Maybe<String>;
  newtime_ends_with?: Maybe<String>;
  newtime_not_ends_with?: Maybe<String>;
  newdiscount?: Maybe<String>;
  newdiscount_not?: Maybe<String>;
  newdiscount_in?: Maybe<String[] | String>;
  newdiscount_not_in?: Maybe<String[] | String>;
  newdiscount_lt?: Maybe<String>;
  newdiscount_lte?: Maybe<String>;
  newdiscount_gt?: Maybe<String>;
  newdiscount_gte?: Maybe<String>;
  newdiscount_contains?: Maybe<String>;
  newdiscount_not_contains?: Maybe<String>;
  newdiscount_starts_with?: Maybe<String>;
  newdiscount_not_starts_with?: Maybe<String>;
  newdiscount_ends_with?: Maybe<String>;
  newdiscount_not_ends_with?: Maybe<String>;
  friday?: Maybe<FridayWhereInput>;
  monday?: Maybe<MondayWhereInput>;
  saturday?: Maybe<SaturdayWhereInput>;
  sunday?: Maybe<SundayWhereInput>;
  thursday?: Maybe<ThursdayWhereInput>;
  tuesday?: Maybe<TuesdayWhereInput>;
  wednesday?: Maybe<WednesdayWhereInput>;
  exhausted?: Maybe<Boolean>;
  exhausted_not?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  tueExhaust_not?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  monExhaust_not?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  wedExhaust_not?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  thuExhaust_not?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  friExhaust_not?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  satExhaust_not?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  sunExhaust_not?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  monDiscount_not?: Maybe<Float>;
  monDiscount_in?: Maybe<Float[] | Float>;
  monDiscount_not_in?: Maybe<Float[] | Float>;
  monDiscount_lt?: Maybe<Float>;
  monDiscount_lte?: Maybe<Float>;
  monDiscount_gt?: Maybe<Float>;
  monDiscount_gte?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  tueDiscount_not?: Maybe<Float>;
  tueDiscount_in?: Maybe<Float[] | Float>;
  tueDiscount_not_in?: Maybe<Float[] | Float>;
  tueDiscount_lt?: Maybe<Float>;
  tueDiscount_lte?: Maybe<Float>;
  tueDiscount_gt?: Maybe<Float>;
  tueDiscount_gte?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  wedDiscount_not?: Maybe<Float>;
  wedDiscount_in?: Maybe<Float[] | Float>;
  wedDiscount_not_in?: Maybe<Float[] | Float>;
  wedDiscount_lt?: Maybe<Float>;
  wedDiscount_lte?: Maybe<Float>;
  wedDiscount_gt?: Maybe<Float>;
  wedDiscount_gte?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  thuDiscount_not?: Maybe<Float>;
  thuDiscount_in?: Maybe<Float[] | Float>;
  thuDiscount_not_in?: Maybe<Float[] | Float>;
  thuDiscount_lt?: Maybe<Float>;
  thuDiscount_lte?: Maybe<Float>;
  thuDiscount_gt?: Maybe<Float>;
  thuDiscount_gte?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  friDiscount_not?: Maybe<Float>;
  friDiscount_in?: Maybe<Float[] | Float>;
  friDiscount_not_in?: Maybe<Float[] | Float>;
  friDiscount_lt?: Maybe<Float>;
  friDiscount_lte?: Maybe<Float>;
  friDiscount_gt?: Maybe<Float>;
  friDiscount_gte?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  satDiscount_not?: Maybe<Float>;
  satDiscount_in?: Maybe<Float[] | Float>;
  satDiscount_not_in?: Maybe<Float[] | Float>;
  satDiscount_lt?: Maybe<Float>;
  satDiscount_lte?: Maybe<Float>;
  satDiscount_gt?: Maybe<Float>;
  satDiscount_gte?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
  sunDiscount_not?: Maybe<Float>;
  sunDiscount_in?: Maybe<Float[] | Float>;
  sunDiscount_not_in?: Maybe<Float[] | Float>;
  sunDiscount_lt?: Maybe<Float>;
  sunDiscount_lte?: Maybe<Float>;
  sunDiscount_gt?: Maybe<Float>;
  sunDiscount_gte?: Maybe<Float>;
  AND?: Maybe<TimeDiscountWhereInput[] | TimeDiscountWhereInput>;
  OR?: Maybe<TimeDiscountWhereInput[] | TimeDiscountWhereInput>;
  NOT?: Maybe<TimeDiscountWhereInput[] | TimeDiscountWhereInput>;
}

export interface FridayWhereInput {
  exhausted?: Maybe<Boolean>;
  exhausted_not?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsWhereInput>;
  timeDiscounts_every?: Maybe<TimeDiscountWhereInput>;
  timeDiscounts_some?: Maybe<TimeDiscountWhereInput>;
  timeDiscounts_none?: Maybe<TimeDiscountWhereInput>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<FridayWhereInput[] | FridayWhereInput>;
  OR?: Maybe<FridayWhereInput[] | FridayWhereInput>;
  NOT?: Maybe<FridayWhereInput[] | FridayWhereInput>;
}

export interface MondayWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  exhausted?: Maybe<Boolean>;
  exhausted_not?: Maybe<Boolean>;
  restaurants?: Maybe<RestaurantsWhereInput>;
  timeDiscounts_every?: Maybe<TimeDiscountWhereInput>;
  timeDiscounts_some?: Maybe<TimeDiscountWhereInput>;
  timeDiscounts_none?: Maybe<TimeDiscountWhereInput>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<MondayWhereInput[] | MondayWhereInput>;
  OR?: Maybe<MondayWhereInput[] | MondayWhereInput>;
  NOT?: Maybe<MondayWhereInput[] | MondayWhereInput>;
}

export interface SaturdayWhereInput {
  exhausted?: Maybe<Boolean>;
  exhausted_not?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsWhereInput>;
  timeDiscounts_every?: Maybe<TimeDiscountWhereInput>;
  timeDiscounts_some?: Maybe<TimeDiscountWhereInput>;
  timeDiscounts_none?: Maybe<TimeDiscountWhereInput>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<SaturdayWhereInput[] | SaturdayWhereInput>;
  OR?: Maybe<SaturdayWhereInput[] | SaturdayWhereInput>;
  NOT?: Maybe<SaturdayWhereInput[] | SaturdayWhereInput>;
}

export interface SundayWhereInput {
  exhausted?: Maybe<Boolean>;
  exhausted_not?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsWhereInput>;
  timeDiscounts_every?: Maybe<TimeDiscountWhereInput>;
  timeDiscounts_some?: Maybe<TimeDiscountWhereInput>;
  timeDiscounts_none?: Maybe<TimeDiscountWhereInput>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<SundayWhereInput[] | SundayWhereInput>;
  OR?: Maybe<SundayWhereInput[] | SundayWhereInput>;
  NOT?: Maybe<SundayWhereInput[] | SundayWhereInput>;
}

export interface ThursdayWhereInput {
  exhausted?: Maybe<Boolean>;
  exhausted_not?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  restaurants?: Maybe<RestaurantsWhereInput>;
  timeDiscounts_every?: Maybe<TimeDiscountWhereInput>;
  timeDiscounts_some?: Maybe<TimeDiscountWhereInput>;
  timeDiscounts_none?: Maybe<TimeDiscountWhereInput>;
  AND?: Maybe<ThursdayWhereInput[] | ThursdayWhereInput>;
  OR?: Maybe<ThursdayWhereInput[] | ThursdayWhereInput>;
  NOT?: Maybe<ThursdayWhereInput[] | ThursdayWhereInput>;
}

export interface TuesdayWhereInput {
  exhausted?: Maybe<Boolean>;
  exhausted_not?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsWhereInput>;
  timeDiscounts_every?: Maybe<TimeDiscountWhereInput>;
  timeDiscounts_some?: Maybe<TimeDiscountWhereInput>;
  timeDiscounts_none?: Maybe<TimeDiscountWhereInput>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<TuesdayWhereInput[] | TuesdayWhereInput>;
  OR?: Maybe<TuesdayWhereInput[] | TuesdayWhereInput>;
  NOT?: Maybe<TuesdayWhereInput[] | TuesdayWhereInput>;
}

export interface WednesdayWhereInput {
  exhausted?: Maybe<Boolean>;
  exhausted_not?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsWhereInput>;
  timeDiscounts_every?: Maybe<TimeDiscountWhereInput>;
  timeDiscounts_some?: Maybe<TimeDiscountWhereInput>;
  timeDiscounts_none?: Maybe<TimeDiscountWhereInput>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<WednesdayWhereInput[] | WednesdayWhereInput>;
  OR?: Maybe<WednesdayWhereInput[] | WednesdayWhereInput>;
  NOT?: Maybe<WednesdayWhereInput[] | WednesdayWhereInput>;
}

export interface UserWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  firstname?: Maybe<String>;
  firstname_not?: Maybe<String>;
  firstname_in?: Maybe<String[] | String>;
  firstname_not_in?: Maybe<String[] | String>;
  firstname_lt?: Maybe<String>;
  firstname_lte?: Maybe<String>;
  firstname_gt?: Maybe<String>;
  firstname_gte?: Maybe<String>;
  firstname_contains?: Maybe<String>;
  firstname_not_contains?: Maybe<String>;
  firstname_starts_with?: Maybe<String>;
  firstname_not_starts_with?: Maybe<String>;
  firstname_ends_with?: Maybe<String>;
  firstname_not_ends_with?: Maybe<String>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  facebookID?: Maybe<String>;
  facebookID_not?: Maybe<String>;
  facebookID_in?: Maybe<String[] | String>;
  facebookID_not_in?: Maybe<String[] | String>;
  facebookID_lt?: Maybe<String>;
  facebookID_lte?: Maybe<String>;
  facebookID_gt?: Maybe<String>;
  facebookID_gte?: Maybe<String>;
  facebookID_contains?: Maybe<String>;
  facebookID_not_contains?: Maybe<String>;
  facebookID_starts_with?: Maybe<String>;
  facebookID_not_starts_with?: Maybe<String>;
  facebookID_ends_with?: Maybe<String>;
  facebookID_not_ends_with?: Maybe<String>;
  lastname?: Maybe<String>;
  lastname_not?: Maybe<String>;
  lastname_in?: Maybe<String[] | String>;
  lastname_not_in?: Maybe<String[] | String>;
  lastname_lt?: Maybe<String>;
  lastname_lte?: Maybe<String>;
  lastname_gt?: Maybe<String>;
  lastname_gte?: Maybe<String>;
  lastname_contains?: Maybe<String>;
  lastname_not_contains?: Maybe<String>;
  lastname_starts_with?: Maybe<String>;
  lastname_not_starts_with?: Maybe<String>;
  lastname_ends_with?: Maybe<String>;
  lastname_not_ends_with?: Maybe<String>;
  mobile?: Maybe<String>;
  mobile_not?: Maybe<String>;
  mobile_in?: Maybe<String[] | String>;
  mobile_not_in?: Maybe<String[] | String>;
  mobile_lt?: Maybe<String>;
  mobile_lte?: Maybe<String>;
  mobile_gt?: Maybe<String>;
  mobile_gte?: Maybe<String>;
  mobile_contains?: Maybe<String>;
  mobile_not_contains?: Maybe<String>;
  mobile_starts_with?: Maybe<String>;
  mobile_not_starts_with?: Maybe<String>;
  mobile_ends_with?: Maybe<String>;
  mobile_not_ends_with?: Maybe<String>;
  totalOrders?: Maybe<Int>;
  totalOrders_not?: Maybe<Int>;
  totalOrders_in?: Maybe<Int[] | Int>;
  totalOrders_not_in?: Maybe<Int[] | Int>;
  totalOrders_lt?: Maybe<Int>;
  totalOrders_lte?: Maybe<Int>;
  totalOrders_gt?: Maybe<Int>;
  totalOrders_gte?: Maybe<Int>;
  orderses_every?: Maybe<OrdersWhereInput>;
  orderses_some?: Maybe<OrdersWhereInput>;
  orderses_none?: Maybe<OrdersWhereInput>;
  contactSync?: Maybe<Boolean>;
  contactSync_not?: Maybe<Boolean>;
  userReviewses_every?: Maybe<UserReviewsWhereInput>;
  userReviewses_some?: Maybe<UserReviewsWhereInput>;
  userReviewses_none?: Maybe<UserReviewsWhereInput>;
  isBlocked?: Maybe<Boolean>;
  isBlocked_not?: Maybe<Boolean>;
  promoCode?: Maybe<String>;
  promoCode_not?: Maybe<String>;
  promoCode_in?: Maybe<String[] | String>;
  promoCode_not_in?: Maybe<String[] | String>;
  promoCode_lt?: Maybe<String>;
  promoCode_lte?: Maybe<String>;
  promoCode_gt?: Maybe<String>;
  promoCode_gte?: Maybe<String>;
  promoCode_contains?: Maybe<String>;
  promoCode_not_contains?: Maybe<String>;
  promoCode_starts_with?: Maybe<String>;
  promoCode_not_starts_with?: Maybe<String>;
  promoCode_ends_with?: Maybe<String>;
  promoCode_not_ends_with?: Maybe<String>;
  userPromoCount?: Maybe<Int>;
  userPromoCount_not?: Maybe<Int>;
  userPromoCount_in?: Maybe<Int[] | Int>;
  userPromoCount_not_in?: Maybe<Int[] | Int>;
  userPromoCount_lt?: Maybe<Int>;
  userPromoCount_lte?: Maybe<Int>;
  userPromoCount_gt?: Maybe<Int>;
  userPromoCount_gte?: Maybe<Int>;
  typeAccess?: Maybe<String>;
  typeAccess_not?: Maybe<String>;
  typeAccess_in?: Maybe<String[] | String>;
  typeAccess_not_in?: Maybe<String[] | String>;
  typeAccess_lt?: Maybe<String>;
  typeAccess_lte?: Maybe<String>;
  typeAccess_gt?: Maybe<String>;
  typeAccess_gte?: Maybe<String>;
  typeAccess_contains?: Maybe<String>;
  typeAccess_not_contains?: Maybe<String>;
  typeAccess_starts_with?: Maybe<String>;
  typeAccess_not_starts_with?: Maybe<String>;
  typeAccess_ends_with?: Maybe<String>;
  typeAccess_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  installLocation?: Maybe<String>;
  installLocation_not?: Maybe<String>;
  installLocation_in?: Maybe<String[] | String>;
  installLocation_not_in?: Maybe<String[] | String>;
  installLocation_lt?: Maybe<String>;
  installLocation_lte?: Maybe<String>;
  installLocation_gt?: Maybe<String>;
  installLocation_gte?: Maybe<String>;
  installLocation_contains?: Maybe<String>;
  installLocation_not_contains?: Maybe<String>;
  installLocation_starts_with?: Maybe<String>;
  installLocation_not_starts_with?: Maybe<String>;
  installLocation_ends_with?: Maybe<String>;
  installLocation_not_ends_with?: Maybe<String>;
  isPremiumUser?: Maybe<String>;
  isPremiumUser_not?: Maybe<String>;
  isPremiumUser_in?: Maybe<String[] | String>;
  isPremiumUser_not_in?: Maybe<String[] | String>;
  isPremiumUser_lt?: Maybe<String>;
  isPremiumUser_lte?: Maybe<String>;
  isPremiumUser_gt?: Maybe<String>;
  isPremiumUser_gte?: Maybe<String>;
  isPremiumUser_contains?: Maybe<String>;
  isPremiumUser_not_contains?: Maybe<String>;
  isPremiumUser_starts_with?: Maybe<String>;
  isPremiumUser_not_starts_with?: Maybe<String>;
  isPremiumUser_ends_with?: Maybe<String>;
  isPremiumUser_not_ends_with?: Maybe<String>;
  currentLocation?: Maybe<String>;
  currentLocation_not?: Maybe<String>;
  currentLocation_in?: Maybe<String[] | String>;
  currentLocation_not_in?: Maybe<String[] | String>;
  currentLocation_lt?: Maybe<String>;
  currentLocation_lte?: Maybe<String>;
  currentLocation_gt?: Maybe<String>;
  currentLocation_gte?: Maybe<String>;
  currentLocation_contains?: Maybe<String>;
  currentLocation_not_contains?: Maybe<String>;
  currentLocation_starts_with?: Maybe<String>;
  currentLocation_not_starts_with?: Maybe<String>;
  currentLocation_ends_with?: Maybe<String>;
  currentLocation_not_ends_with?: Maybe<String>;
  profileImage?: Maybe<String>;
  profileImage_not?: Maybe<String>;
  profileImage_in?: Maybe<String[] | String>;
  profileImage_not_in?: Maybe<String[] | String>;
  profileImage_lt?: Maybe<String>;
  profileImage_lte?: Maybe<String>;
  profileImage_gt?: Maybe<String>;
  profileImage_gte?: Maybe<String>;
  profileImage_contains?: Maybe<String>;
  profileImage_not_contains?: Maybe<String>;
  profileImage_starts_with?: Maybe<String>;
  profileImage_not_starts_with?: Maybe<String>;
  profileImage_ends_with?: Maybe<String>;
  profileImage_not_ends_with?: Maybe<String>;
  bookingOtp?: Maybe<String>;
  bookingOtp_not?: Maybe<String>;
  bookingOtp_in?: Maybe<String[] | String>;
  bookingOtp_not_in?: Maybe<String[] | String>;
  bookingOtp_lt?: Maybe<String>;
  bookingOtp_lte?: Maybe<String>;
  bookingOtp_gt?: Maybe<String>;
  bookingOtp_gte?: Maybe<String>;
  bookingOtp_contains?: Maybe<String>;
  bookingOtp_not_contains?: Maybe<String>;
  bookingOtp_starts_with?: Maybe<String>;
  bookingOtp_not_starts_with?: Maybe<String>;
  bookingOtp_ends_with?: Maybe<String>;
  bookingOtp_not_ends_with?: Maybe<String>;
  otpExpires?: Maybe<DateTimeInput>;
  otpExpires_not?: Maybe<DateTimeInput>;
  otpExpires_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  otpExpires_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  otpExpires_lt?: Maybe<DateTimeInput>;
  otpExpires_lte?: Maybe<DateTimeInput>;
  otpExpires_gt?: Maybe<DateTimeInput>;
  otpExpires_gte?: Maybe<DateTimeInput>;
  premiumStartDate?: Maybe<DateTimeInput>;
  premiumStartDate_not?: Maybe<DateTimeInput>;
  premiumStartDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  premiumStartDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  premiumStartDate_lt?: Maybe<DateTimeInput>;
  premiumStartDate_lte?: Maybe<DateTimeInput>;
  premiumStartDate_gt?: Maybe<DateTimeInput>;
  premiumStartDate_gte?: Maybe<DateTimeInput>;
  premiumExpireDate?: Maybe<DateTimeInput>;
  premiumExpireDate_not?: Maybe<DateTimeInput>;
  premiumExpireDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  premiumExpireDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  premiumExpireDate_lt?: Maybe<DateTimeInput>;
  premiumExpireDate_lte?: Maybe<DateTimeInput>;
  premiumExpireDate_gt?: Maybe<DateTimeInput>;
  premiumExpireDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface UserReviewsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  review?: Maybe<String>;
  review_not?: Maybe<String>;
  review_in?: Maybe<String[] | String>;
  review_not_in?: Maybe<String[] | String>;
  review_lt?: Maybe<String>;
  review_lte?: Maybe<String>;
  review_gt?: Maybe<String>;
  review_gte?: Maybe<String>;
  review_contains?: Maybe<String>;
  review_not_contains?: Maybe<String>;
  review_starts_with?: Maybe<String>;
  review_not_starts_with?: Maybe<String>;
  review_ends_with?: Maybe<String>;
  review_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  rating?: Maybe<Int>;
  rating_not?: Maybe<Int>;
  rating_in?: Maybe<Int[] | Int>;
  rating_not_in?: Maybe<Int[] | Int>;
  rating_lt?: Maybe<Int>;
  rating_lte?: Maybe<Int>;
  rating_gt?: Maybe<Int>;
  rating_gte?: Maybe<Int>;
  restaurants?: Maybe<RestaurantsWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<UserReviewsWhereInput[] | UserReviewsWhereInput>;
  OR?: Maybe<UserReviewsWhereInput[] | UserReviewsWhereInput>;
  NOT?: Maybe<UserReviewsWhereInput[] | UserReviewsWhereInput>;
}

export interface RestaurantTypeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  restaurantses_every?: Maybe<RestaurantsWhereInput>;
  restaurantses_some?: Maybe<RestaurantsWhereInput>;
  restaurantses_none?: Maybe<RestaurantsWhereInput>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  imageurl?: Maybe<String>;
  imageurl_not?: Maybe<String>;
  imageurl_in?: Maybe<String[] | String>;
  imageurl_not_in?: Maybe<String[] | String>;
  imageurl_lt?: Maybe<String>;
  imageurl_lte?: Maybe<String>;
  imageurl_gt?: Maybe<String>;
  imageurl_gte?: Maybe<String>;
  imageurl_contains?: Maybe<String>;
  imageurl_not_contains?: Maybe<String>;
  imageurl_starts_with?: Maybe<String>;
  imageurl_not_starts_with?: Maybe<String>;
  imageurl_ends_with?: Maybe<String>;
  imageurl_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  typeName?: Maybe<String>;
  typeName_not?: Maybe<String>;
  typeName_in?: Maybe<String[] | String>;
  typeName_not_in?: Maybe<String[] | String>;
  typeName_lt?: Maybe<String>;
  typeName_lte?: Maybe<String>;
  typeName_gt?: Maybe<String>;
  typeName_gte?: Maybe<String>;
  typeName_contains?: Maybe<String>;
  typeName_not_contains?: Maybe<String>;
  typeName_starts_with?: Maybe<String>;
  typeName_not_starts_with?: Maybe<String>;
  typeName_ends_with?: Maybe<String>;
  typeName_not_ends_with?: Maybe<String>;
  cityImage?: Maybe<String>;
  cityImage_not?: Maybe<String>;
  cityImage_in?: Maybe<String[] | String>;
  cityImage_not_in?: Maybe<String[] | String>;
  cityImage_lt?: Maybe<String>;
  cityImage_lte?: Maybe<String>;
  cityImage_gt?: Maybe<String>;
  cityImage_gte?: Maybe<String>;
  cityImage_contains?: Maybe<String>;
  cityImage_not_contains?: Maybe<String>;
  cityImage_starts_with?: Maybe<String>;
  cityImage_not_starts_with?: Maybe<String>;
  cityImage_ends_with?: Maybe<String>;
  cityImage_not_ends_with?: Maybe<String>;
  activatePremium?: Maybe<Boolean>;
  activatePremium_not?: Maybe<Boolean>;
  premiumPrice?: Maybe<Int>;
  premiumPrice_not?: Maybe<Int>;
  premiumPrice_in?: Maybe<Int[] | Int>;
  premiumPrice_not_in?: Maybe<Int[] | Int>;
  premiumPrice_lt?: Maybe<Int>;
  premiumPrice_lte?: Maybe<Int>;
  premiumPrice_gt?: Maybe<Int>;
  premiumPrice_gte?: Maybe<Int>;
  AND?: Maybe<RestaurantTypeWhereInput[] | RestaurantTypeWhereInput>;
  OR?: Maybe<RestaurantTypeWhereInput[] | RestaurantTypeWhereInput>;
  NOT?: Maybe<RestaurantTypeWhereInput[] | RestaurantTypeWhereInput>;
}

export interface HotDealsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  restaurantses_every?: Maybe<RestaurantsWhereInput>;
  restaurantses_some?: Maybe<RestaurantsWhereInput>;
  restaurantses_none?: Maybe<RestaurantsWhereInput>;
  imageurl?: Maybe<String>;
  imageurl_not?: Maybe<String>;
  imageurl_in?: Maybe<String[] | String>;
  imageurl_not_in?: Maybe<String[] | String>;
  imageurl_lt?: Maybe<String>;
  imageurl_lte?: Maybe<String>;
  imageurl_gt?: Maybe<String>;
  imageurl_gte?: Maybe<String>;
  imageurl_contains?: Maybe<String>;
  imageurl_not_contains?: Maybe<String>;
  imageurl_starts_with?: Maybe<String>;
  imageurl_not_starts_with?: Maybe<String>;
  imageurl_ends_with?: Maybe<String>;
  imageurl_not_ends_with?: Maybe<String>;
  AND?: Maybe<HotDealsWhereInput[] | HotDealsWhereInput>;
  OR?: Maybe<HotDealsWhereInput[] | HotDealsWhereInput>;
  NOT?: Maybe<HotDealsWhereInput[] | HotDealsWhereInput>;
}

export interface BrandTileWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  imageurl?: Maybe<String>;
  imageurl_not?: Maybe<String>;
  imageurl_in?: Maybe<String[] | String>;
  imageurl_not_in?: Maybe<String[] | String>;
  imageurl_lt?: Maybe<String>;
  imageurl_lte?: Maybe<String>;
  imageurl_gt?: Maybe<String>;
  imageurl_gte?: Maybe<String>;
  imageurl_contains?: Maybe<String>;
  imageurl_not_contains?: Maybe<String>;
  imageurl_starts_with?: Maybe<String>;
  imageurl_not_starts_with?: Maybe<String>;
  imageurl_ends_with?: Maybe<String>;
  imageurl_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  restaurantses_every?: Maybe<RestaurantsWhereInput>;
  restaurantses_some?: Maybe<RestaurantsWhereInput>;
  restaurantses_none?: Maybe<RestaurantsWhereInput>;
  brandTileName?: Maybe<String>;
  brandTileName_not?: Maybe<String>;
  brandTileName_in?: Maybe<String[] | String>;
  brandTileName_not_in?: Maybe<String[] | String>;
  brandTileName_lt?: Maybe<String>;
  brandTileName_lte?: Maybe<String>;
  brandTileName_gt?: Maybe<String>;
  brandTileName_gte?: Maybe<String>;
  brandTileName_contains?: Maybe<String>;
  brandTileName_not_contains?: Maybe<String>;
  brandTileName_starts_with?: Maybe<String>;
  brandTileName_not_starts_with?: Maybe<String>;
  brandTileName_ends_with?: Maybe<String>;
  brandTileName_not_ends_with?: Maybe<String>;
  AND?: Maybe<BrandTileWhereInput[] | BrandTileWhereInput>;
  OR?: Maybe<BrandTileWhereInput[] | BrandTileWhereInput>;
  NOT?: Maybe<BrandTileWhereInput[] | BrandTileWhereInput>;
}

export type ContactsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ContactsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  AND?: Maybe<ContactsWhereInput[] | ContactsWhereInput>;
  OR?: Maybe<ContactsWhereInput[] | ContactsWhereInput>;
  NOT?: Maybe<ContactsWhereInput[] | ContactsWhereInput>;
}

export type FileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  secret?: Maybe<String>;
  url?: Maybe<String>;
}>;

export interface FileWhereInput {
  contentType?: Maybe<String>;
  contentType_not?: Maybe<String>;
  contentType_in?: Maybe<String[] | String>;
  contentType_not_in?: Maybe<String[] | String>;
  contentType_lt?: Maybe<String>;
  contentType_lte?: Maybe<String>;
  contentType_gt?: Maybe<String>;
  contentType_gte?: Maybe<String>;
  contentType_contains?: Maybe<String>;
  contentType_not_contains?: Maybe<String>;
  contentType_starts_with?: Maybe<String>;
  contentType_not_starts_with?: Maybe<String>;
  contentType_ends_with?: Maybe<String>;
  contentType_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  secret?: Maybe<String>;
  secret_not?: Maybe<String>;
  secret_in?: Maybe<String[] | String>;
  secret_not_in?: Maybe<String[] | String>;
  secret_lt?: Maybe<String>;
  secret_lte?: Maybe<String>;
  secret_gt?: Maybe<String>;
  secret_gte?: Maybe<String>;
  secret_contains?: Maybe<String>;
  secret_not_contains?: Maybe<String>;
  secret_starts_with?: Maybe<String>;
  secret_not_starts_with?: Maybe<String>;
  secret_ends_with?: Maybe<String>;
  secret_not_ends_with?: Maybe<String>;
  size?: Maybe<Int>;
  size_not?: Maybe<Int>;
  size_in?: Maybe<Int[] | Int>;
  size_not_in?: Maybe<Int[] | Int>;
  size_lt?: Maybe<Int>;
  size_lte?: Maybe<Int>;
  size_gt?: Maybe<Int>;
  size_gte?: Maybe<Int>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<FileWhereInput[] | FileWhereInput>;
  OR?: Maybe<FileWhereInput[] | FileWhereInput>;
  NOT?: Maybe<FileWhereInput[] | FileWhereInput>;
}

export type FridayWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type HotDealsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  type?: Maybe<String>;
}>;

export type MiscWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface MiscWhereInput {
  faq?: Maybe<String>;
  faq_not?: Maybe<String>;
  faq_in?: Maybe<String[] | String>;
  faq_not_in?: Maybe<String[] | String>;
  faq_lt?: Maybe<String>;
  faq_lte?: Maybe<String>;
  faq_gt?: Maybe<String>;
  faq_gte?: Maybe<String>;
  faq_contains?: Maybe<String>;
  faq_not_contains?: Maybe<String>;
  faq_starts_with?: Maybe<String>;
  faq_not_starts_with?: Maybe<String>;
  faq_ends_with?: Maybe<String>;
  faq_not_ends_with?: Maybe<String>;
  fup?: Maybe<String>;
  fup_not?: Maybe<String>;
  fup_in?: Maybe<String[] | String>;
  fup_not_in?: Maybe<String[] | String>;
  fup_lt?: Maybe<String>;
  fup_lte?: Maybe<String>;
  fup_gt?: Maybe<String>;
  fup_gte?: Maybe<String>;
  fup_contains?: Maybe<String>;
  fup_not_contains?: Maybe<String>;
  fup_starts_with?: Maybe<String>;
  fup_not_starts_with?: Maybe<String>;
  fup_ends_with?: Maybe<String>;
  fup_not_ends_with?: Maybe<String>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<MiscWhereInput[] | MiscWhereInput>;
  OR?: Maybe<MiscWhereInput[] | MiscWhereInput>;
  NOT?: Maybe<MiscWhereInput[] | MiscWhereInput>;
}

export type MondayWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type OrdersWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type RestaurantTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type RestaurantsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
  password?: Maybe<String>;
}>;

export type SaturdayWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SundayWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ThursdayWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TimeDiscountWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TuesdayWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  facebookID?: Maybe<String>;
  promoCode?: Maybe<String>;
}>;

export type UserReviewsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type WednesdayWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type cityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface cityWhereInput {
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  isPremium?: Maybe<Boolean>;
  isPremium_not?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  premiumAmmount90?: Maybe<Int>;
  premiumAmmount90_not?: Maybe<Int>;
  premiumAmmount90_in?: Maybe<Int[] | Int>;
  premiumAmmount90_not_in?: Maybe<Int[] | Int>;
  premiumAmmount90_lt?: Maybe<Int>;
  premiumAmmount90_lte?: Maybe<Int>;
  premiumAmmount90_gt?: Maybe<Int>;
  premiumAmmount90_gte?: Maybe<Int>;
  premiumAmmount180?: Maybe<Int>;
  premiumAmmount180_not?: Maybe<Int>;
  premiumAmmount180_in?: Maybe<Int[] | Int>;
  premiumAmmount180_not_in?: Maybe<Int[] | Int>;
  premiumAmmount180_lt?: Maybe<Int>;
  premiumAmmount180_lte?: Maybe<Int>;
  premiumAmmount180_gt?: Maybe<Int>;
  premiumAmmount180_gte?: Maybe<Int>;
  premiumAmmount360?: Maybe<Int>;
  premiumAmmount360_not?: Maybe<Int>;
  premiumAmmount360_in?: Maybe<Int[] | Int>;
  premiumAmmount360_not_in?: Maybe<Int[] | Int>;
  premiumAmmount360_lt?: Maybe<Int>;
  premiumAmmount360_lte?: Maybe<Int>;
  premiumAmmount360_gt?: Maybe<Int>;
  premiumAmmount360_gte?: Maybe<Int>;
  imageUrl?: Maybe<String>;
  imageUrl_not?: Maybe<String>;
  imageUrl_in?: Maybe<String[] | String>;
  imageUrl_not_in?: Maybe<String[] | String>;
  imageUrl_lt?: Maybe<String>;
  imageUrl_lte?: Maybe<String>;
  imageUrl_gt?: Maybe<String>;
  imageUrl_gte?: Maybe<String>;
  imageUrl_contains?: Maybe<String>;
  imageUrl_not_contains?: Maybe<String>;
  imageUrl_starts_with?: Maybe<String>;
  imageUrl_not_starts_with?: Maybe<String>;
  imageUrl_ends_with?: Maybe<String>;
  imageUrl_not_ends_with?: Maybe<String>;
  AND?: Maybe<cityWhereInput[] | cityWhereInput>;
  OR?: Maybe<cityWhereInput[] | cityWhereInput>;
  NOT?: Maybe<cityWhereInput[] | cityWhereInput>;
}

export interface AdsCreateInput {
  city: String;
  id?: Maybe<ID_Input>;
  imageurl: String;
  visible: Boolean;
}

export interface AdsUpdateInput {
  city?: Maybe<String>;
  imageurl?: Maybe<String>;
  visible?: Maybe<Boolean>;
}

export interface AdsUpdateManyMutationInput {
  city?: Maybe<String>;
  imageurl?: Maybe<String>;
  visible?: Maybe<Boolean>;
}

export interface BlogCreateInput {
  authorImg: String;
  authorName: String;
  content: String;
  createdon: DateTimeInput;
  id?: Maybe<ID_Input>;
  summary: String;
  title: String;
  titleImg?: Maybe<String>;
}

export interface BlogUpdateInput {
  authorImg?: Maybe<String>;
  authorName?: Maybe<String>;
  content?: Maybe<String>;
  createdon?: Maybe<DateTimeInput>;
  summary?: Maybe<String>;
  title?: Maybe<String>;
  titleImg?: Maybe<String>;
}

export interface BlogUpdateManyMutationInput {
  authorImg?: Maybe<String>;
  authorName?: Maybe<String>;
  content?: Maybe<String>;
  createdon?: Maybe<DateTimeInput>;
  summary?: Maybe<String>;
  title?: Maybe<String>;
  titleImg?: Maybe<String>;
}

export interface BrandTileCreateInput {
  id?: Maybe<ID_Input>;
  type: String;
  imageurl?: Maybe<String>;
  order?: Maybe<Int>;
  restaurantses?: Maybe<RestaurantsCreateManyWithoutBrandTileInput>;
  brandTileName: String;
}

export interface RestaurantsCreateManyWithoutBrandTileInput {
  create?: Maybe<
    | RestaurantsCreateWithoutBrandTileInput[]
    | RestaurantsCreateWithoutBrandTileInput
  >;
  connect?: Maybe<RestaurantsWhereUniqueInput[] | RestaurantsWhereUniqueInput>;
}

export interface RestaurantsCreateWithoutBrandTileInput {
  city: String;
  id?: Maybe<ID_Input>;
  enableLoginAccess?: Maybe<Boolean>;
  name: String;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersCreateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeCreateManyWithoutRestaurantsesInput>;
  state: String;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsCreateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsCreateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsCreaterphoneInput>;
  friday?: Maybe<FridayCreateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayCreateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayCreateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsCreatemenuInput>;
  restaurantImages?: Maybe<RestaurantsCreaterestaurantImagesInput>;
}

export interface OrdersCreateManyWithoutRestaurantsInput {
  create?: Maybe<
    OrdersCreateWithoutRestaurantsInput[] | OrdersCreateWithoutRestaurantsInput
  >;
  connect?: Maybe<OrdersWhereUniqueInput[] | OrdersWhereUniqueInput>;
}

export interface OrdersCreateWithoutRestaurantsInput {
  id?: Maybe<ID_Input>;
  timeDiscount?: Maybe<TimeDiscountCreateOneWithoutOrdersesInput>;
  user: UserCreateOneWithoutOrdersesInput;
  date: String;
  totalDiscount?: Maybe<Int>;
  people: Int;
  bookingid: String;
  mobile: String;
  unlockActive?: Maybe<Boolean>;
  name: String;
  geolocation?: Maybe<String>;
  referrer?: Maybe<String>;
  confirmed?: Maybe<Boolean>;
  cancelled?: Maybe<Boolean>;
  amount?: Maybe<Int>;
  receipt?: Maybe<String>;
  paymentId?: Maybe<String>;
  paymentOrderId?: Maybe<String>;
  paymentDescription?: Maybe<String>;
}

export interface TimeDiscountCreateOneWithoutOrdersesInput {
  create?: Maybe<TimeDiscountCreateWithoutOrdersesInput>;
  connect?: Maybe<TimeDiscountWhereUniqueInput>;
}

export interface TimeDiscountCreateWithoutOrdersesInput {
  discount: Float;
  id?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutTimeDiscountsInput>;
  time: String;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  friday?: Maybe<FridayCreateOneWithoutTimeDiscountsInput>;
  monday?: Maybe<MondayCreateOneWithoutTimeDiscountsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutTimeDiscountsInput>;
  sunday?: Maybe<SundayCreateOneWithoutTimeDiscountsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutTimeDiscountsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutTimeDiscountsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface RestaurantsCreateOneWithoutTimeDiscountsInput {
  create?: Maybe<RestaurantsCreateWithoutTimeDiscountsInput>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsCreateWithoutTimeDiscountsInput {
  city: String;
  id?: Maybe<ID_Input>;
  enableLoginAccess?: Maybe<Boolean>;
  name: String;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersCreateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeCreateManyWithoutRestaurantsesInput>;
  state: String;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsCreateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsCreateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsCreaterphoneInput>;
  friday?: Maybe<FridayCreateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayCreateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayCreateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsCreatemenuInput>;
  brandTile?: Maybe<BrandTileCreateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsCreaterestaurantImagesInput>;
}

export interface RestaurantTypeCreateManyWithoutRestaurantsesInput {
  create?: Maybe<
    | RestaurantTypeCreateWithoutRestaurantsesInput[]
    | RestaurantTypeCreateWithoutRestaurantsesInput
  >;
  connect?: Maybe<
    RestaurantTypeWhereUniqueInput[] | RestaurantTypeWhereUniqueInput
  >;
}

export interface RestaurantTypeCreateWithoutRestaurantsesInput {
  id?: Maybe<ID_Input>;
  type: String;
  imageurl?: Maybe<String>;
  order?: Maybe<Int>;
  typeName?: Maybe<String>;
  cityImage?: Maybe<String>;
  activatePremium?: Maybe<Boolean>;
  premiumPrice?: Maybe<Int>;
}

export interface UserReviewsCreateManyWithoutRestaurantsInput {
  create?: Maybe<
    | UserReviewsCreateWithoutRestaurantsInput[]
    | UserReviewsCreateWithoutRestaurantsInput
  >;
  connect?: Maybe<UserReviewsWhereUniqueInput[] | UserReviewsWhereUniqueInput>;
}

export interface UserReviewsCreateWithoutRestaurantsInput {
  id?: Maybe<ID_Input>;
  review: String;
  rating: Int;
  user?: Maybe<UserCreateOneWithoutUserReviewsesInput>;
}

export interface UserCreateOneWithoutUserReviewsesInput {
  create?: Maybe<UserCreateWithoutUserReviewsesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutUserReviewsesInput {
  email?: Maybe<String>;
  firstname?: Maybe<String>;
  id?: Maybe<ID_Input>;
  facebookID: String;
  lastname?: Maybe<String>;
  mobile?: Maybe<String>;
  totalOrders?: Maybe<Int>;
  orderses?: Maybe<OrdersCreateManyWithoutUserInput>;
  contactSync?: Maybe<Boolean>;
  isBlocked?: Maybe<Boolean>;
  promoCode?: Maybe<String>;
  userPromoCount?: Maybe<Int>;
  typeAccess?: Maybe<String>;
  password?: Maybe<String>;
  installLocation?: Maybe<String>;
  isPremiumUser?: Maybe<String>;
  currentLocation?: Maybe<String>;
  profileImage?: Maybe<String>;
  bookingOtp?: Maybe<String>;
  otpExpires?: Maybe<DateTimeInput>;
  premiumStartDate?: Maybe<DateTimeInput>;
  premiumExpireDate?: Maybe<DateTimeInput>;
}

export interface OrdersCreateManyWithoutUserInput {
  create?: Maybe<OrdersCreateWithoutUserInput[] | OrdersCreateWithoutUserInput>;
  connect?: Maybe<OrdersWhereUniqueInput[] | OrdersWhereUniqueInput>;
}

export interface OrdersCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutOrdersesInput>;
  timeDiscount?: Maybe<TimeDiscountCreateOneWithoutOrdersesInput>;
  date: String;
  totalDiscount?: Maybe<Int>;
  people: Int;
  bookingid: String;
  mobile: String;
  unlockActive?: Maybe<Boolean>;
  name: String;
  geolocation?: Maybe<String>;
  referrer?: Maybe<String>;
  confirmed?: Maybe<Boolean>;
  cancelled?: Maybe<Boolean>;
  amount?: Maybe<Int>;
  receipt?: Maybe<String>;
  paymentId?: Maybe<String>;
  paymentOrderId?: Maybe<String>;
  paymentDescription?: Maybe<String>;
}

export interface RestaurantsCreateOneWithoutOrdersesInput {
  create?: Maybe<RestaurantsCreateWithoutOrdersesInput>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsCreateWithoutOrdersesInput {
  city: String;
  id?: Maybe<ID_Input>;
  enableLoginAccess?: Maybe<Boolean>;
  name: String;
  email?: Maybe<String>;
  password?: Maybe<String>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeCreateManyWithoutRestaurantsesInput>;
  state: String;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsCreateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsCreateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsCreaterphoneInput>;
  friday?: Maybe<FridayCreateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayCreateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayCreateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsCreatemenuInput>;
  brandTile?: Maybe<BrandTileCreateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsCreaterestaurantImagesInput>;
}

export interface TimeDiscountCreateManyWithoutRestaurantsInput {
  create?: Maybe<
    | TimeDiscountCreateWithoutRestaurantsInput[]
    | TimeDiscountCreateWithoutRestaurantsInput
  >;
  connect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
}

export interface TimeDiscountCreateWithoutRestaurantsInput {
  discount: Float;
  id?: Maybe<ID_Input>;
  orderses?: Maybe<OrdersCreateManyWithoutTimeDiscountInput>;
  time: String;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  friday?: Maybe<FridayCreateOneWithoutTimeDiscountsInput>;
  monday?: Maybe<MondayCreateOneWithoutTimeDiscountsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutTimeDiscountsInput>;
  sunday?: Maybe<SundayCreateOneWithoutTimeDiscountsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutTimeDiscountsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutTimeDiscountsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface OrdersCreateManyWithoutTimeDiscountInput {
  create?: Maybe<
    | OrdersCreateWithoutTimeDiscountInput[]
    | OrdersCreateWithoutTimeDiscountInput
  >;
  connect?: Maybe<OrdersWhereUniqueInput[] | OrdersWhereUniqueInput>;
}

export interface OrdersCreateWithoutTimeDiscountInput {
  id?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutOrdersesInput>;
  user: UserCreateOneWithoutOrdersesInput;
  date: String;
  totalDiscount?: Maybe<Int>;
  people: Int;
  bookingid: String;
  mobile: String;
  unlockActive?: Maybe<Boolean>;
  name: String;
  geolocation?: Maybe<String>;
  referrer?: Maybe<String>;
  confirmed?: Maybe<Boolean>;
  cancelled?: Maybe<Boolean>;
  amount?: Maybe<Int>;
  receipt?: Maybe<String>;
  paymentId?: Maybe<String>;
  paymentOrderId?: Maybe<String>;
  paymentDescription?: Maybe<String>;
}

export interface UserCreateOneWithoutOrdersesInput {
  create?: Maybe<UserCreateWithoutOrdersesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutOrdersesInput {
  email?: Maybe<String>;
  firstname?: Maybe<String>;
  id?: Maybe<ID_Input>;
  facebookID: String;
  lastname?: Maybe<String>;
  mobile?: Maybe<String>;
  totalOrders?: Maybe<Int>;
  contactSync?: Maybe<Boolean>;
  userReviewses?: Maybe<UserReviewsCreateManyWithoutUserInput>;
  isBlocked?: Maybe<Boolean>;
  promoCode?: Maybe<String>;
  userPromoCount?: Maybe<Int>;
  typeAccess?: Maybe<String>;
  password?: Maybe<String>;
  installLocation?: Maybe<String>;
  isPremiumUser?: Maybe<String>;
  currentLocation?: Maybe<String>;
  profileImage?: Maybe<String>;
  bookingOtp?: Maybe<String>;
  otpExpires?: Maybe<DateTimeInput>;
  premiumStartDate?: Maybe<DateTimeInput>;
  premiumExpireDate?: Maybe<DateTimeInput>;
}

export interface UserReviewsCreateManyWithoutUserInput {
  create?: Maybe<
    UserReviewsCreateWithoutUserInput[] | UserReviewsCreateWithoutUserInput
  >;
  connect?: Maybe<UserReviewsWhereUniqueInput[] | UserReviewsWhereUniqueInput>;
}

export interface UserReviewsCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  review: String;
  rating: Int;
  restaurants?: Maybe<RestaurantsCreateOneWithoutUserReviewsesInput>;
}

export interface RestaurantsCreateOneWithoutUserReviewsesInput {
  create?: Maybe<RestaurantsCreateWithoutUserReviewsesInput>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsCreateWithoutUserReviewsesInput {
  city: String;
  id?: Maybe<ID_Input>;
  enableLoginAccess?: Maybe<Boolean>;
  name: String;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersCreateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeCreateManyWithoutRestaurantsesInput>;
  state: String;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  hotDealses?: Maybe<HotDealsCreateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsCreaterphoneInput>;
  friday?: Maybe<FridayCreateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayCreateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayCreateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsCreatemenuInput>;
  brandTile?: Maybe<BrandTileCreateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsCreaterestaurantImagesInput>;
}

export interface HotDealsCreateManyWithoutRestaurantsesInput {
  create?: Maybe<
    | HotDealsCreateWithoutRestaurantsesInput[]
    | HotDealsCreateWithoutRestaurantsesInput
  >;
  connect?: Maybe<HotDealsWhereUniqueInput[] | HotDealsWhereUniqueInput>;
}

export interface HotDealsCreateWithoutRestaurantsesInput {
  id?: Maybe<ID_Input>;
  type: String;
  imageurl?: Maybe<String>;
}

export interface RestaurantsCreaterphoneInput {
  set?: Maybe<String[] | String>;
}

export interface FridayCreateOneWithoutRestaurantsInput {
  create?: Maybe<FridayCreateWithoutRestaurantsInput>;
  connect?: Maybe<FridayWhereUniqueInput>;
}

export interface FridayCreateWithoutRestaurantsInput {
  exhausted?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutFridayInput>;
  order?: Maybe<Int>;
}

export interface TimeDiscountCreateManyWithoutFridayInput {
  create?: Maybe<
    | TimeDiscountCreateWithoutFridayInput[]
    | TimeDiscountCreateWithoutFridayInput
  >;
  connect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
}

export interface TimeDiscountCreateWithoutFridayInput {
  discount: Float;
  id?: Maybe<ID_Input>;
  orderses?: Maybe<OrdersCreateManyWithoutTimeDiscountInput>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutTimeDiscountsInput>;
  time: String;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  monday?: Maybe<MondayCreateOneWithoutTimeDiscountsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutTimeDiscountsInput>;
  sunday?: Maybe<SundayCreateOneWithoutTimeDiscountsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutTimeDiscountsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutTimeDiscountsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface MondayCreateOneWithoutTimeDiscountsInput {
  create?: Maybe<MondayCreateWithoutTimeDiscountsInput>;
  connect?: Maybe<MondayWhereUniqueInput>;
}

export interface MondayCreateWithoutTimeDiscountsInput {
  id?: Maybe<ID_Input>;
  exhausted?: Maybe<Boolean>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutMondayInput>;
  order?: Maybe<Int>;
}

export interface RestaurantsCreateOneWithoutMondayInput {
  create?: Maybe<RestaurantsCreateWithoutMondayInput>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsCreateWithoutMondayInput {
  city: String;
  id?: Maybe<ID_Input>;
  enableLoginAccess?: Maybe<Boolean>;
  name: String;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersCreateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeCreateManyWithoutRestaurantsesInput>;
  state: String;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsCreateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsCreateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsCreaterphoneInput>;
  friday?: Maybe<FridayCreateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayCreateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsCreatemenuInput>;
  brandTile?: Maybe<BrandTileCreateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsCreaterestaurantImagesInput>;
}

export interface SaturdayCreateOneWithoutRestaurantsInput {
  create?: Maybe<SaturdayCreateWithoutRestaurantsInput>;
  connect?: Maybe<SaturdayWhereUniqueInput>;
}

export interface SaturdayCreateWithoutRestaurantsInput {
  exhausted?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutSaturdayInput>;
  order?: Maybe<Int>;
}

export interface TimeDiscountCreateManyWithoutSaturdayInput {
  create?: Maybe<
    | TimeDiscountCreateWithoutSaturdayInput[]
    | TimeDiscountCreateWithoutSaturdayInput
  >;
  connect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
}

export interface TimeDiscountCreateWithoutSaturdayInput {
  discount: Float;
  id?: Maybe<ID_Input>;
  orderses?: Maybe<OrdersCreateManyWithoutTimeDiscountInput>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutTimeDiscountsInput>;
  time: String;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  friday?: Maybe<FridayCreateOneWithoutTimeDiscountsInput>;
  monday?: Maybe<MondayCreateOneWithoutTimeDiscountsInput>;
  sunday?: Maybe<SundayCreateOneWithoutTimeDiscountsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutTimeDiscountsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutTimeDiscountsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface FridayCreateOneWithoutTimeDiscountsInput {
  create?: Maybe<FridayCreateWithoutTimeDiscountsInput>;
  connect?: Maybe<FridayWhereUniqueInput>;
}

export interface FridayCreateWithoutTimeDiscountsInput {
  exhausted?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutFridayInput>;
  order?: Maybe<Int>;
}

export interface RestaurantsCreateOneWithoutFridayInput {
  create?: Maybe<RestaurantsCreateWithoutFridayInput>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsCreateWithoutFridayInput {
  city: String;
  id?: Maybe<ID_Input>;
  enableLoginAccess?: Maybe<Boolean>;
  name: String;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersCreateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeCreateManyWithoutRestaurantsesInput>;
  state: String;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsCreateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsCreateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsCreaterphoneInput>;
  monday?: Maybe<MondayCreateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayCreateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsCreatemenuInput>;
  brandTile?: Maybe<BrandTileCreateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsCreaterestaurantImagesInput>;
}

export interface MondayCreateOneWithoutRestaurantsInput {
  create?: Maybe<MondayCreateWithoutRestaurantsInput>;
  connect?: Maybe<MondayWhereUniqueInput>;
}

export interface MondayCreateWithoutRestaurantsInput {
  id?: Maybe<ID_Input>;
  exhausted?: Maybe<Boolean>;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutMondayInput>;
  order?: Maybe<Int>;
}

export interface TimeDiscountCreateManyWithoutMondayInput {
  create?: Maybe<
    | TimeDiscountCreateWithoutMondayInput[]
    | TimeDiscountCreateWithoutMondayInput
  >;
  connect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
}

export interface TimeDiscountCreateWithoutMondayInput {
  discount: Float;
  id?: Maybe<ID_Input>;
  orderses?: Maybe<OrdersCreateManyWithoutTimeDiscountInput>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutTimeDiscountsInput>;
  time: String;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  friday?: Maybe<FridayCreateOneWithoutTimeDiscountsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutTimeDiscountsInput>;
  sunday?: Maybe<SundayCreateOneWithoutTimeDiscountsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutTimeDiscountsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutTimeDiscountsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface SaturdayCreateOneWithoutTimeDiscountsInput {
  create?: Maybe<SaturdayCreateWithoutTimeDiscountsInput>;
  connect?: Maybe<SaturdayWhereUniqueInput>;
}

export interface SaturdayCreateWithoutTimeDiscountsInput {
  exhausted?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutSaturdayInput>;
  order?: Maybe<Int>;
}

export interface RestaurantsCreateOneWithoutSaturdayInput {
  create?: Maybe<RestaurantsCreateWithoutSaturdayInput>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsCreateWithoutSaturdayInput {
  city: String;
  id?: Maybe<ID_Input>;
  enableLoginAccess?: Maybe<Boolean>;
  name: String;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersCreateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeCreateManyWithoutRestaurantsesInput>;
  state: String;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsCreateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsCreateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsCreaterphoneInput>;
  friday?: Maybe<FridayCreateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayCreateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayCreateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsCreatemenuInput>;
  brandTile?: Maybe<BrandTileCreateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsCreaterestaurantImagesInput>;
}

export interface SundayCreateOneWithoutRestaurantsInput {
  create?: Maybe<SundayCreateWithoutRestaurantsInput>;
  connect?: Maybe<SundayWhereUniqueInput>;
}

export interface SundayCreateWithoutRestaurantsInput {
  exhausted?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutSundayInput>;
  order?: Maybe<Int>;
}

export interface TimeDiscountCreateManyWithoutSundayInput {
  create?: Maybe<
    | TimeDiscountCreateWithoutSundayInput[]
    | TimeDiscountCreateWithoutSundayInput
  >;
  connect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
}

export interface TimeDiscountCreateWithoutSundayInput {
  discount: Float;
  id?: Maybe<ID_Input>;
  orderses?: Maybe<OrdersCreateManyWithoutTimeDiscountInput>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutTimeDiscountsInput>;
  time: String;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  friday?: Maybe<FridayCreateOneWithoutTimeDiscountsInput>;
  monday?: Maybe<MondayCreateOneWithoutTimeDiscountsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutTimeDiscountsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutTimeDiscountsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutTimeDiscountsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface ThursdayCreateOneWithoutTimeDiscountsInput {
  create?: Maybe<ThursdayCreateWithoutTimeDiscountsInput>;
  connect?: Maybe<ThursdayWhereUniqueInput>;
}

export interface ThursdayCreateWithoutTimeDiscountsInput {
  exhausted?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  order?: Maybe<Int>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutThursdayInput>;
}

export interface RestaurantsCreateOneWithoutThursdayInput {
  create?: Maybe<RestaurantsCreateWithoutThursdayInput>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsCreateWithoutThursdayInput {
  city: String;
  id?: Maybe<ID_Input>;
  enableLoginAccess?: Maybe<Boolean>;
  name: String;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersCreateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeCreateManyWithoutRestaurantsesInput>;
  state: String;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsCreateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsCreateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsCreaterphoneInput>;
  friday?: Maybe<FridayCreateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayCreateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayCreateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsCreatemenuInput>;
  brandTile?: Maybe<BrandTileCreateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsCreaterestaurantImagesInput>;
}

export interface TuesdayCreateOneWithoutRestaurantsInput {
  create?: Maybe<TuesdayCreateWithoutRestaurantsInput>;
  connect?: Maybe<TuesdayWhereUniqueInput>;
}

export interface TuesdayCreateWithoutRestaurantsInput {
  exhausted?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutTuesdayInput>;
  order?: Maybe<Int>;
}

export interface TimeDiscountCreateManyWithoutTuesdayInput {
  create?: Maybe<
    | TimeDiscountCreateWithoutTuesdayInput[]
    | TimeDiscountCreateWithoutTuesdayInput
  >;
  connect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
}

export interface TimeDiscountCreateWithoutTuesdayInput {
  discount: Float;
  id?: Maybe<ID_Input>;
  orderses?: Maybe<OrdersCreateManyWithoutTimeDiscountInput>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutTimeDiscountsInput>;
  time: String;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  friday?: Maybe<FridayCreateOneWithoutTimeDiscountsInput>;
  monday?: Maybe<MondayCreateOneWithoutTimeDiscountsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutTimeDiscountsInput>;
  sunday?: Maybe<SundayCreateOneWithoutTimeDiscountsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutTimeDiscountsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface SundayCreateOneWithoutTimeDiscountsInput {
  create?: Maybe<SundayCreateWithoutTimeDiscountsInput>;
  connect?: Maybe<SundayWhereUniqueInput>;
}

export interface SundayCreateWithoutTimeDiscountsInput {
  exhausted?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutSundayInput>;
  order?: Maybe<Int>;
}

export interface RestaurantsCreateOneWithoutSundayInput {
  create?: Maybe<RestaurantsCreateWithoutSundayInput>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsCreateWithoutSundayInput {
  city: String;
  id?: Maybe<ID_Input>;
  enableLoginAccess?: Maybe<Boolean>;
  name: String;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersCreateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeCreateManyWithoutRestaurantsesInput>;
  state: String;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsCreateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsCreateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsCreaterphoneInput>;
  friday?: Maybe<FridayCreateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayCreateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsCreatemenuInput>;
  brandTile?: Maybe<BrandTileCreateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsCreaterestaurantImagesInput>;
}

export interface ThursdayCreateOneWithoutRestaurantsInput {
  create?: Maybe<ThursdayCreateWithoutRestaurantsInput>;
  connect?: Maybe<ThursdayWhereUniqueInput>;
}

export interface ThursdayCreateWithoutRestaurantsInput {
  exhausted?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  order?: Maybe<Int>;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutThursdayInput>;
}

export interface TimeDiscountCreateManyWithoutThursdayInput {
  create?: Maybe<
    | TimeDiscountCreateWithoutThursdayInput[]
    | TimeDiscountCreateWithoutThursdayInput
  >;
  connect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
}

export interface TimeDiscountCreateWithoutThursdayInput {
  discount: Float;
  id?: Maybe<ID_Input>;
  orderses?: Maybe<OrdersCreateManyWithoutTimeDiscountInput>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutTimeDiscountsInput>;
  time: String;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  friday?: Maybe<FridayCreateOneWithoutTimeDiscountsInput>;
  monday?: Maybe<MondayCreateOneWithoutTimeDiscountsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutTimeDiscountsInput>;
  sunday?: Maybe<SundayCreateOneWithoutTimeDiscountsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutTimeDiscountsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface TuesdayCreateOneWithoutTimeDiscountsInput {
  create?: Maybe<TuesdayCreateWithoutTimeDiscountsInput>;
  connect?: Maybe<TuesdayWhereUniqueInput>;
}

export interface TuesdayCreateWithoutTimeDiscountsInput {
  exhausted?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutTuesdayInput>;
  order?: Maybe<Int>;
}

export interface RestaurantsCreateOneWithoutTuesdayInput {
  create?: Maybe<RestaurantsCreateWithoutTuesdayInput>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsCreateWithoutTuesdayInput {
  city: String;
  id?: Maybe<ID_Input>;
  enableLoginAccess?: Maybe<Boolean>;
  name: String;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersCreateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeCreateManyWithoutRestaurantsesInput>;
  state: String;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsCreateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsCreateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsCreaterphoneInput>;
  friday?: Maybe<FridayCreateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayCreateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayCreateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsCreatemenuInput>;
  brandTile?: Maybe<BrandTileCreateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsCreaterestaurantImagesInput>;
}

export interface WednesdayCreateOneWithoutRestaurantsInput {
  create?: Maybe<WednesdayCreateWithoutRestaurantsInput>;
  connect?: Maybe<WednesdayWhereUniqueInput>;
}

export interface WednesdayCreateWithoutRestaurantsInput {
  exhausted?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutWednesdayInput>;
  order?: Maybe<Int>;
}

export interface TimeDiscountCreateManyWithoutWednesdayInput {
  create?: Maybe<
    | TimeDiscountCreateWithoutWednesdayInput[]
    | TimeDiscountCreateWithoutWednesdayInput
  >;
  connect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
}

export interface TimeDiscountCreateWithoutWednesdayInput {
  discount: Float;
  id?: Maybe<ID_Input>;
  orderses?: Maybe<OrdersCreateManyWithoutTimeDiscountInput>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutTimeDiscountsInput>;
  time: String;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  friday?: Maybe<FridayCreateOneWithoutTimeDiscountsInput>;
  monday?: Maybe<MondayCreateOneWithoutTimeDiscountsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutTimeDiscountsInput>;
  sunday?: Maybe<SundayCreateOneWithoutTimeDiscountsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutTimeDiscountsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface RestaurantsCreatemenuInput {
  set?: Maybe<Json[] | Json>;
}

export interface BrandTileCreateOneWithoutRestaurantsesInput {
  create?: Maybe<BrandTileCreateWithoutRestaurantsesInput>;
  connect?: Maybe<BrandTileWhereUniqueInput>;
}

export interface BrandTileCreateWithoutRestaurantsesInput {
  id?: Maybe<ID_Input>;
  type: String;
  imageurl?: Maybe<String>;
  order?: Maybe<Int>;
  brandTileName: String;
}

export interface RestaurantsCreaterestaurantImagesInput {
  set?: Maybe<String[] | String>;
}

export interface WednesdayCreateOneWithoutTimeDiscountsInput {
  create?: Maybe<WednesdayCreateWithoutTimeDiscountsInput>;
  connect?: Maybe<WednesdayWhereUniqueInput>;
}

export interface WednesdayCreateWithoutTimeDiscountsInput {
  exhausted?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutWednesdayInput>;
  order?: Maybe<Int>;
}

export interface RestaurantsCreateOneWithoutWednesdayInput {
  create?: Maybe<RestaurantsCreateWithoutWednesdayInput>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsCreateWithoutWednesdayInput {
  city: String;
  id?: Maybe<ID_Input>;
  enableLoginAccess?: Maybe<Boolean>;
  name: String;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersCreateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeCreateManyWithoutRestaurantsesInput>;
  state: String;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsCreateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsCreateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsCreaterphoneInput>;
  friday?: Maybe<FridayCreateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayCreateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayCreateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsCreatemenuInput>;
  brandTile?: Maybe<BrandTileCreateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsCreaterestaurantImagesInput>;
}

export interface BrandTileUpdateInput {
  type?: Maybe<String>;
  imageurl?: Maybe<String>;
  order?: Maybe<Int>;
  restaurantses?: Maybe<RestaurantsUpdateManyWithoutBrandTileInput>;
  brandTileName?: Maybe<String>;
}

export interface RestaurantsUpdateManyWithoutBrandTileInput {
  create?: Maybe<
    | RestaurantsCreateWithoutBrandTileInput[]
    | RestaurantsCreateWithoutBrandTileInput
  >;
  delete?: Maybe<RestaurantsWhereUniqueInput[] | RestaurantsWhereUniqueInput>;
  connect?: Maybe<RestaurantsWhereUniqueInput[] | RestaurantsWhereUniqueInput>;
  set?: Maybe<RestaurantsWhereUniqueInput[] | RestaurantsWhereUniqueInput>;
  disconnect?: Maybe<
    RestaurantsWhereUniqueInput[] | RestaurantsWhereUniqueInput
  >;
  update?: Maybe<
    | RestaurantsUpdateWithWhereUniqueWithoutBrandTileInput[]
    | RestaurantsUpdateWithWhereUniqueWithoutBrandTileInput
  >;
  upsert?: Maybe<
    | RestaurantsUpsertWithWhereUniqueWithoutBrandTileInput[]
    | RestaurantsUpsertWithWhereUniqueWithoutBrandTileInput
  >;
  deleteMany?: Maybe<
    RestaurantsScalarWhereInput[] | RestaurantsScalarWhereInput
  >;
  updateMany?: Maybe<
    | RestaurantsUpdateManyWithWhereNestedInput[]
    | RestaurantsUpdateManyWithWhereNestedInput
  >;
}

export interface RestaurantsUpdateWithWhereUniqueWithoutBrandTileInput {
  where: RestaurantsWhereUniqueInput;
  data: RestaurantsUpdateWithoutBrandTileDataInput;
}

export interface RestaurantsUpdateWithoutBrandTileDataInput {
  city?: Maybe<String>;
  enableLoginAccess?: Maybe<Boolean>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersUpdateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeUpdateManyWithoutRestaurantsesInput>;
  state?: Maybe<String>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsUpdateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsUpdateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsUpdaterphoneInput>;
  friday?: Maybe<FridayUpdateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayUpdateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsUpdatemenuInput>;
  restaurantImages?: Maybe<RestaurantsUpdaterestaurantImagesInput>;
}

export interface OrdersUpdateManyWithoutRestaurantsInput {
  create?: Maybe<
    OrdersCreateWithoutRestaurantsInput[] | OrdersCreateWithoutRestaurantsInput
  >;
  delete?: Maybe<OrdersWhereUniqueInput[] | OrdersWhereUniqueInput>;
  connect?: Maybe<OrdersWhereUniqueInput[] | OrdersWhereUniqueInput>;
  set?: Maybe<OrdersWhereUniqueInput[] | OrdersWhereUniqueInput>;
  disconnect?: Maybe<OrdersWhereUniqueInput[] | OrdersWhereUniqueInput>;
  update?: Maybe<
    | OrdersUpdateWithWhereUniqueWithoutRestaurantsInput[]
    | OrdersUpdateWithWhereUniqueWithoutRestaurantsInput
  >;
  upsert?: Maybe<
    | OrdersUpsertWithWhereUniqueWithoutRestaurantsInput[]
    | OrdersUpsertWithWhereUniqueWithoutRestaurantsInput
  >;
  deleteMany?: Maybe<OrdersScalarWhereInput[] | OrdersScalarWhereInput>;
  updateMany?: Maybe<
    | OrdersUpdateManyWithWhereNestedInput[]
    | OrdersUpdateManyWithWhereNestedInput
  >;
}

export interface OrdersUpdateWithWhereUniqueWithoutRestaurantsInput {
  where: OrdersWhereUniqueInput;
  data: OrdersUpdateWithoutRestaurantsDataInput;
}

export interface OrdersUpdateWithoutRestaurantsDataInput {
  timeDiscount?: Maybe<TimeDiscountUpdateOneWithoutOrdersesInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutOrdersesInput>;
  date?: Maybe<String>;
  totalDiscount?: Maybe<Int>;
  people?: Maybe<Int>;
  bookingid?: Maybe<String>;
  mobile?: Maybe<String>;
  unlockActive?: Maybe<Boolean>;
  name?: Maybe<String>;
  geolocation?: Maybe<String>;
  referrer?: Maybe<String>;
  confirmed?: Maybe<Boolean>;
  cancelled?: Maybe<Boolean>;
  amount?: Maybe<Int>;
  receipt?: Maybe<String>;
  paymentId?: Maybe<String>;
  paymentOrderId?: Maybe<String>;
  paymentDescription?: Maybe<String>;
}

export interface TimeDiscountUpdateOneWithoutOrdersesInput {
  create?: Maybe<TimeDiscountCreateWithoutOrdersesInput>;
  update?: Maybe<TimeDiscountUpdateWithoutOrdersesDataInput>;
  upsert?: Maybe<TimeDiscountUpsertWithoutOrdersesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TimeDiscountWhereUniqueInput>;
}

export interface TimeDiscountUpdateWithoutOrdersesDataInput {
  discount?: Maybe<Float>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutTimeDiscountsInput>;
  time?: Maybe<String>;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  friday?: Maybe<FridayUpdateOneWithoutTimeDiscountsInput>;
  monday?: Maybe<MondayUpdateOneWithoutTimeDiscountsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutTimeDiscountsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutTimeDiscountsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutTimeDiscountsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutTimeDiscountsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface RestaurantsUpdateOneWithoutTimeDiscountsInput {
  create?: Maybe<RestaurantsCreateWithoutTimeDiscountsInput>;
  update?: Maybe<RestaurantsUpdateWithoutTimeDiscountsDataInput>;
  upsert?: Maybe<RestaurantsUpsertWithoutTimeDiscountsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsUpdateWithoutTimeDiscountsDataInput {
  city?: Maybe<String>;
  enableLoginAccess?: Maybe<Boolean>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersUpdateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeUpdateManyWithoutRestaurantsesInput>;
  state?: Maybe<String>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsUpdateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsUpdateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsUpdaterphoneInput>;
  friday?: Maybe<FridayUpdateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayUpdateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsUpdatemenuInput>;
  brandTile?: Maybe<BrandTileUpdateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsUpdaterestaurantImagesInput>;
}

export interface RestaurantTypeUpdateManyWithoutRestaurantsesInput {
  create?: Maybe<
    | RestaurantTypeCreateWithoutRestaurantsesInput[]
    | RestaurantTypeCreateWithoutRestaurantsesInput
  >;
  delete?: Maybe<
    RestaurantTypeWhereUniqueInput[] | RestaurantTypeWhereUniqueInput
  >;
  connect?: Maybe<
    RestaurantTypeWhereUniqueInput[] | RestaurantTypeWhereUniqueInput
  >;
  set?: Maybe<
    RestaurantTypeWhereUniqueInput[] | RestaurantTypeWhereUniqueInput
  >;
  disconnect?: Maybe<
    RestaurantTypeWhereUniqueInput[] | RestaurantTypeWhereUniqueInput
  >;
  update?: Maybe<
    | RestaurantTypeUpdateWithWhereUniqueWithoutRestaurantsesInput[]
    | RestaurantTypeUpdateWithWhereUniqueWithoutRestaurantsesInput
  >;
  upsert?: Maybe<
    | RestaurantTypeUpsertWithWhereUniqueWithoutRestaurantsesInput[]
    | RestaurantTypeUpsertWithWhereUniqueWithoutRestaurantsesInput
  >;
  deleteMany?: Maybe<
    RestaurantTypeScalarWhereInput[] | RestaurantTypeScalarWhereInput
  >;
  updateMany?: Maybe<
    | RestaurantTypeUpdateManyWithWhereNestedInput[]
    | RestaurantTypeUpdateManyWithWhereNestedInput
  >;
}

export interface RestaurantTypeUpdateWithWhereUniqueWithoutRestaurantsesInput {
  where: RestaurantTypeWhereUniqueInput;
  data: RestaurantTypeUpdateWithoutRestaurantsesDataInput;
}

export interface RestaurantTypeUpdateWithoutRestaurantsesDataInput {
  type?: Maybe<String>;
  imageurl?: Maybe<String>;
  order?: Maybe<Int>;
  typeName?: Maybe<String>;
  cityImage?: Maybe<String>;
  activatePremium?: Maybe<Boolean>;
  premiumPrice?: Maybe<Int>;
}

export interface RestaurantTypeUpsertWithWhereUniqueWithoutRestaurantsesInput {
  where: RestaurantTypeWhereUniqueInput;
  update: RestaurantTypeUpdateWithoutRestaurantsesDataInput;
  create: RestaurantTypeCreateWithoutRestaurantsesInput;
}

export interface RestaurantTypeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  imageurl?: Maybe<String>;
  imageurl_not?: Maybe<String>;
  imageurl_in?: Maybe<String[] | String>;
  imageurl_not_in?: Maybe<String[] | String>;
  imageurl_lt?: Maybe<String>;
  imageurl_lte?: Maybe<String>;
  imageurl_gt?: Maybe<String>;
  imageurl_gte?: Maybe<String>;
  imageurl_contains?: Maybe<String>;
  imageurl_not_contains?: Maybe<String>;
  imageurl_starts_with?: Maybe<String>;
  imageurl_not_starts_with?: Maybe<String>;
  imageurl_ends_with?: Maybe<String>;
  imageurl_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  typeName?: Maybe<String>;
  typeName_not?: Maybe<String>;
  typeName_in?: Maybe<String[] | String>;
  typeName_not_in?: Maybe<String[] | String>;
  typeName_lt?: Maybe<String>;
  typeName_lte?: Maybe<String>;
  typeName_gt?: Maybe<String>;
  typeName_gte?: Maybe<String>;
  typeName_contains?: Maybe<String>;
  typeName_not_contains?: Maybe<String>;
  typeName_starts_with?: Maybe<String>;
  typeName_not_starts_with?: Maybe<String>;
  typeName_ends_with?: Maybe<String>;
  typeName_not_ends_with?: Maybe<String>;
  cityImage?: Maybe<String>;
  cityImage_not?: Maybe<String>;
  cityImage_in?: Maybe<String[] | String>;
  cityImage_not_in?: Maybe<String[] | String>;
  cityImage_lt?: Maybe<String>;
  cityImage_lte?: Maybe<String>;
  cityImage_gt?: Maybe<String>;
  cityImage_gte?: Maybe<String>;
  cityImage_contains?: Maybe<String>;
  cityImage_not_contains?: Maybe<String>;
  cityImage_starts_with?: Maybe<String>;
  cityImage_not_starts_with?: Maybe<String>;
  cityImage_ends_with?: Maybe<String>;
  cityImage_not_ends_with?: Maybe<String>;
  activatePremium?: Maybe<Boolean>;
  activatePremium_not?: Maybe<Boolean>;
  premiumPrice?: Maybe<Int>;
  premiumPrice_not?: Maybe<Int>;
  premiumPrice_in?: Maybe<Int[] | Int>;
  premiumPrice_not_in?: Maybe<Int[] | Int>;
  premiumPrice_lt?: Maybe<Int>;
  premiumPrice_lte?: Maybe<Int>;
  premiumPrice_gt?: Maybe<Int>;
  premiumPrice_gte?: Maybe<Int>;
  AND?: Maybe<
    RestaurantTypeScalarWhereInput[] | RestaurantTypeScalarWhereInput
  >;
  OR?: Maybe<RestaurantTypeScalarWhereInput[] | RestaurantTypeScalarWhereInput>;
  NOT?: Maybe<
    RestaurantTypeScalarWhereInput[] | RestaurantTypeScalarWhereInput
  >;
}

export interface RestaurantTypeUpdateManyWithWhereNestedInput {
  where: RestaurantTypeScalarWhereInput;
  data: RestaurantTypeUpdateManyDataInput;
}

export interface RestaurantTypeUpdateManyDataInput {
  type?: Maybe<String>;
  imageurl?: Maybe<String>;
  order?: Maybe<Int>;
  typeName?: Maybe<String>;
  cityImage?: Maybe<String>;
  activatePremium?: Maybe<Boolean>;
  premiumPrice?: Maybe<Int>;
}

export interface UserReviewsUpdateManyWithoutRestaurantsInput {
  create?: Maybe<
    | UserReviewsCreateWithoutRestaurantsInput[]
    | UserReviewsCreateWithoutRestaurantsInput
  >;
  delete?: Maybe<UserReviewsWhereUniqueInput[] | UserReviewsWhereUniqueInput>;
  connect?: Maybe<UserReviewsWhereUniqueInput[] | UserReviewsWhereUniqueInput>;
  set?: Maybe<UserReviewsWhereUniqueInput[] | UserReviewsWhereUniqueInput>;
  disconnect?: Maybe<
    UserReviewsWhereUniqueInput[] | UserReviewsWhereUniqueInput
  >;
  update?: Maybe<
    | UserReviewsUpdateWithWhereUniqueWithoutRestaurantsInput[]
    | UserReviewsUpdateWithWhereUniqueWithoutRestaurantsInput
  >;
  upsert?: Maybe<
    | UserReviewsUpsertWithWhereUniqueWithoutRestaurantsInput[]
    | UserReviewsUpsertWithWhereUniqueWithoutRestaurantsInput
  >;
  deleteMany?: Maybe<
    UserReviewsScalarWhereInput[] | UserReviewsScalarWhereInput
  >;
  updateMany?: Maybe<
    | UserReviewsUpdateManyWithWhereNestedInput[]
    | UserReviewsUpdateManyWithWhereNestedInput
  >;
}

export interface UserReviewsUpdateWithWhereUniqueWithoutRestaurantsInput {
  where: UserReviewsWhereUniqueInput;
  data: UserReviewsUpdateWithoutRestaurantsDataInput;
}

export interface UserReviewsUpdateWithoutRestaurantsDataInput {
  review?: Maybe<String>;
  rating?: Maybe<Int>;
  user?: Maybe<UserUpdateOneWithoutUserReviewsesInput>;
}

export interface UserUpdateOneWithoutUserReviewsesInput {
  create?: Maybe<UserCreateWithoutUserReviewsesInput>;
  update?: Maybe<UserUpdateWithoutUserReviewsesDataInput>;
  upsert?: Maybe<UserUpsertWithoutUserReviewsesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutUserReviewsesDataInput {
  email?: Maybe<String>;
  firstname?: Maybe<String>;
  facebookID?: Maybe<String>;
  lastname?: Maybe<String>;
  mobile?: Maybe<String>;
  totalOrders?: Maybe<Int>;
  orderses?: Maybe<OrdersUpdateManyWithoutUserInput>;
  contactSync?: Maybe<Boolean>;
  isBlocked?: Maybe<Boolean>;
  promoCode?: Maybe<String>;
  userPromoCount?: Maybe<Int>;
  typeAccess?: Maybe<String>;
  password?: Maybe<String>;
  installLocation?: Maybe<String>;
  isPremiumUser?: Maybe<String>;
  currentLocation?: Maybe<String>;
  profileImage?: Maybe<String>;
  bookingOtp?: Maybe<String>;
  otpExpires?: Maybe<DateTimeInput>;
  premiumStartDate?: Maybe<DateTimeInput>;
  premiumExpireDate?: Maybe<DateTimeInput>;
}

export interface OrdersUpdateManyWithoutUserInput {
  create?: Maybe<OrdersCreateWithoutUserInput[] | OrdersCreateWithoutUserInput>;
  delete?: Maybe<OrdersWhereUniqueInput[] | OrdersWhereUniqueInput>;
  connect?: Maybe<OrdersWhereUniqueInput[] | OrdersWhereUniqueInput>;
  set?: Maybe<OrdersWhereUniqueInput[] | OrdersWhereUniqueInput>;
  disconnect?: Maybe<OrdersWhereUniqueInput[] | OrdersWhereUniqueInput>;
  update?: Maybe<
    | OrdersUpdateWithWhereUniqueWithoutUserInput[]
    | OrdersUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | OrdersUpsertWithWhereUniqueWithoutUserInput[]
    | OrdersUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<OrdersScalarWhereInput[] | OrdersScalarWhereInput>;
  updateMany?: Maybe<
    | OrdersUpdateManyWithWhereNestedInput[]
    | OrdersUpdateManyWithWhereNestedInput
  >;
}

export interface OrdersUpdateWithWhereUniqueWithoutUserInput {
  where: OrdersWhereUniqueInput;
  data: OrdersUpdateWithoutUserDataInput;
}

export interface OrdersUpdateWithoutUserDataInput {
  restaurants?: Maybe<RestaurantsUpdateOneWithoutOrdersesInput>;
  timeDiscount?: Maybe<TimeDiscountUpdateOneWithoutOrdersesInput>;
  date?: Maybe<String>;
  totalDiscount?: Maybe<Int>;
  people?: Maybe<Int>;
  bookingid?: Maybe<String>;
  mobile?: Maybe<String>;
  unlockActive?: Maybe<Boolean>;
  name?: Maybe<String>;
  geolocation?: Maybe<String>;
  referrer?: Maybe<String>;
  confirmed?: Maybe<Boolean>;
  cancelled?: Maybe<Boolean>;
  amount?: Maybe<Int>;
  receipt?: Maybe<String>;
  paymentId?: Maybe<String>;
  paymentOrderId?: Maybe<String>;
  paymentDescription?: Maybe<String>;
}

export interface RestaurantsUpdateOneWithoutOrdersesInput {
  create?: Maybe<RestaurantsCreateWithoutOrdersesInput>;
  update?: Maybe<RestaurantsUpdateWithoutOrdersesDataInput>;
  upsert?: Maybe<RestaurantsUpsertWithoutOrdersesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsUpdateWithoutOrdersesDataInput {
  city?: Maybe<String>;
  enableLoginAccess?: Maybe<Boolean>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeUpdateManyWithoutRestaurantsesInput>;
  state?: Maybe<String>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsUpdateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsUpdateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsUpdaterphoneInput>;
  friday?: Maybe<FridayUpdateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayUpdateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsUpdatemenuInput>;
  brandTile?: Maybe<BrandTileUpdateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsUpdaterestaurantImagesInput>;
}

export interface TimeDiscountUpdateManyWithoutRestaurantsInput {
  create?: Maybe<
    | TimeDiscountCreateWithoutRestaurantsInput[]
    | TimeDiscountCreateWithoutRestaurantsInput
  >;
  delete?: Maybe<TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput>;
  connect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
  set?: Maybe<TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput>;
  disconnect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
  update?: Maybe<
    | TimeDiscountUpdateWithWhereUniqueWithoutRestaurantsInput[]
    | TimeDiscountUpdateWithWhereUniqueWithoutRestaurantsInput
  >;
  upsert?: Maybe<
    | TimeDiscountUpsertWithWhereUniqueWithoutRestaurantsInput[]
    | TimeDiscountUpsertWithWhereUniqueWithoutRestaurantsInput
  >;
  deleteMany?: Maybe<
    TimeDiscountScalarWhereInput[] | TimeDiscountScalarWhereInput
  >;
  updateMany?: Maybe<
    | TimeDiscountUpdateManyWithWhereNestedInput[]
    | TimeDiscountUpdateManyWithWhereNestedInput
  >;
}

export interface TimeDiscountUpdateWithWhereUniqueWithoutRestaurantsInput {
  where: TimeDiscountWhereUniqueInput;
  data: TimeDiscountUpdateWithoutRestaurantsDataInput;
}

export interface TimeDiscountUpdateWithoutRestaurantsDataInput {
  discount?: Maybe<Float>;
  orderses?: Maybe<OrdersUpdateManyWithoutTimeDiscountInput>;
  time?: Maybe<String>;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  friday?: Maybe<FridayUpdateOneWithoutTimeDiscountsInput>;
  monday?: Maybe<MondayUpdateOneWithoutTimeDiscountsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutTimeDiscountsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutTimeDiscountsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutTimeDiscountsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutTimeDiscountsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface OrdersUpdateManyWithoutTimeDiscountInput {
  create?: Maybe<
    | OrdersCreateWithoutTimeDiscountInput[]
    | OrdersCreateWithoutTimeDiscountInput
  >;
  delete?: Maybe<OrdersWhereUniqueInput[] | OrdersWhereUniqueInput>;
  connect?: Maybe<OrdersWhereUniqueInput[] | OrdersWhereUniqueInput>;
  set?: Maybe<OrdersWhereUniqueInput[] | OrdersWhereUniqueInput>;
  disconnect?: Maybe<OrdersWhereUniqueInput[] | OrdersWhereUniqueInput>;
  update?: Maybe<
    | OrdersUpdateWithWhereUniqueWithoutTimeDiscountInput[]
    | OrdersUpdateWithWhereUniqueWithoutTimeDiscountInput
  >;
  upsert?: Maybe<
    | OrdersUpsertWithWhereUniqueWithoutTimeDiscountInput[]
    | OrdersUpsertWithWhereUniqueWithoutTimeDiscountInput
  >;
  deleteMany?: Maybe<OrdersScalarWhereInput[] | OrdersScalarWhereInput>;
  updateMany?: Maybe<
    | OrdersUpdateManyWithWhereNestedInput[]
    | OrdersUpdateManyWithWhereNestedInput
  >;
}

export interface OrdersUpdateWithWhereUniqueWithoutTimeDiscountInput {
  where: OrdersWhereUniqueInput;
  data: OrdersUpdateWithoutTimeDiscountDataInput;
}

export interface OrdersUpdateWithoutTimeDiscountDataInput {
  restaurants?: Maybe<RestaurantsUpdateOneWithoutOrdersesInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutOrdersesInput>;
  date?: Maybe<String>;
  totalDiscount?: Maybe<Int>;
  people?: Maybe<Int>;
  bookingid?: Maybe<String>;
  mobile?: Maybe<String>;
  unlockActive?: Maybe<Boolean>;
  name?: Maybe<String>;
  geolocation?: Maybe<String>;
  referrer?: Maybe<String>;
  confirmed?: Maybe<Boolean>;
  cancelled?: Maybe<Boolean>;
  amount?: Maybe<Int>;
  receipt?: Maybe<String>;
  paymentId?: Maybe<String>;
  paymentOrderId?: Maybe<String>;
  paymentDescription?: Maybe<String>;
}

export interface UserUpdateOneRequiredWithoutOrdersesInput {
  create?: Maybe<UserCreateWithoutOrdersesInput>;
  update?: Maybe<UserUpdateWithoutOrdersesDataInput>;
  upsert?: Maybe<UserUpsertWithoutOrdersesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutOrdersesDataInput {
  email?: Maybe<String>;
  firstname?: Maybe<String>;
  facebookID?: Maybe<String>;
  lastname?: Maybe<String>;
  mobile?: Maybe<String>;
  totalOrders?: Maybe<Int>;
  contactSync?: Maybe<Boolean>;
  userReviewses?: Maybe<UserReviewsUpdateManyWithoutUserInput>;
  isBlocked?: Maybe<Boolean>;
  promoCode?: Maybe<String>;
  userPromoCount?: Maybe<Int>;
  typeAccess?: Maybe<String>;
  password?: Maybe<String>;
  installLocation?: Maybe<String>;
  isPremiumUser?: Maybe<String>;
  currentLocation?: Maybe<String>;
  profileImage?: Maybe<String>;
  bookingOtp?: Maybe<String>;
  otpExpires?: Maybe<DateTimeInput>;
  premiumStartDate?: Maybe<DateTimeInput>;
  premiumExpireDate?: Maybe<DateTimeInput>;
}

export interface UserReviewsUpdateManyWithoutUserInput {
  create?: Maybe<
    UserReviewsCreateWithoutUserInput[] | UserReviewsCreateWithoutUserInput
  >;
  delete?: Maybe<UserReviewsWhereUniqueInput[] | UserReviewsWhereUniqueInput>;
  connect?: Maybe<UserReviewsWhereUniqueInput[] | UserReviewsWhereUniqueInput>;
  set?: Maybe<UserReviewsWhereUniqueInput[] | UserReviewsWhereUniqueInput>;
  disconnect?: Maybe<
    UserReviewsWhereUniqueInput[] | UserReviewsWhereUniqueInput
  >;
  update?: Maybe<
    | UserReviewsUpdateWithWhereUniqueWithoutUserInput[]
    | UserReviewsUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | UserReviewsUpsertWithWhereUniqueWithoutUserInput[]
    | UserReviewsUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    UserReviewsScalarWhereInput[] | UserReviewsScalarWhereInput
  >;
  updateMany?: Maybe<
    | UserReviewsUpdateManyWithWhereNestedInput[]
    | UserReviewsUpdateManyWithWhereNestedInput
  >;
}

export interface UserReviewsUpdateWithWhereUniqueWithoutUserInput {
  where: UserReviewsWhereUniqueInput;
  data: UserReviewsUpdateWithoutUserDataInput;
}

export interface UserReviewsUpdateWithoutUserDataInput {
  review?: Maybe<String>;
  rating?: Maybe<Int>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutUserReviewsesInput>;
}

export interface RestaurantsUpdateOneWithoutUserReviewsesInput {
  create?: Maybe<RestaurantsCreateWithoutUserReviewsesInput>;
  update?: Maybe<RestaurantsUpdateWithoutUserReviewsesDataInput>;
  upsert?: Maybe<RestaurantsUpsertWithoutUserReviewsesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsUpdateWithoutUserReviewsesDataInput {
  city?: Maybe<String>;
  enableLoginAccess?: Maybe<Boolean>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersUpdateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeUpdateManyWithoutRestaurantsesInput>;
  state?: Maybe<String>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  hotDealses?: Maybe<HotDealsUpdateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsUpdaterphoneInput>;
  friday?: Maybe<FridayUpdateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayUpdateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsUpdatemenuInput>;
  brandTile?: Maybe<BrandTileUpdateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsUpdaterestaurantImagesInput>;
}

export interface HotDealsUpdateManyWithoutRestaurantsesInput {
  create?: Maybe<
    | HotDealsCreateWithoutRestaurantsesInput[]
    | HotDealsCreateWithoutRestaurantsesInput
  >;
  delete?: Maybe<HotDealsWhereUniqueInput[] | HotDealsWhereUniqueInput>;
  connect?: Maybe<HotDealsWhereUniqueInput[] | HotDealsWhereUniqueInput>;
  set?: Maybe<HotDealsWhereUniqueInput[] | HotDealsWhereUniqueInput>;
  disconnect?: Maybe<HotDealsWhereUniqueInput[] | HotDealsWhereUniqueInput>;
  update?: Maybe<
    | HotDealsUpdateWithWhereUniqueWithoutRestaurantsesInput[]
    | HotDealsUpdateWithWhereUniqueWithoutRestaurantsesInput
  >;
  upsert?: Maybe<
    | HotDealsUpsertWithWhereUniqueWithoutRestaurantsesInput[]
    | HotDealsUpsertWithWhereUniqueWithoutRestaurantsesInput
  >;
  deleteMany?: Maybe<HotDealsScalarWhereInput[] | HotDealsScalarWhereInput>;
  updateMany?: Maybe<
    | HotDealsUpdateManyWithWhereNestedInput[]
    | HotDealsUpdateManyWithWhereNestedInput
  >;
}

export interface HotDealsUpdateWithWhereUniqueWithoutRestaurantsesInput {
  where: HotDealsWhereUniqueInput;
  data: HotDealsUpdateWithoutRestaurantsesDataInput;
}

export interface HotDealsUpdateWithoutRestaurantsesDataInput {
  type?: Maybe<String>;
  imageurl?: Maybe<String>;
}

export interface HotDealsUpsertWithWhereUniqueWithoutRestaurantsesInput {
  where: HotDealsWhereUniqueInput;
  update: HotDealsUpdateWithoutRestaurantsesDataInput;
  create: HotDealsCreateWithoutRestaurantsesInput;
}

export interface HotDealsScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  imageurl?: Maybe<String>;
  imageurl_not?: Maybe<String>;
  imageurl_in?: Maybe<String[] | String>;
  imageurl_not_in?: Maybe<String[] | String>;
  imageurl_lt?: Maybe<String>;
  imageurl_lte?: Maybe<String>;
  imageurl_gt?: Maybe<String>;
  imageurl_gte?: Maybe<String>;
  imageurl_contains?: Maybe<String>;
  imageurl_not_contains?: Maybe<String>;
  imageurl_starts_with?: Maybe<String>;
  imageurl_not_starts_with?: Maybe<String>;
  imageurl_ends_with?: Maybe<String>;
  imageurl_not_ends_with?: Maybe<String>;
  AND?: Maybe<HotDealsScalarWhereInput[] | HotDealsScalarWhereInput>;
  OR?: Maybe<HotDealsScalarWhereInput[] | HotDealsScalarWhereInput>;
  NOT?: Maybe<HotDealsScalarWhereInput[] | HotDealsScalarWhereInput>;
}

export interface HotDealsUpdateManyWithWhereNestedInput {
  where: HotDealsScalarWhereInput;
  data: HotDealsUpdateManyDataInput;
}

export interface HotDealsUpdateManyDataInput {
  type?: Maybe<String>;
  imageurl?: Maybe<String>;
}

export interface RestaurantsUpdaterphoneInput {
  set?: Maybe<String[] | String>;
}

export interface FridayUpdateOneWithoutRestaurantsInput {
  create?: Maybe<FridayCreateWithoutRestaurantsInput>;
  update?: Maybe<FridayUpdateWithoutRestaurantsDataInput>;
  upsert?: Maybe<FridayUpsertWithoutRestaurantsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<FridayWhereUniqueInput>;
}

export interface FridayUpdateWithoutRestaurantsDataInput {
  exhausted?: Maybe<Boolean>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutFridayInput>;
  order?: Maybe<Int>;
}

export interface TimeDiscountUpdateManyWithoutFridayInput {
  create?: Maybe<
    | TimeDiscountCreateWithoutFridayInput[]
    | TimeDiscountCreateWithoutFridayInput
  >;
  delete?: Maybe<TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput>;
  connect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
  set?: Maybe<TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput>;
  disconnect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
  update?: Maybe<
    | TimeDiscountUpdateWithWhereUniqueWithoutFridayInput[]
    | TimeDiscountUpdateWithWhereUniqueWithoutFridayInput
  >;
  upsert?: Maybe<
    | TimeDiscountUpsertWithWhereUniqueWithoutFridayInput[]
    | TimeDiscountUpsertWithWhereUniqueWithoutFridayInput
  >;
  deleteMany?: Maybe<
    TimeDiscountScalarWhereInput[] | TimeDiscountScalarWhereInput
  >;
  updateMany?: Maybe<
    | TimeDiscountUpdateManyWithWhereNestedInput[]
    | TimeDiscountUpdateManyWithWhereNestedInput
  >;
}

export interface TimeDiscountUpdateWithWhereUniqueWithoutFridayInput {
  where: TimeDiscountWhereUniqueInput;
  data: TimeDiscountUpdateWithoutFridayDataInput;
}

export interface TimeDiscountUpdateWithoutFridayDataInput {
  discount?: Maybe<Float>;
  orderses?: Maybe<OrdersUpdateManyWithoutTimeDiscountInput>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutTimeDiscountsInput>;
  time?: Maybe<String>;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  monday?: Maybe<MondayUpdateOneWithoutTimeDiscountsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutTimeDiscountsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutTimeDiscountsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutTimeDiscountsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutTimeDiscountsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface MondayUpdateOneWithoutTimeDiscountsInput {
  create?: Maybe<MondayCreateWithoutTimeDiscountsInput>;
  update?: Maybe<MondayUpdateWithoutTimeDiscountsDataInput>;
  upsert?: Maybe<MondayUpsertWithoutTimeDiscountsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<MondayWhereUniqueInput>;
}

export interface MondayUpdateWithoutTimeDiscountsDataInput {
  exhausted?: Maybe<Boolean>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutMondayInput>;
  order?: Maybe<Int>;
}

export interface RestaurantsUpdateOneWithoutMondayInput {
  create?: Maybe<RestaurantsCreateWithoutMondayInput>;
  update?: Maybe<RestaurantsUpdateWithoutMondayDataInput>;
  upsert?: Maybe<RestaurantsUpsertWithoutMondayInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsUpdateWithoutMondayDataInput {
  city?: Maybe<String>;
  enableLoginAccess?: Maybe<Boolean>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersUpdateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeUpdateManyWithoutRestaurantsesInput>;
  state?: Maybe<String>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsUpdateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsUpdateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsUpdaterphoneInput>;
  friday?: Maybe<FridayUpdateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsUpdatemenuInput>;
  brandTile?: Maybe<BrandTileUpdateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsUpdaterestaurantImagesInput>;
}

export interface SaturdayUpdateOneWithoutRestaurantsInput {
  create?: Maybe<SaturdayCreateWithoutRestaurantsInput>;
  update?: Maybe<SaturdayUpdateWithoutRestaurantsDataInput>;
  upsert?: Maybe<SaturdayUpsertWithoutRestaurantsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SaturdayWhereUniqueInput>;
}

export interface SaturdayUpdateWithoutRestaurantsDataInput {
  exhausted?: Maybe<Boolean>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutSaturdayInput>;
  order?: Maybe<Int>;
}

export interface TimeDiscountUpdateManyWithoutSaturdayInput {
  create?: Maybe<
    | TimeDiscountCreateWithoutSaturdayInput[]
    | TimeDiscountCreateWithoutSaturdayInput
  >;
  delete?: Maybe<TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput>;
  connect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
  set?: Maybe<TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput>;
  disconnect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
  update?: Maybe<
    | TimeDiscountUpdateWithWhereUniqueWithoutSaturdayInput[]
    | TimeDiscountUpdateWithWhereUniqueWithoutSaturdayInput
  >;
  upsert?: Maybe<
    | TimeDiscountUpsertWithWhereUniqueWithoutSaturdayInput[]
    | TimeDiscountUpsertWithWhereUniqueWithoutSaturdayInput
  >;
  deleteMany?: Maybe<
    TimeDiscountScalarWhereInput[] | TimeDiscountScalarWhereInput
  >;
  updateMany?: Maybe<
    | TimeDiscountUpdateManyWithWhereNestedInput[]
    | TimeDiscountUpdateManyWithWhereNestedInput
  >;
}

export interface TimeDiscountUpdateWithWhereUniqueWithoutSaturdayInput {
  where: TimeDiscountWhereUniqueInput;
  data: TimeDiscountUpdateWithoutSaturdayDataInput;
}

export interface TimeDiscountUpdateWithoutSaturdayDataInput {
  discount?: Maybe<Float>;
  orderses?: Maybe<OrdersUpdateManyWithoutTimeDiscountInput>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutTimeDiscountsInput>;
  time?: Maybe<String>;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  friday?: Maybe<FridayUpdateOneWithoutTimeDiscountsInput>;
  monday?: Maybe<MondayUpdateOneWithoutTimeDiscountsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutTimeDiscountsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutTimeDiscountsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutTimeDiscountsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface FridayUpdateOneWithoutTimeDiscountsInput {
  create?: Maybe<FridayCreateWithoutTimeDiscountsInput>;
  update?: Maybe<FridayUpdateWithoutTimeDiscountsDataInput>;
  upsert?: Maybe<FridayUpsertWithoutTimeDiscountsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<FridayWhereUniqueInput>;
}

export interface FridayUpdateWithoutTimeDiscountsDataInput {
  exhausted?: Maybe<Boolean>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutFridayInput>;
  order?: Maybe<Int>;
}

export interface RestaurantsUpdateOneWithoutFridayInput {
  create?: Maybe<RestaurantsCreateWithoutFridayInput>;
  update?: Maybe<RestaurantsUpdateWithoutFridayDataInput>;
  upsert?: Maybe<RestaurantsUpsertWithoutFridayInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsUpdateWithoutFridayDataInput {
  city?: Maybe<String>;
  enableLoginAccess?: Maybe<Boolean>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersUpdateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeUpdateManyWithoutRestaurantsesInput>;
  state?: Maybe<String>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsUpdateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsUpdateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsUpdaterphoneInput>;
  monday?: Maybe<MondayUpdateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsUpdatemenuInput>;
  brandTile?: Maybe<BrandTileUpdateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsUpdaterestaurantImagesInput>;
}

export interface MondayUpdateOneWithoutRestaurantsInput {
  create?: Maybe<MondayCreateWithoutRestaurantsInput>;
  update?: Maybe<MondayUpdateWithoutRestaurantsDataInput>;
  upsert?: Maybe<MondayUpsertWithoutRestaurantsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<MondayWhereUniqueInput>;
}

export interface MondayUpdateWithoutRestaurantsDataInput {
  exhausted?: Maybe<Boolean>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutMondayInput>;
  order?: Maybe<Int>;
}

export interface TimeDiscountUpdateManyWithoutMondayInput {
  create?: Maybe<
    | TimeDiscountCreateWithoutMondayInput[]
    | TimeDiscountCreateWithoutMondayInput
  >;
  delete?: Maybe<TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput>;
  connect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
  set?: Maybe<TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput>;
  disconnect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
  update?: Maybe<
    | TimeDiscountUpdateWithWhereUniqueWithoutMondayInput[]
    | TimeDiscountUpdateWithWhereUniqueWithoutMondayInput
  >;
  upsert?: Maybe<
    | TimeDiscountUpsertWithWhereUniqueWithoutMondayInput[]
    | TimeDiscountUpsertWithWhereUniqueWithoutMondayInput
  >;
  deleteMany?: Maybe<
    TimeDiscountScalarWhereInput[] | TimeDiscountScalarWhereInput
  >;
  updateMany?: Maybe<
    | TimeDiscountUpdateManyWithWhereNestedInput[]
    | TimeDiscountUpdateManyWithWhereNestedInput
  >;
}

export interface TimeDiscountUpdateWithWhereUniqueWithoutMondayInput {
  where: TimeDiscountWhereUniqueInput;
  data: TimeDiscountUpdateWithoutMondayDataInput;
}

export interface TimeDiscountUpdateWithoutMondayDataInput {
  discount?: Maybe<Float>;
  orderses?: Maybe<OrdersUpdateManyWithoutTimeDiscountInput>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutTimeDiscountsInput>;
  time?: Maybe<String>;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  friday?: Maybe<FridayUpdateOneWithoutTimeDiscountsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutTimeDiscountsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutTimeDiscountsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutTimeDiscountsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutTimeDiscountsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface SaturdayUpdateOneWithoutTimeDiscountsInput {
  create?: Maybe<SaturdayCreateWithoutTimeDiscountsInput>;
  update?: Maybe<SaturdayUpdateWithoutTimeDiscountsDataInput>;
  upsert?: Maybe<SaturdayUpsertWithoutTimeDiscountsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SaturdayWhereUniqueInput>;
}

export interface SaturdayUpdateWithoutTimeDiscountsDataInput {
  exhausted?: Maybe<Boolean>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutSaturdayInput>;
  order?: Maybe<Int>;
}

export interface RestaurantsUpdateOneWithoutSaturdayInput {
  create?: Maybe<RestaurantsCreateWithoutSaturdayInput>;
  update?: Maybe<RestaurantsUpdateWithoutSaturdayDataInput>;
  upsert?: Maybe<RestaurantsUpsertWithoutSaturdayInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsUpdateWithoutSaturdayDataInput {
  city?: Maybe<String>;
  enableLoginAccess?: Maybe<Boolean>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersUpdateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeUpdateManyWithoutRestaurantsesInput>;
  state?: Maybe<String>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsUpdateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsUpdateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsUpdaterphoneInput>;
  friday?: Maybe<FridayUpdateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayUpdateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsUpdatemenuInput>;
  brandTile?: Maybe<BrandTileUpdateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsUpdaterestaurantImagesInput>;
}

export interface SundayUpdateOneWithoutRestaurantsInput {
  create?: Maybe<SundayCreateWithoutRestaurantsInput>;
  update?: Maybe<SundayUpdateWithoutRestaurantsDataInput>;
  upsert?: Maybe<SundayUpsertWithoutRestaurantsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SundayWhereUniqueInput>;
}

export interface SundayUpdateWithoutRestaurantsDataInput {
  exhausted?: Maybe<Boolean>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutSundayInput>;
  order?: Maybe<Int>;
}

export interface TimeDiscountUpdateManyWithoutSundayInput {
  create?: Maybe<
    | TimeDiscountCreateWithoutSundayInput[]
    | TimeDiscountCreateWithoutSundayInput
  >;
  delete?: Maybe<TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput>;
  connect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
  set?: Maybe<TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput>;
  disconnect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
  update?: Maybe<
    | TimeDiscountUpdateWithWhereUniqueWithoutSundayInput[]
    | TimeDiscountUpdateWithWhereUniqueWithoutSundayInput
  >;
  upsert?: Maybe<
    | TimeDiscountUpsertWithWhereUniqueWithoutSundayInput[]
    | TimeDiscountUpsertWithWhereUniqueWithoutSundayInput
  >;
  deleteMany?: Maybe<
    TimeDiscountScalarWhereInput[] | TimeDiscountScalarWhereInput
  >;
  updateMany?: Maybe<
    | TimeDiscountUpdateManyWithWhereNestedInput[]
    | TimeDiscountUpdateManyWithWhereNestedInput
  >;
}

export interface TimeDiscountUpdateWithWhereUniqueWithoutSundayInput {
  where: TimeDiscountWhereUniqueInput;
  data: TimeDiscountUpdateWithoutSundayDataInput;
}

export interface TimeDiscountUpdateWithoutSundayDataInput {
  discount?: Maybe<Float>;
  orderses?: Maybe<OrdersUpdateManyWithoutTimeDiscountInput>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutTimeDiscountsInput>;
  time?: Maybe<String>;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  friday?: Maybe<FridayUpdateOneWithoutTimeDiscountsInput>;
  monday?: Maybe<MondayUpdateOneWithoutTimeDiscountsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutTimeDiscountsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutTimeDiscountsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutTimeDiscountsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface ThursdayUpdateOneWithoutTimeDiscountsInput {
  create?: Maybe<ThursdayCreateWithoutTimeDiscountsInput>;
  update?: Maybe<ThursdayUpdateWithoutTimeDiscountsDataInput>;
  upsert?: Maybe<ThursdayUpsertWithoutTimeDiscountsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ThursdayWhereUniqueInput>;
}

export interface ThursdayUpdateWithoutTimeDiscountsDataInput {
  exhausted?: Maybe<Boolean>;
  order?: Maybe<Int>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutThursdayInput>;
}

export interface RestaurantsUpdateOneWithoutThursdayInput {
  create?: Maybe<RestaurantsCreateWithoutThursdayInput>;
  update?: Maybe<RestaurantsUpdateWithoutThursdayDataInput>;
  upsert?: Maybe<RestaurantsUpsertWithoutThursdayInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsUpdateWithoutThursdayDataInput {
  city?: Maybe<String>;
  enableLoginAccess?: Maybe<Boolean>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersUpdateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeUpdateManyWithoutRestaurantsesInput>;
  state?: Maybe<String>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsUpdateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsUpdateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsUpdaterphoneInput>;
  friday?: Maybe<FridayUpdateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayUpdateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsUpdatemenuInput>;
  brandTile?: Maybe<BrandTileUpdateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsUpdaterestaurantImagesInput>;
}

export interface TuesdayUpdateOneWithoutRestaurantsInput {
  create?: Maybe<TuesdayCreateWithoutRestaurantsInput>;
  update?: Maybe<TuesdayUpdateWithoutRestaurantsDataInput>;
  upsert?: Maybe<TuesdayUpsertWithoutRestaurantsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TuesdayWhereUniqueInput>;
}

export interface TuesdayUpdateWithoutRestaurantsDataInput {
  exhausted?: Maybe<Boolean>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutTuesdayInput>;
  order?: Maybe<Int>;
}

export interface TimeDiscountUpdateManyWithoutTuesdayInput {
  create?: Maybe<
    | TimeDiscountCreateWithoutTuesdayInput[]
    | TimeDiscountCreateWithoutTuesdayInput
  >;
  delete?: Maybe<TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput>;
  connect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
  set?: Maybe<TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput>;
  disconnect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
  update?: Maybe<
    | TimeDiscountUpdateWithWhereUniqueWithoutTuesdayInput[]
    | TimeDiscountUpdateWithWhereUniqueWithoutTuesdayInput
  >;
  upsert?: Maybe<
    | TimeDiscountUpsertWithWhereUniqueWithoutTuesdayInput[]
    | TimeDiscountUpsertWithWhereUniqueWithoutTuesdayInput
  >;
  deleteMany?: Maybe<
    TimeDiscountScalarWhereInput[] | TimeDiscountScalarWhereInput
  >;
  updateMany?: Maybe<
    | TimeDiscountUpdateManyWithWhereNestedInput[]
    | TimeDiscountUpdateManyWithWhereNestedInput
  >;
}

export interface TimeDiscountUpdateWithWhereUniqueWithoutTuesdayInput {
  where: TimeDiscountWhereUniqueInput;
  data: TimeDiscountUpdateWithoutTuesdayDataInput;
}

export interface TimeDiscountUpdateWithoutTuesdayDataInput {
  discount?: Maybe<Float>;
  orderses?: Maybe<OrdersUpdateManyWithoutTimeDiscountInput>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutTimeDiscountsInput>;
  time?: Maybe<String>;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  friday?: Maybe<FridayUpdateOneWithoutTimeDiscountsInput>;
  monday?: Maybe<MondayUpdateOneWithoutTimeDiscountsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutTimeDiscountsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutTimeDiscountsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutTimeDiscountsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface SundayUpdateOneWithoutTimeDiscountsInput {
  create?: Maybe<SundayCreateWithoutTimeDiscountsInput>;
  update?: Maybe<SundayUpdateWithoutTimeDiscountsDataInput>;
  upsert?: Maybe<SundayUpsertWithoutTimeDiscountsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SundayWhereUniqueInput>;
}

export interface SundayUpdateWithoutTimeDiscountsDataInput {
  exhausted?: Maybe<Boolean>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutSundayInput>;
  order?: Maybe<Int>;
}

export interface RestaurantsUpdateOneWithoutSundayInput {
  create?: Maybe<RestaurantsCreateWithoutSundayInput>;
  update?: Maybe<RestaurantsUpdateWithoutSundayDataInput>;
  upsert?: Maybe<RestaurantsUpsertWithoutSundayInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsUpdateWithoutSundayDataInput {
  city?: Maybe<String>;
  enableLoginAccess?: Maybe<Boolean>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersUpdateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeUpdateManyWithoutRestaurantsesInput>;
  state?: Maybe<String>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsUpdateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsUpdateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsUpdaterphoneInput>;
  friday?: Maybe<FridayUpdateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayUpdateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsUpdatemenuInput>;
  brandTile?: Maybe<BrandTileUpdateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsUpdaterestaurantImagesInput>;
}

export interface ThursdayUpdateOneWithoutRestaurantsInput {
  create?: Maybe<ThursdayCreateWithoutRestaurantsInput>;
  update?: Maybe<ThursdayUpdateWithoutRestaurantsDataInput>;
  upsert?: Maybe<ThursdayUpsertWithoutRestaurantsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ThursdayWhereUniqueInput>;
}

export interface ThursdayUpdateWithoutRestaurantsDataInput {
  exhausted?: Maybe<Boolean>;
  order?: Maybe<Int>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutThursdayInput>;
}

export interface TimeDiscountUpdateManyWithoutThursdayInput {
  create?: Maybe<
    | TimeDiscountCreateWithoutThursdayInput[]
    | TimeDiscountCreateWithoutThursdayInput
  >;
  delete?: Maybe<TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput>;
  connect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
  set?: Maybe<TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput>;
  disconnect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
  update?: Maybe<
    | TimeDiscountUpdateWithWhereUniqueWithoutThursdayInput[]
    | TimeDiscountUpdateWithWhereUniqueWithoutThursdayInput
  >;
  upsert?: Maybe<
    | TimeDiscountUpsertWithWhereUniqueWithoutThursdayInput[]
    | TimeDiscountUpsertWithWhereUniqueWithoutThursdayInput
  >;
  deleteMany?: Maybe<
    TimeDiscountScalarWhereInput[] | TimeDiscountScalarWhereInput
  >;
  updateMany?: Maybe<
    | TimeDiscountUpdateManyWithWhereNestedInput[]
    | TimeDiscountUpdateManyWithWhereNestedInput
  >;
}

export interface TimeDiscountUpdateWithWhereUniqueWithoutThursdayInput {
  where: TimeDiscountWhereUniqueInput;
  data: TimeDiscountUpdateWithoutThursdayDataInput;
}

export interface TimeDiscountUpdateWithoutThursdayDataInput {
  discount?: Maybe<Float>;
  orderses?: Maybe<OrdersUpdateManyWithoutTimeDiscountInput>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutTimeDiscountsInput>;
  time?: Maybe<String>;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  friday?: Maybe<FridayUpdateOneWithoutTimeDiscountsInput>;
  monday?: Maybe<MondayUpdateOneWithoutTimeDiscountsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutTimeDiscountsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutTimeDiscountsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutTimeDiscountsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface TuesdayUpdateOneWithoutTimeDiscountsInput {
  create?: Maybe<TuesdayCreateWithoutTimeDiscountsInput>;
  update?: Maybe<TuesdayUpdateWithoutTimeDiscountsDataInput>;
  upsert?: Maybe<TuesdayUpsertWithoutTimeDiscountsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TuesdayWhereUniqueInput>;
}

export interface TuesdayUpdateWithoutTimeDiscountsDataInput {
  exhausted?: Maybe<Boolean>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutTuesdayInput>;
  order?: Maybe<Int>;
}

export interface RestaurantsUpdateOneWithoutTuesdayInput {
  create?: Maybe<RestaurantsCreateWithoutTuesdayInput>;
  update?: Maybe<RestaurantsUpdateWithoutTuesdayDataInput>;
  upsert?: Maybe<RestaurantsUpsertWithoutTuesdayInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsUpdateWithoutTuesdayDataInput {
  city?: Maybe<String>;
  enableLoginAccess?: Maybe<Boolean>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersUpdateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeUpdateManyWithoutRestaurantsesInput>;
  state?: Maybe<String>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsUpdateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsUpdateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsUpdaterphoneInput>;
  friday?: Maybe<FridayUpdateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayUpdateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsUpdatemenuInput>;
  brandTile?: Maybe<BrandTileUpdateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsUpdaterestaurantImagesInput>;
}

export interface WednesdayUpdateOneWithoutRestaurantsInput {
  create?: Maybe<WednesdayCreateWithoutRestaurantsInput>;
  update?: Maybe<WednesdayUpdateWithoutRestaurantsDataInput>;
  upsert?: Maybe<WednesdayUpsertWithoutRestaurantsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<WednesdayWhereUniqueInput>;
}

export interface WednesdayUpdateWithoutRestaurantsDataInput {
  exhausted?: Maybe<Boolean>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutWednesdayInput>;
  order?: Maybe<Int>;
}

export interface TimeDiscountUpdateManyWithoutWednesdayInput {
  create?: Maybe<
    | TimeDiscountCreateWithoutWednesdayInput[]
    | TimeDiscountCreateWithoutWednesdayInput
  >;
  delete?: Maybe<TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput>;
  connect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
  set?: Maybe<TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput>;
  disconnect?: Maybe<
    TimeDiscountWhereUniqueInput[] | TimeDiscountWhereUniqueInput
  >;
  update?: Maybe<
    | TimeDiscountUpdateWithWhereUniqueWithoutWednesdayInput[]
    | TimeDiscountUpdateWithWhereUniqueWithoutWednesdayInput
  >;
  upsert?: Maybe<
    | TimeDiscountUpsertWithWhereUniqueWithoutWednesdayInput[]
    | TimeDiscountUpsertWithWhereUniqueWithoutWednesdayInput
  >;
  deleteMany?: Maybe<
    TimeDiscountScalarWhereInput[] | TimeDiscountScalarWhereInput
  >;
  updateMany?: Maybe<
    | TimeDiscountUpdateManyWithWhereNestedInput[]
    | TimeDiscountUpdateManyWithWhereNestedInput
  >;
}

export interface TimeDiscountUpdateWithWhereUniqueWithoutWednesdayInput {
  where: TimeDiscountWhereUniqueInput;
  data: TimeDiscountUpdateWithoutWednesdayDataInput;
}

export interface TimeDiscountUpdateWithoutWednesdayDataInput {
  discount?: Maybe<Float>;
  orderses?: Maybe<OrdersUpdateManyWithoutTimeDiscountInput>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutTimeDiscountsInput>;
  time?: Maybe<String>;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  friday?: Maybe<FridayUpdateOneWithoutTimeDiscountsInput>;
  monday?: Maybe<MondayUpdateOneWithoutTimeDiscountsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutTimeDiscountsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutTimeDiscountsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutTimeDiscountsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface TimeDiscountUpsertWithWhereUniqueWithoutWednesdayInput {
  where: TimeDiscountWhereUniqueInput;
  update: TimeDiscountUpdateWithoutWednesdayDataInput;
  create: TimeDiscountCreateWithoutWednesdayInput;
}

export interface TimeDiscountScalarWhereInput {
  discount?: Maybe<Float>;
  discount_not?: Maybe<Float>;
  discount_in?: Maybe<Float[] | Float>;
  discount_not_in?: Maybe<Float[] | Float>;
  discount_lt?: Maybe<Float>;
  discount_lte?: Maybe<Float>;
  discount_gt?: Maybe<Float>;
  discount_gte?: Maybe<Float>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  time?: Maybe<String>;
  time_not?: Maybe<String>;
  time_in?: Maybe<String[] | String>;
  time_not_in?: Maybe<String[] | String>;
  time_lt?: Maybe<String>;
  time_lte?: Maybe<String>;
  time_gt?: Maybe<String>;
  time_gte?: Maybe<String>;
  time_contains?: Maybe<String>;
  time_not_contains?: Maybe<String>;
  time_starts_with?: Maybe<String>;
  time_not_starts_with?: Maybe<String>;
  time_ends_with?: Maybe<String>;
  time_not_ends_with?: Maybe<String>;
  daychange?: Maybe<Boolean>;
  daychange_not?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  day_not?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newtime_not?: Maybe<String>;
  newtime_in?: Maybe<String[] | String>;
  newtime_not_in?: Maybe<String[] | String>;
  newtime_lt?: Maybe<String>;
  newtime_lte?: Maybe<String>;
  newtime_gt?: Maybe<String>;
  newtime_gte?: Maybe<String>;
  newtime_contains?: Maybe<String>;
  newtime_not_contains?: Maybe<String>;
  newtime_starts_with?: Maybe<String>;
  newtime_not_starts_with?: Maybe<String>;
  newtime_ends_with?: Maybe<String>;
  newtime_not_ends_with?: Maybe<String>;
  newdiscount?: Maybe<String>;
  newdiscount_not?: Maybe<String>;
  newdiscount_in?: Maybe<String[] | String>;
  newdiscount_not_in?: Maybe<String[] | String>;
  newdiscount_lt?: Maybe<String>;
  newdiscount_lte?: Maybe<String>;
  newdiscount_gt?: Maybe<String>;
  newdiscount_gte?: Maybe<String>;
  newdiscount_contains?: Maybe<String>;
  newdiscount_not_contains?: Maybe<String>;
  newdiscount_starts_with?: Maybe<String>;
  newdiscount_not_starts_with?: Maybe<String>;
  newdiscount_ends_with?: Maybe<String>;
  newdiscount_not_ends_with?: Maybe<String>;
  exhausted?: Maybe<Boolean>;
  exhausted_not?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  tueExhaust_not?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  monExhaust_not?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  wedExhaust_not?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  thuExhaust_not?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  friExhaust_not?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  satExhaust_not?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  sunExhaust_not?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  monDiscount_not?: Maybe<Float>;
  monDiscount_in?: Maybe<Float[] | Float>;
  monDiscount_not_in?: Maybe<Float[] | Float>;
  monDiscount_lt?: Maybe<Float>;
  monDiscount_lte?: Maybe<Float>;
  monDiscount_gt?: Maybe<Float>;
  monDiscount_gte?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  tueDiscount_not?: Maybe<Float>;
  tueDiscount_in?: Maybe<Float[] | Float>;
  tueDiscount_not_in?: Maybe<Float[] | Float>;
  tueDiscount_lt?: Maybe<Float>;
  tueDiscount_lte?: Maybe<Float>;
  tueDiscount_gt?: Maybe<Float>;
  tueDiscount_gte?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  wedDiscount_not?: Maybe<Float>;
  wedDiscount_in?: Maybe<Float[] | Float>;
  wedDiscount_not_in?: Maybe<Float[] | Float>;
  wedDiscount_lt?: Maybe<Float>;
  wedDiscount_lte?: Maybe<Float>;
  wedDiscount_gt?: Maybe<Float>;
  wedDiscount_gte?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  thuDiscount_not?: Maybe<Float>;
  thuDiscount_in?: Maybe<Float[] | Float>;
  thuDiscount_not_in?: Maybe<Float[] | Float>;
  thuDiscount_lt?: Maybe<Float>;
  thuDiscount_lte?: Maybe<Float>;
  thuDiscount_gt?: Maybe<Float>;
  thuDiscount_gte?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  friDiscount_not?: Maybe<Float>;
  friDiscount_in?: Maybe<Float[] | Float>;
  friDiscount_not_in?: Maybe<Float[] | Float>;
  friDiscount_lt?: Maybe<Float>;
  friDiscount_lte?: Maybe<Float>;
  friDiscount_gt?: Maybe<Float>;
  friDiscount_gte?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  satDiscount_not?: Maybe<Float>;
  satDiscount_in?: Maybe<Float[] | Float>;
  satDiscount_not_in?: Maybe<Float[] | Float>;
  satDiscount_lt?: Maybe<Float>;
  satDiscount_lte?: Maybe<Float>;
  satDiscount_gt?: Maybe<Float>;
  satDiscount_gte?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
  sunDiscount_not?: Maybe<Float>;
  sunDiscount_in?: Maybe<Float[] | Float>;
  sunDiscount_not_in?: Maybe<Float[] | Float>;
  sunDiscount_lt?: Maybe<Float>;
  sunDiscount_lte?: Maybe<Float>;
  sunDiscount_gt?: Maybe<Float>;
  sunDiscount_gte?: Maybe<Float>;
  AND?: Maybe<TimeDiscountScalarWhereInput[] | TimeDiscountScalarWhereInput>;
  OR?: Maybe<TimeDiscountScalarWhereInput[] | TimeDiscountScalarWhereInput>;
  NOT?: Maybe<TimeDiscountScalarWhereInput[] | TimeDiscountScalarWhereInput>;
}

export interface TimeDiscountUpdateManyWithWhereNestedInput {
  where: TimeDiscountScalarWhereInput;
  data: TimeDiscountUpdateManyDataInput;
}

export interface TimeDiscountUpdateManyDataInput {
  discount?: Maybe<Float>;
  time?: Maybe<String>;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface WednesdayUpsertWithoutRestaurantsInput {
  update: WednesdayUpdateWithoutRestaurantsDataInput;
  create: WednesdayCreateWithoutRestaurantsInput;
}

export interface RestaurantsUpdatemenuInput {
  set?: Maybe<Json[] | Json>;
}

export interface BrandTileUpdateOneWithoutRestaurantsesInput {
  create?: Maybe<BrandTileCreateWithoutRestaurantsesInput>;
  update?: Maybe<BrandTileUpdateWithoutRestaurantsesDataInput>;
  upsert?: Maybe<BrandTileUpsertWithoutRestaurantsesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BrandTileWhereUniqueInput>;
}

export interface BrandTileUpdateWithoutRestaurantsesDataInput {
  type?: Maybe<String>;
  imageurl?: Maybe<String>;
  order?: Maybe<Int>;
  brandTileName?: Maybe<String>;
}

export interface BrandTileUpsertWithoutRestaurantsesInput {
  update: BrandTileUpdateWithoutRestaurantsesDataInput;
  create: BrandTileCreateWithoutRestaurantsesInput;
}

export interface RestaurantsUpdaterestaurantImagesInput {
  set?: Maybe<String[] | String>;
}

export interface RestaurantsUpsertWithoutTuesdayInput {
  update: RestaurantsUpdateWithoutTuesdayDataInput;
  create: RestaurantsCreateWithoutTuesdayInput;
}

export interface TuesdayUpsertWithoutTimeDiscountsInput {
  update: TuesdayUpdateWithoutTimeDiscountsDataInput;
  create: TuesdayCreateWithoutTimeDiscountsInput;
}

export interface WednesdayUpdateOneWithoutTimeDiscountsInput {
  create?: Maybe<WednesdayCreateWithoutTimeDiscountsInput>;
  update?: Maybe<WednesdayUpdateWithoutTimeDiscountsDataInput>;
  upsert?: Maybe<WednesdayUpsertWithoutTimeDiscountsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<WednesdayWhereUniqueInput>;
}

export interface WednesdayUpdateWithoutTimeDiscountsDataInput {
  exhausted?: Maybe<Boolean>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutWednesdayInput>;
  order?: Maybe<Int>;
}

export interface RestaurantsUpdateOneWithoutWednesdayInput {
  create?: Maybe<RestaurantsCreateWithoutWednesdayInput>;
  update?: Maybe<RestaurantsUpdateWithoutWednesdayDataInput>;
  upsert?: Maybe<RestaurantsUpsertWithoutWednesdayInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<RestaurantsWhereUniqueInput>;
}

export interface RestaurantsUpdateWithoutWednesdayDataInput {
  city?: Maybe<String>;
  enableLoginAccess?: Maybe<Boolean>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersUpdateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeUpdateManyWithoutRestaurantsesInput>;
  state?: Maybe<String>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsUpdateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsUpdateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsUpdaterphoneInput>;
  friday?: Maybe<FridayUpdateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayUpdateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsUpdatemenuInput>;
  brandTile?: Maybe<BrandTileUpdateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsUpdaterestaurantImagesInput>;
}

export interface RestaurantsUpsertWithoutWednesdayInput {
  update: RestaurantsUpdateWithoutWednesdayDataInput;
  create: RestaurantsCreateWithoutWednesdayInput;
}

export interface WednesdayUpsertWithoutTimeDiscountsInput {
  update: WednesdayUpdateWithoutTimeDiscountsDataInput;
  create: WednesdayCreateWithoutTimeDiscountsInput;
}

export interface TimeDiscountUpsertWithWhereUniqueWithoutThursdayInput {
  where: TimeDiscountWhereUniqueInput;
  update: TimeDiscountUpdateWithoutThursdayDataInput;
  create: TimeDiscountCreateWithoutThursdayInput;
}

export interface ThursdayUpsertWithoutRestaurantsInput {
  update: ThursdayUpdateWithoutRestaurantsDataInput;
  create: ThursdayCreateWithoutRestaurantsInput;
}

export interface RestaurantsUpsertWithoutSundayInput {
  update: RestaurantsUpdateWithoutSundayDataInput;
  create: RestaurantsCreateWithoutSundayInput;
}

export interface SundayUpsertWithoutTimeDiscountsInput {
  update: SundayUpdateWithoutTimeDiscountsDataInput;
  create: SundayCreateWithoutTimeDiscountsInput;
}

export interface TimeDiscountUpsertWithWhereUniqueWithoutTuesdayInput {
  where: TimeDiscountWhereUniqueInput;
  update: TimeDiscountUpdateWithoutTuesdayDataInput;
  create: TimeDiscountCreateWithoutTuesdayInput;
}

export interface TuesdayUpsertWithoutRestaurantsInput {
  update: TuesdayUpdateWithoutRestaurantsDataInput;
  create: TuesdayCreateWithoutRestaurantsInput;
}

export interface RestaurantsUpsertWithoutThursdayInput {
  update: RestaurantsUpdateWithoutThursdayDataInput;
  create: RestaurantsCreateWithoutThursdayInput;
}

export interface ThursdayUpsertWithoutTimeDiscountsInput {
  update: ThursdayUpdateWithoutTimeDiscountsDataInput;
  create: ThursdayCreateWithoutTimeDiscountsInput;
}

export interface TimeDiscountUpsertWithWhereUniqueWithoutSundayInput {
  where: TimeDiscountWhereUniqueInput;
  update: TimeDiscountUpdateWithoutSundayDataInput;
  create: TimeDiscountCreateWithoutSundayInput;
}

export interface SundayUpsertWithoutRestaurantsInput {
  update: SundayUpdateWithoutRestaurantsDataInput;
  create: SundayCreateWithoutRestaurantsInput;
}

export interface RestaurantsUpsertWithoutSaturdayInput {
  update: RestaurantsUpdateWithoutSaturdayDataInput;
  create: RestaurantsCreateWithoutSaturdayInput;
}

export interface SaturdayUpsertWithoutTimeDiscountsInput {
  update: SaturdayUpdateWithoutTimeDiscountsDataInput;
  create: SaturdayCreateWithoutTimeDiscountsInput;
}

export interface TimeDiscountUpsertWithWhereUniqueWithoutMondayInput {
  where: TimeDiscountWhereUniqueInput;
  update: TimeDiscountUpdateWithoutMondayDataInput;
  create: TimeDiscountCreateWithoutMondayInput;
}

export interface MondayUpsertWithoutRestaurantsInput {
  update: MondayUpdateWithoutRestaurantsDataInput;
  create: MondayCreateWithoutRestaurantsInput;
}

export interface RestaurantsUpsertWithoutFridayInput {
  update: RestaurantsUpdateWithoutFridayDataInput;
  create: RestaurantsCreateWithoutFridayInput;
}

export interface FridayUpsertWithoutTimeDiscountsInput {
  update: FridayUpdateWithoutTimeDiscountsDataInput;
  create: FridayCreateWithoutTimeDiscountsInput;
}

export interface TimeDiscountUpsertWithWhereUniqueWithoutSaturdayInput {
  where: TimeDiscountWhereUniqueInput;
  update: TimeDiscountUpdateWithoutSaturdayDataInput;
  create: TimeDiscountCreateWithoutSaturdayInput;
}

export interface SaturdayUpsertWithoutRestaurantsInput {
  update: SaturdayUpdateWithoutRestaurantsDataInput;
  create: SaturdayCreateWithoutRestaurantsInput;
}

export interface RestaurantsUpsertWithoutMondayInput {
  update: RestaurantsUpdateWithoutMondayDataInput;
  create: RestaurantsCreateWithoutMondayInput;
}

export interface MondayUpsertWithoutTimeDiscountsInput {
  update: MondayUpdateWithoutTimeDiscountsDataInput;
  create: MondayCreateWithoutTimeDiscountsInput;
}

export interface TimeDiscountUpsertWithWhereUniqueWithoutFridayInput {
  where: TimeDiscountWhereUniqueInput;
  update: TimeDiscountUpdateWithoutFridayDataInput;
  create: TimeDiscountCreateWithoutFridayInput;
}

export interface FridayUpsertWithoutRestaurantsInput {
  update: FridayUpdateWithoutRestaurantsDataInput;
  create: FridayCreateWithoutRestaurantsInput;
}

export interface RestaurantsUpsertWithoutUserReviewsesInput {
  update: RestaurantsUpdateWithoutUserReviewsesDataInput;
  create: RestaurantsCreateWithoutUserReviewsesInput;
}

export interface UserReviewsUpsertWithWhereUniqueWithoutUserInput {
  where: UserReviewsWhereUniqueInput;
  update: UserReviewsUpdateWithoutUserDataInput;
  create: UserReviewsCreateWithoutUserInput;
}

export interface UserReviewsScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  review?: Maybe<String>;
  review_not?: Maybe<String>;
  review_in?: Maybe<String[] | String>;
  review_not_in?: Maybe<String[] | String>;
  review_lt?: Maybe<String>;
  review_lte?: Maybe<String>;
  review_gt?: Maybe<String>;
  review_gte?: Maybe<String>;
  review_contains?: Maybe<String>;
  review_not_contains?: Maybe<String>;
  review_starts_with?: Maybe<String>;
  review_not_starts_with?: Maybe<String>;
  review_ends_with?: Maybe<String>;
  review_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  rating?: Maybe<Int>;
  rating_not?: Maybe<Int>;
  rating_in?: Maybe<Int[] | Int>;
  rating_not_in?: Maybe<Int[] | Int>;
  rating_lt?: Maybe<Int>;
  rating_lte?: Maybe<Int>;
  rating_gt?: Maybe<Int>;
  rating_gte?: Maybe<Int>;
  AND?: Maybe<UserReviewsScalarWhereInput[] | UserReviewsScalarWhereInput>;
  OR?: Maybe<UserReviewsScalarWhereInput[] | UserReviewsScalarWhereInput>;
  NOT?: Maybe<UserReviewsScalarWhereInput[] | UserReviewsScalarWhereInput>;
}

export interface UserReviewsUpdateManyWithWhereNestedInput {
  where: UserReviewsScalarWhereInput;
  data: UserReviewsUpdateManyDataInput;
}

export interface UserReviewsUpdateManyDataInput {
  review?: Maybe<String>;
  rating?: Maybe<Int>;
}

export interface UserUpsertWithoutOrdersesInput {
  update: UserUpdateWithoutOrdersesDataInput;
  create: UserCreateWithoutOrdersesInput;
}

export interface OrdersUpsertWithWhereUniqueWithoutTimeDiscountInput {
  where: OrdersWhereUniqueInput;
  update: OrdersUpdateWithoutTimeDiscountDataInput;
  create: OrdersCreateWithoutTimeDiscountInput;
}

export interface OrdersScalarWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  date?: Maybe<String>;
  date_not?: Maybe<String>;
  date_in?: Maybe<String[] | String>;
  date_not_in?: Maybe<String[] | String>;
  date_lt?: Maybe<String>;
  date_lte?: Maybe<String>;
  date_gt?: Maybe<String>;
  date_gte?: Maybe<String>;
  date_contains?: Maybe<String>;
  date_not_contains?: Maybe<String>;
  date_starts_with?: Maybe<String>;
  date_not_starts_with?: Maybe<String>;
  date_ends_with?: Maybe<String>;
  date_not_ends_with?: Maybe<String>;
  totalDiscount?: Maybe<Int>;
  totalDiscount_not?: Maybe<Int>;
  totalDiscount_in?: Maybe<Int[] | Int>;
  totalDiscount_not_in?: Maybe<Int[] | Int>;
  totalDiscount_lt?: Maybe<Int>;
  totalDiscount_lte?: Maybe<Int>;
  totalDiscount_gt?: Maybe<Int>;
  totalDiscount_gte?: Maybe<Int>;
  people?: Maybe<Int>;
  people_not?: Maybe<Int>;
  people_in?: Maybe<Int[] | Int>;
  people_not_in?: Maybe<Int[] | Int>;
  people_lt?: Maybe<Int>;
  people_lte?: Maybe<Int>;
  people_gt?: Maybe<Int>;
  people_gte?: Maybe<Int>;
  bookingid?: Maybe<String>;
  bookingid_not?: Maybe<String>;
  bookingid_in?: Maybe<String[] | String>;
  bookingid_not_in?: Maybe<String[] | String>;
  bookingid_lt?: Maybe<String>;
  bookingid_lte?: Maybe<String>;
  bookingid_gt?: Maybe<String>;
  bookingid_gte?: Maybe<String>;
  bookingid_contains?: Maybe<String>;
  bookingid_not_contains?: Maybe<String>;
  bookingid_starts_with?: Maybe<String>;
  bookingid_not_starts_with?: Maybe<String>;
  bookingid_ends_with?: Maybe<String>;
  bookingid_not_ends_with?: Maybe<String>;
  mobile?: Maybe<String>;
  mobile_not?: Maybe<String>;
  mobile_in?: Maybe<String[] | String>;
  mobile_not_in?: Maybe<String[] | String>;
  mobile_lt?: Maybe<String>;
  mobile_lte?: Maybe<String>;
  mobile_gt?: Maybe<String>;
  mobile_gte?: Maybe<String>;
  mobile_contains?: Maybe<String>;
  mobile_not_contains?: Maybe<String>;
  mobile_starts_with?: Maybe<String>;
  mobile_not_starts_with?: Maybe<String>;
  mobile_ends_with?: Maybe<String>;
  mobile_not_ends_with?: Maybe<String>;
  unlockActive?: Maybe<Boolean>;
  unlockActive_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  geolocation?: Maybe<String>;
  geolocation_not?: Maybe<String>;
  geolocation_in?: Maybe<String[] | String>;
  geolocation_not_in?: Maybe<String[] | String>;
  geolocation_lt?: Maybe<String>;
  geolocation_lte?: Maybe<String>;
  geolocation_gt?: Maybe<String>;
  geolocation_gte?: Maybe<String>;
  geolocation_contains?: Maybe<String>;
  geolocation_not_contains?: Maybe<String>;
  geolocation_starts_with?: Maybe<String>;
  geolocation_not_starts_with?: Maybe<String>;
  geolocation_ends_with?: Maybe<String>;
  geolocation_not_ends_with?: Maybe<String>;
  referrer?: Maybe<String>;
  referrer_not?: Maybe<String>;
  referrer_in?: Maybe<String[] | String>;
  referrer_not_in?: Maybe<String[] | String>;
  referrer_lt?: Maybe<String>;
  referrer_lte?: Maybe<String>;
  referrer_gt?: Maybe<String>;
  referrer_gte?: Maybe<String>;
  referrer_contains?: Maybe<String>;
  referrer_not_contains?: Maybe<String>;
  referrer_starts_with?: Maybe<String>;
  referrer_not_starts_with?: Maybe<String>;
  referrer_ends_with?: Maybe<String>;
  referrer_not_ends_with?: Maybe<String>;
  confirmed?: Maybe<Boolean>;
  confirmed_not?: Maybe<Boolean>;
  cancelled?: Maybe<Boolean>;
  cancelled_not?: Maybe<Boolean>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  receipt?: Maybe<String>;
  receipt_not?: Maybe<String>;
  receipt_in?: Maybe<String[] | String>;
  receipt_not_in?: Maybe<String[] | String>;
  receipt_lt?: Maybe<String>;
  receipt_lte?: Maybe<String>;
  receipt_gt?: Maybe<String>;
  receipt_gte?: Maybe<String>;
  receipt_contains?: Maybe<String>;
  receipt_not_contains?: Maybe<String>;
  receipt_starts_with?: Maybe<String>;
  receipt_not_starts_with?: Maybe<String>;
  receipt_ends_with?: Maybe<String>;
  receipt_not_ends_with?: Maybe<String>;
  paymentId?: Maybe<String>;
  paymentId_not?: Maybe<String>;
  paymentId_in?: Maybe<String[] | String>;
  paymentId_not_in?: Maybe<String[] | String>;
  paymentId_lt?: Maybe<String>;
  paymentId_lte?: Maybe<String>;
  paymentId_gt?: Maybe<String>;
  paymentId_gte?: Maybe<String>;
  paymentId_contains?: Maybe<String>;
  paymentId_not_contains?: Maybe<String>;
  paymentId_starts_with?: Maybe<String>;
  paymentId_not_starts_with?: Maybe<String>;
  paymentId_ends_with?: Maybe<String>;
  paymentId_not_ends_with?: Maybe<String>;
  paymentOrderId?: Maybe<String>;
  paymentOrderId_not?: Maybe<String>;
  paymentOrderId_in?: Maybe<String[] | String>;
  paymentOrderId_not_in?: Maybe<String[] | String>;
  paymentOrderId_lt?: Maybe<String>;
  paymentOrderId_lte?: Maybe<String>;
  paymentOrderId_gt?: Maybe<String>;
  paymentOrderId_gte?: Maybe<String>;
  paymentOrderId_contains?: Maybe<String>;
  paymentOrderId_not_contains?: Maybe<String>;
  paymentOrderId_starts_with?: Maybe<String>;
  paymentOrderId_not_starts_with?: Maybe<String>;
  paymentOrderId_ends_with?: Maybe<String>;
  paymentOrderId_not_ends_with?: Maybe<String>;
  paymentDescription?: Maybe<String>;
  paymentDescription_not?: Maybe<String>;
  paymentDescription_in?: Maybe<String[] | String>;
  paymentDescription_not_in?: Maybe<String[] | String>;
  paymentDescription_lt?: Maybe<String>;
  paymentDescription_lte?: Maybe<String>;
  paymentDescription_gt?: Maybe<String>;
  paymentDescription_gte?: Maybe<String>;
  paymentDescription_contains?: Maybe<String>;
  paymentDescription_not_contains?: Maybe<String>;
  paymentDescription_starts_with?: Maybe<String>;
  paymentDescription_not_starts_with?: Maybe<String>;
  paymentDescription_ends_with?: Maybe<String>;
  paymentDescription_not_ends_with?: Maybe<String>;
  AND?: Maybe<OrdersScalarWhereInput[] | OrdersScalarWhereInput>;
  OR?: Maybe<OrdersScalarWhereInput[] | OrdersScalarWhereInput>;
  NOT?: Maybe<OrdersScalarWhereInput[] | OrdersScalarWhereInput>;
}

export interface OrdersUpdateManyWithWhereNestedInput {
  where: OrdersScalarWhereInput;
  data: OrdersUpdateManyDataInput;
}

export interface OrdersUpdateManyDataInput {
  date?: Maybe<String>;
  totalDiscount?: Maybe<Int>;
  people?: Maybe<Int>;
  bookingid?: Maybe<String>;
  mobile?: Maybe<String>;
  unlockActive?: Maybe<Boolean>;
  name?: Maybe<String>;
  geolocation?: Maybe<String>;
  referrer?: Maybe<String>;
  confirmed?: Maybe<Boolean>;
  cancelled?: Maybe<Boolean>;
  amount?: Maybe<Int>;
  receipt?: Maybe<String>;
  paymentId?: Maybe<String>;
  paymentOrderId?: Maybe<String>;
  paymentDescription?: Maybe<String>;
}

export interface TimeDiscountUpsertWithWhereUniqueWithoutRestaurantsInput {
  where: TimeDiscountWhereUniqueInput;
  update: TimeDiscountUpdateWithoutRestaurantsDataInput;
  create: TimeDiscountCreateWithoutRestaurantsInput;
}

export interface RestaurantsUpsertWithoutOrdersesInput {
  update: RestaurantsUpdateWithoutOrdersesDataInput;
  create: RestaurantsCreateWithoutOrdersesInput;
}

export interface OrdersUpsertWithWhereUniqueWithoutUserInput {
  where: OrdersWhereUniqueInput;
  update: OrdersUpdateWithoutUserDataInput;
  create: OrdersCreateWithoutUserInput;
}

export interface UserUpsertWithoutUserReviewsesInput {
  update: UserUpdateWithoutUserReviewsesDataInput;
  create: UserCreateWithoutUserReviewsesInput;
}

export interface UserReviewsUpsertWithWhereUniqueWithoutRestaurantsInput {
  where: UserReviewsWhereUniqueInput;
  update: UserReviewsUpdateWithoutRestaurantsDataInput;
  create: UserReviewsCreateWithoutRestaurantsInput;
}

export interface RestaurantsUpsertWithoutTimeDiscountsInput {
  update: RestaurantsUpdateWithoutTimeDiscountsDataInput;
  create: RestaurantsCreateWithoutTimeDiscountsInput;
}

export interface TimeDiscountUpsertWithoutOrdersesInput {
  update: TimeDiscountUpdateWithoutOrdersesDataInput;
  create: TimeDiscountCreateWithoutOrdersesInput;
}

export interface OrdersUpsertWithWhereUniqueWithoutRestaurantsInput {
  where: OrdersWhereUniqueInput;
  update: OrdersUpdateWithoutRestaurantsDataInput;
  create: OrdersCreateWithoutRestaurantsInput;
}

export interface RestaurantsUpsertWithWhereUniqueWithoutBrandTileInput {
  where: RestaurantsWhereUniqueInput;
  update: RestaurantsUpdateWithoutBrandTileDataInput;
  create: RestaurantsCreateWithoutBrandTileInput;
}

export interface RestaurantsScalarWhereInput {
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  enableLoginAccess?: Maybe<Boolean>;
  enableLoginAccess_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  rating?: Maybe<Float>;
  rating_not?: Maybe<Float>;
  rating_in?: Maybe<Float[] | Float>;
  rating_not_in?: Maybe<Float[] | Float>;
  rating_lt?: Maybe<Float>;
  rating_lte?: Maybe<Float>;
  rating_gt?: Maybe<Float>;
  rating_gte?: Maybe<Float>;
  imageurl?: Maybe<String>;
  imageurl_not?: Maybe<String>;
  imageurl_in?: Maybe<String[] | String>;
  imageurl_not_in?: Maybe<String[] | String>;
  imageurl_lt?: Maybe<String>;
  imageurl_lte?: Maybe<String>;
  imageurl_gt?: Maybe<String>;
  imageurl_gte?: Maybe<String>;
  imageurl_contains?: Maybe<String>;
  imageurl_not_contains?: Maybe<String>;
  imageurl_starts_with?: Maybe<String>;
  imageurl_not_starts_with?: Maybe<String>;
  imageurl_ends_with?: Maybe<String>;
  imageurl_not_ends_with?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  googlemapsurl_not?: Maybe<String>;
  googlemapsurl_in?: Maybe<String[] | String>;
  googlemapsurl_not_in?: Maybe<String[] | String>;
  googlemapsurl_lt?: Maybe<String>;
  googlemapsurl_lte?: Maybe<String>;
  googlemapsurl_gt?: Maybe<String>;
  googlemapsurl_gte?: Maybe<String>;
  googlemapsurl_contains?: Maybe<String>;
  googlemapsurl_not_contains?: Maybe<String>;
  googlemapsurl_starts_with?: Maybe<String>;
  googlemapsurl_not_starts_with?: Maybe<String>;
  googlemapsurl_ends_with?: Maybe<String>;
  googlemapsurl_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  about?: Maybe<String>;
  about_not?: Maybe<String>;
  about_in?: Maybe<String[] | String>;
  about_not_in?: Maybe<String[] | String>;
  about_lt?: Maybe<String>;
  about_lte?: Maybe<String>;
  about_gt?: Maybe<String>;
  about_gte?: Maybe<String>;
  about_contains?: Maybe<String>;
  about_not_contains?: Maybe<String>;
  about_starts_with?: Maybe<String>;
  about_not_starts_with?: Maybe<String>;
  about_ends_with?: Maybe<String>;
  about_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  conditions?: Maybe<String>;
  conditions_not?: Maybe<String>;
  conditions_in?: Maybe<String[] | String>;
  conditions_not_in?: Maybe<String[] | String>;
  conditions_lt?: Maybe<String>;
  conditions_lte?: Maybe<String>;
  conditions_gt?: Maybe<String>;
  conditions_gte?: Maybe<String>;
  conditions_contains?: Maybe<String>;
  conditions_not_contains?: Maybe<String>;
  conditions_starts_with?: Maybe<String>;
  conditions_not_starts_with?: Maybe<String>;
  conditions_ends_with?: Maybe<String>;
  conditions_not_ends_with?: Maybe<String>;
  remail?: Maybe<String>;
  remail_not?: Maybe<String>;
  remail_in?: Maybe<String[] | String>;
  remail_not_in?: Maybe<String[] | String>;
  remail_lt?: Maybe<String>;
  remail_lte?: Maybe<String>;
  remail_gt?: Maybe<String>;
  remail_gte?: Maybe<String>;
  remail_contains?: Maybe<String>;
  remail_not_contains?: Maybe<String>;
  remail_starts_with?: Maybe<String>;
  remail_not_starts_with?: Maybe<String>;
  remail_ends_with?: Maybe<String>;
  remail_not_ends_with?: Maybe<String>;
  latitude?: Maybe<Float>;
  latitude_not?: Maybe<Float>;
  latitude_in?: Maybe<Float[] | Float>;
  latitude_not_in?: Maybe<Float[] | Float>;
  latitude_lt?: Maybe<Float>;
  latitude_lte?: Maybe<Float>;
  latitude_gt?: Maybe<Float>;
  latitude_gte?: Maybe<Float>;
  longitude?: Maybe<Float>;
  longitude_not?: Maybe<Float>;
  longitude_in?: Maybe<Float[] | Float>;
  longitude_not_in?: Maybe<Float[] | Float>;
  longitude_lt?: Maybe<Float>;
  longitude_lte?: Maybe<Float>;
  longitude_gt?: Maybe<Float>;
  longitude_gte?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  acceptsRenoPay_not?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  renoCommision_not?: Maybe<Int>;
  renoCommision_in?: Maybe<Int[] | Int>;
  renoCommision_not_in?: Maybe<Int[] | Int>;
  renoCommision_lt?: Maybe<Int>;
  renoCommision_lte?: Maybe<Int>;
  renoCommision_gt?: Maybe<Int>;
  renoCommision_gte?: Maybe<Int>;
  AND?: Maybe<RestaurantsScalarWhereInput[] | RestaurantsScalarWhereInput>;
  OR?: Maybe<RestaurantsScalarWhereInput[] | RestaurantsScalarWhereInput>;
  NOT?: Maybe<RestaurantsScalarWhereInput[] | RestaurantsScalarWhereInput>;
}

export interface RestaurantsUpdateManyWithWhereNestedInput {
  where: RestaurantsScalarWhereInput;
  data: RestaurantsUpdateManyDataInput;
}

export interface RestaurantsUpdateManyDataInput {
  city?: Maybe<String>;
  enableLoginAccess?: Maybe<Boolean>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  state?: Maybe<String>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsUpdaterphoneInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsUpdatemenuInput>;
  restaurantImages?: Maybe<RestaurantsUpdaterestaurantImagesInput>;
}

export interface BrandTileUpdateManyMutationInput {
  type?: Maybe<String>;
  imageurl?: Maybe<String>;
  order?: Maybe<Int>;
  brandTileName?: Maybe<String>;
}

export interface ContactsCreateInput {
  id?: Maybe<ID_Input>;
  phoneNumber?: Maybe<String>;
  name?: Maybe<String>;
  address?: Maybe<String>;
  email?: Maybe<String>;
}

export interface ContactsUpdateInput {
  phoneNumber?: Maybe<String>;
  name?: Maybe<String>;
  address?: Maybe<String>;
  email?: Maybe<String>;
}

export interface ContactsUpdateManyMutationInput {
  phoneNumber?: Maybe<String>;
  name?: Maybe<String>;
  address?: Maybe<String>;
  email?: Maybe<String>;
}

export interface FileCreateInput {
  contentType: String;
  id?: Maybe<ID_Input>;
  name: String;
  secret: String;
  size: Int;
  url: String;
}

export interface FileUpdateInput {
  contentType?: Maybe<String>;
  name?: Maybe<String>;
  secret?: Maybe<String>;
  size?: Maybe<Int>;
  url?: Maybe<String>;
}

export interface FileUpdateManyMutationInput {
  contentType?: Maybe<String>;
  name?: Maybe<String>;
  secret?: Maybe<String>;
  size?: Maybe<Int>;
  url?: Maybe<String>;
}

export interface FridayCreateInput {
  exhausted?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutFridayInput>;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutFridayInput>;
  order?: Maybe<Int>;
}

export interface FridayUpdateInput {
  exhausted?: Maybe<Boolean>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutFridayInput>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutFridayInput>;
  order?: Maybe<Int>;
}

export interface FridayUpdateManyMutationInput {
  exhausted?: Maybe<Boolean>;
  order?: Maybe<Int>;
}

export interface HotDealsCreateInput {
  id?: Maybe<ID_Input>;
  type: String;
  restaurantses?: Maybe<RestaurantsCreateManyWithoutHotDealsesInput>;
  imageurl?: Maybe<String>;
}

export interface RestaurantsCreateManyWithoutHotDealsesInput {
  create?: Maybe<
    | RestaurantsCreateWithoutHotDealsesInput[]
    | RestaurantsCreateWithoutHotDealsesInput
  >;
  connect?: Maybe<RestaurantsWhereUniqueInput[] | RestaurantsWhereUniqueInput>;
}

export interface RestaurantsCreateWithoutHotDealsesInput {
  city: String;
  id?: Maybe<ID_Input>;
  enableLoginAccess?: Maybe<Boolean>;
  name: String;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersCreateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeCreateManyWithoutRestaurantsesInput>;
  state: String;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsCreateManyWithoutRestaurantsInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsCreaterphoneInput>;
  friday?: Maybe<FridayCreateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayCreateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayCreateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsCreatemenuInput>;
  brandTile?: Maybe<BrandTileCreateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsCreaterestaurantImagesInput>;
}

export interface HotDealsUpdateInput {
  type?: Maybe<String>;
  restaurantses?: Maybe<RestaurantsUpdateManyWithoutHotDealsesInput>;
  imageurl?: Maybe<String>;
}

export interface RestaurantsUpdateManyWithoutHotDealsesInput {
  create?: Maybe<
    | RestaurantsCreateWithoutHotDealsesInput[]
    | RestaurantsCreateWithoutHotDealsesInput
  >;
  delete?: Maybe<RestaurantsWhereUniqueInput[] | RestaurantsWhereUniqueInput>;
  connect?: Maybe<RestaurantsWhereUniqueInput[] | RestaurantsWhereUniqueInput>;
  set?: Maybe<RestaurantsWhereUniqueInput[] | RestaurantsWhereUniqueInput>;
  disconnect?: Maybe<
    RestaurantsWhereUniqueInput[] | RestaurantsWhereUniqueInput
  >;
  update?: Maybe<
    | RestaurantsUpdateWithWhereUniqueWithoutHotDealsesInput[]
    | RestaurantsUpdateWithWhereUniqueWithoutHotDealsesInput
  >;
  upsert?: Maybe<
    | RestaurantsUpsertWithWhereUniqueWithoutHotDealsesInput[]
    | RestaurantsUpsertWithWhereUniqueWithoutHotDealsesInput
  >;
  deleteMany?: Maybe<
    RestaurantsScalarWhereInput[] | RestaurantsScalarWhereInput
  >;
  updateMany?: Maybe<
    | RestaurantsUpdateManyWithWhereNestedInput[]
    | RestaurantsUpdateManyWithWhereNestedInput
  >;
}

export interface RestaurantsUpdateWithWhereUniqueWithoutHotDealsesInput {
  where: RestaurantsWhereUniqueInput;
  data: RestaurantsUpdateWithoutHotDealsesDataInput;
}

export interface RestaurantsUpdateWithoutHotDealsesDataInput {
  city?: Maybe<String>;
  enableLoginAccess?: Maybe<Boolean>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersUpdateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeUpdateManyWithoutRestaurantsesInput>;
  state?: Maybe<String>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsUpdateManyWithoutRestaurantsInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsUpdaterphoneInput>;
  friday?: Maybe<FridayUpdateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayUpdateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsUpdatemenuInput>;
  brandTile?: Maybe<BrandTileUpdateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsUpdaterestaurantImagesInput>;
}

export interface RestaurantsUpsertWithWhereUniqueWithoutHotDealsesInput {
  where: RestaurantsWhereUniqueInput;
  update: RestaurantsUpdateWithoutHotDealsesDataInput;
  create: RestaurantsCreateWithoutHotDealsesInput;
}

export interface HotDealsUpdateManyMutationInput {
  type?: Maybe<String>;
  imageurl?: Maybe<String>;
}

export interface MiscCreateInput {
  faq?: Maybe<String>;
  fup?: Maybe<String>;
  id?: Maybe<ID_Input>;
}

export interface MiscUpdateInput {
  faq?: Maybe<String>;
  fup?: Maybe<String>;
}

export interface MiscUpdateManyMutationInput {
  faq?: Maybe<String>;
  fup?: Maybe<String>;
}

export interface MondayCreateInput {
  id?: Maybe<ID_Input>;
  exhausted?: Maybe<Boolean>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutMondayInput>;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutMondayInput>;
  order?: Maybe<Int>;
}

export interface MondayUpdateInput {
  exhausted?: Maybe<Boolean>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutMondayInput>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutMondayInput>;
  order?: Maybe<Int>;
}

export interface MondayUpdateManyMutationInput {
  exhausted?: Maybe<Boolean>;
  order?: Maybe<Int>;
}

export interface OrdersCreateInput {
  id?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutOrdersesInput>;
  timeDiscount?: Maybe<TimeDiscountCreateOneWithoutOrdersesInput>;
  user: UserCreateOneWithoutOrdersesInput;
  date: String;
  totalDiscount?: Maybe<Int>;
  people: Int;
  bookingid: String;
  mobile: String;
  unlockActive?: Maybe<Boolean>;
  name: String;
  geolocation?: Maybe<String>;
  referrer?: Maybe<String>;
  confirmed?: Maybe<Boolean>;
  cancelled?: Maybe<Boolean>;
  amount?: Maybe<Int>;
  receipt?: Maybe<String>;
  paymentId?: Maybe<String>;
  paymentOrderId?: Maybe<String>;
  paymentDescription?: Maybe<String>;
}

export interface OrdersUpdateInput {
  restaurants?: Maybe<RestaurantsUpdateOneWithoutOrdersesInput>;
  timeDiscount?: Maybe<TimeDiscountUpdateOneWithoutOrdersesInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutOrdersesInput>;
  date?: Maybe<String>;
  totalDiscount?: Maybe<Int>;
  people?: Maybe<Int>;
  bookingid?: Maybe<String>;
  mobile?: Maybe<String>;
  unlockActive?: Maybe<Boolean>;
  name?: Maybe<String>;
  geolocation?: Maybe<String>;
  referrer?: Maybe<String>;
  confirmed?: Maybe<Boolean>;
  cancelled?: Maybe<Boolean>;
  amount?: Maybe<Int>;
  receipt?: Maybe<String>;
  paymentId?: Maybe<String>;
  paymentOrderId?: Maybe<String>;
  paymentDescription?: Maybe<String>;
}

export interface OrdersUpdateManyMutationInput {
  date?: Maybe<String>;
  totalDiscount?: Maybe<Int>;
  people?: Maybe<Int>;
  bookingid?: Maybe<String>;
  mobile?: Maybe<String>;
  unlockActive?: Maybe<Boolean>;
  name?: Maybe<String>;
  geolocation?: Maybe<String>;
  referrer?: Maybe<String>;
  confirmed?: Maybe<Boolean>;
  cancelled?: Maybe<Boolean>;
  amount?: Maybe<Int>;
  receipt?: Maybe<String>;
  paymentId?: Maybe<String>;
  paymentOrderId?: Maybe<String>;
  paymentDescription?: Maybe<String>;
}

export interface RestaurantTypeCreateInput {
  id?: Maybe<ID_Input>;
  restaurantses?: Maybe<RestaurantsCreateManyWithoutRestaurantTypesInput>;
  type: String;
  imageurl?: Maybe<String>;
  order?: Maybe<Int>;
  typeName?: Maybe<String>;
  cityImage?: Maybe<String>;
  activatePremium?: Maybe<Boolean>;
  premiumPrice?: Maybe<Int>;
}

export interface RestaurantsCreateManyWithoutRestaurantTypesInput {
  create?: Maybe<
    | RestaurantsCreateWithoutRestaurantTypesInput[]
    | RestaurantsCreateWithoutRestaurantTypesInput
  >;
  connect?: Maybe<RestaurantsWhereUniqueInput[] | RestaurantsWhereUniqueInput>;
}

export interface RestaurantsCreateWithoutRestaurantTypesInput {
  city: String;
  id?: Maybe<ID_Input>;
  enableLoginAccess?: Maybe<Boolean>;
  name: String;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersCreateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  state: String;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsCreateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsCreateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsCreaterphoneInput>;
  friday?: Maybe<FridayCreateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayCreateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayCreateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsCreatemenuInput>;
  brandTile?: Maybe<BrandTileCreateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsCreaterestaurantImagesInput>;
}

export interface RestaurantTypeUpdateInput {
  restaurantses?: Maybe<RestaurantsUpdateManyWithoutRestaurantTypesInput>;
  type?: Maybe<String>;
  imageurl?: Maybe<String>;
  order?: Maybe<Int>;
  typeName?: Maybe<String>;
  cityImage?: Maybe<String>;
  activatePremium?: Maybe<Boolean>;
  premiumPrice?: Maybe<Int>;
}

export interface RestaurantsUpdateManyWithoutRestaurantTypesInput {
  create?: Maybe<
    | RestaurantsCreateWithoutRestaurantTypesInput[]
    | RestaurantsCreateWithoutRestaurantTypesInput
  >;
  delete?: Maybe<RestaurantsWhereUniqueInput[] | RestaurantsWhereUniqueInput>;
  connect?: Maybe<RestaurantsWhereUniqueInput[] | RestaurantsWhereUniqueInput>;
  set?: Maybe<RestaurantsWhereUniqueInput[] | RestaurantsWhereUniqueInput>;
  disconnect?: Maybe<
    RestaurantsWhereUniqueInput[] | RestaurantsWhereUniqueInput
  >;
  update?: Maybe<
    | RestaurantsUpdateWithWhereUniqueWithoutRestaurantTypesInput[]
    | RestaurantsUpdateWithWhereUniqueWithoutRestaurantTypesInput
  >;
  upsert?: Maybe<
    | RestaurantsUpsertWithWhereUniqueWithoutRestaurantTypesInput[]
    | RestaurantsUpsertWithWhereUniqueWithoutRestaurantTypesInput
  >;
  deleteMany?: Maybe<
    RestaurantsScalarWhereInput[] | RestaurantsScalarWhereInput
  >;
  updateMany?: Maybe<
    | RestaurantsUpdateManyWithWhereNestedInput[]
    | RestaurantsUpdateManyWithWhereNestedInput
  >;
}

export interface RestaurantsUpdateWithWhereUniqueWithoutRestaurantTypesInput {
  where: RestaurantsWhereUniqueInput;
  data: RestaurantsUpdateWithoutRestaurantTypesDataInput;
}

export interface RestaurantsUpdateWithoutRestaurantTypesDataInput {
  city?: Maybe<String>;
  enableLoginAccess?: Maybe<Boolean>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersUpdateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  state?: Maybe<String>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsUpdateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsUpdateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsUpdaterphoneInput>;
  friday?: Maybe<FridayUpdateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayUpdateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsUpdatemenuInput>;
  brandTile?: Maybe<BrandTileUpdateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsUpdaterestaurantImagesInput>;
}

export interface RestaurantsUpsertWithWhereUniqueWithoutRestaurantTypesInput {
  where: RestaurantsWhereUniqueInput;
  update: RestaurantsUpdateWithoutRestaurantTypesDataInput;
  create: RestaurantsCreateWithoutRestaurantTypesInput;
}

export interface RestaurantTypeUpdateManyMutationInput {
  type?: Maybe<String>;
  imageurl?: Maybe<String>;
  order?: Maybe<Int>;
  typeName?: Maybe<String>;
  cityImage?: Maybe<String>;
  activatePremium?: Maybe<Boolean>;
  premiumPrice?: Maybe<Int>;
}

export interface RestaurantsCreateInput {
  city: String;
  id?: Maybe<ID_Input>;
  enableLoginAccess?: Maybe<Boolean>;
  name: String;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersCreateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeCreateManyWithoutRestaurantsesInput>;
  state: String;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsCreateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsCreateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsCreaterphoneInput>;
  friday?: Maybe<FridayCreateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayCreateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayCreateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsCreatemenuInput>;
  brandTile?: Maybe<BrandTileCreateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsCreaterestaurantImagesInput>;
}

export interface RestaurantsUpdateInput {
  city?: Maybe<String>;
  enableLoginAccess?: Maybe<Boolean>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  orderses?: Maybe<OrdersUpdateManyWithoutRestaurantsInput>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  restaurantTypes?: Maybe<RestaurantTypeUpdateManyWithoutRestaurantsesInput>;
  state?: Maybe<String>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutRestaurantsInput>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  userReviewses?: Maybe<UserReviewsUpdateManyWithoutRestaurantsInput>;
  hotDealses?: Maybe<HotDealsUpdateManyWithoutRestaurantsesInput>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsUpdaterphoneInput>;
  friday?: Maybe<FridayUpdateOneWithoutRestaurantsInput>;
  monday?: Maybe<MondayUpdateOneWithoutRestaurantsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutRestaurantsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutRestaurantsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutRestaurantsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutRestaurantsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutRestaurantsInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsUpdatemenuInput>;
  brandTile?: Maybe<BrandTileUpdateOneWithoutRestaurantsesInput>;
  restaurantImages?: Maybe<RestaurantsUpdaterestaurantImagesInput>;
}

export interface RestaurantsUpdateManyMutationInput {
  city?: Maybe<String>;
  enableLoginAccess?: Maybe<Boolean>;
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  rating?: Maybe<Float>;
  imageurl?: Maybe<String>;
  googlemapsurl?: Maybe<String>;
  state?: Maybe<String>;
  about?: Maybe<String>;
  address?: Maybe<String>;
  conditions?: Maybe<String>;
  remail?: Maybe<String>;
  rphone?: Maybe<RestaurantsUpdaterphoneInput>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  acceptsRenoPay?: Maybe<Boolean>;
  renoCommision?: Maybe<Int>;
  menu?: Maybe<RestaurantsUpdatemenuInput>;
  restaurantImages?: Maybe<RestaurantsUpdaterestaurantImagesInput>;
}

export interface SaturdayCreateInput {
  exhausted?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutSaturdayInput>;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutSaturdayInput>;
  order?: Maybe<Int>;
}

export interface SaturdayUpdateInput {
  exhausted?: Maybe<Boolean>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutSaturdayInput>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutSaturdayInput>;
  order?: Maybe<Int>;
}

export interface SaturdayUpdateManyMutationInput {
  exhausted?: Maybe<Boolean>;
  order?: Maybe<Int>;
}

export interface SundayCreateInput {
  exhausted?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutSundayInput>;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutSundayInput>;
  order?: Maybe<Int>;
}

export interface SundayUpdateInput {
  exhausted?: Maybe<Boolean>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutSundayInput>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutSundayInput>;
  order?: Maybe<Int>;
}

export interface SundayUpdateManyMutationInput {
  exhausted?: Maybe<Boolean>;
  order?: Maybe<Int>;
}

export interface ThursdayCreateInput {
  exhausted?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  order?: Maybe<Int>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutThursdayInput>;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutThursdayInput>;
}

export interface ThursdayUpdateInput {
  exhausted?: Maybe<Boolean>;
  order?: Maybe<Int>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutThursdayInput>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutThursdayInput>;
}

export interface ThursdayUpdateManyMutationInput {
  exhausted?: Maybe<Boolean>;
  order?: Maybe<Int>;
}

export interface TimeDiscountCreateInput {
  discount: Float;
  id?: Maybe<ID_Input>;
  orderses?: Maybe<OrdersCreateManyWithoutTimeDiscountInput>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutTimeDiscountsInput>;
  time: String;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  friday?: Maybe<FridayCreateOneWithoutTimeDiscountsInput>;
  monday?: Maybe<MondayCreateOneWithoutTimeDiscountsInput>;
  saturday?: Maybe<SaturdayCreateOneWithoutTimeDiscountsInput>;
  sunday?: Maybe<SundayCreateOneWithoutTimeDiscountsInput>;
  thursday?: Maybe<ThursdayCreateOneWithoutTimeDiscountsInput>;
  tuesday?: Maybe<TuesdayCreateOneWithoutTimeDiscountsInput>;
  wednesday?: Maybe<WednesdayCreateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface TimeDiscountUpdateInput {
  discount?: Maybe<Float>;
  orderses?: Maybe<OrdersUpdateManyWithoutTimeDiscountInput>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutTimeDiscountsInput>;
  time?: Maybe<String>;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  friday?: Maybe<FridayUpdateOneWithoutTimeDiscountsInput>;
  monday?: Maybe<MondayUpdateOneWithoutTimeDiscountsInput>;
  saturday?: Maybe<SaturdayUpdateOneWithoutTimeDiscountsInput>;
  sunday?: Maybe<SundayUpdateOneWithoutTimeDiscountsInput>;
  thursday?: Maybe<ThursdayUpdateOneWithoutTimeDiscountsInput>;
  tuesday?: Maybe<TuesdayUpdateOneWithoutTimeDiscountsInput>;
  wednesday?: Maybe<WednesdayUpdateOneWithoutTimeDiscountsInput>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface TimeDiscountUpdateManyMutationInput {
  discount?: Maybe<Float>;
  time?: Maybe<String>;
  daychange?: Maybe<Boolean>;
  day?: Maybe<Boolean>;
  newtime?: Maybe<String>;
  newdiscount?: Maybe<String>;
  exhausted?: Maybe<Boolean>;
  tueExhaust?: Maybe<Boolean>;
  monExhaust?: Maybe<Boolean>;
  wedExhaust?: Maybe<Boolean>;
  thuExhaust?: Maybe<Boolean>;
  friExhaust?: Maybe<Boolean>;
  satExhaust?: Maybe<Boolean>;
  sunExhaust?: Maybe<Boolean>;
  monDiscount?: Maybe<Float>;
  tueDiscount?: Maybe<Float>;
  wedDiscount?: Maybe<Float>;
  thuDiscount?: Maybe<Float>;
  friDiscount?: Maybe<Float>;
  satDiscount?: Maybe<Float>;
  sunDiscount?: Maybe<Float>;
}

export interface TuesdayCreateInput {
  exhausted?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutTuesdayInput>;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutTuesdayInput>;
  order?: Maybe<Int>;
}

export interface TuesdayUpdateInput {
  exhausted?: Maybe<Boolean>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutTuesdayInput>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutTuesdayInput>;
  order?: Maybe<Int>;
}

export interface TuesdayUpdateManyMutationInput {
  exhausted?: Maybe<Boolean>;
  order?: Maybe<Int>;
}

export interface UserCreateInput {
  email?: Maybe<String>;
  firstname?: Maybe<String>;
  id?: Maybe<ID_Input>;
  facebookID: String;
  lastname?: Maybe<String>;
  mobile?: Maybe<String>;
  totalOrders?: Maybe<Int>;
  orderses?: Maybe<OrdersCreateManyWithoutUserInput>;
  contactSync?: Maybe<Boolean>;
  userReviewses?: Maybe<UserReviewsCreateManyWithoutUserInput>;
  isBlocked?: Maybe<Boolean>;
  promoCode?: Maybe<String>;
  userPromoCount?: Maybe<Int>;
  typeAccess?: Maybe<String>;
  password?: Maybe<String>;
  installLocation?: Maybe<String>;
  isPremiumUser?: Maybe<String>;
  currentLocation?: Maybe<String>;
  profileImage?: Maybe<String>;
  bookingOtp?: Maybe<String>;
  otpExpires?: Maybe<DateTimeInput>;
  premiumStartDate?: Maybe<DateTimeInput>;
  premiumExpireDate?: Maybe<DateTimeInput>;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  firstname?: Maybe<String>;
  facebookID?: Maybe<String>;
  lastname?: Maybe<String>;
  mobile?: Maybe<String>;
  totalOrders?: Maybe<Int>;
  orderses?: Maybe<OrdersUpdateManyWithoutUserInput>;
  contactSync?: Maybe<Boolean>;
  userReviewses?: Maybe<UserReviewsUpdateManyWithoutUserInput>;
  isBlocked?: Maybe<Boolean>;
  promoCode?: Maybe<String>;
  userPromoCount?: Maybe<Int>;
  typeAccess?: Maybe<String>;
  password?: Maybe<String>;
  installLocation?: Maybe<String>;
  isPremiumUser?: Maybe<String>;
  currentLocation?: Maybe<String>;
  profileImage?: Maybe<String>;
  bookingOtp?: Maybe<String>;
  otpExpires?: Maybe<DateTimeInput>;
  premiumStartDate?: Maybe<DateTimeInput>;
  premiumExpireDate?: Maybe<DateTimeInput>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  firstname?: Maybe<String>;
  facebookID?: Maybe<String>;
  lastname?: Maybe<String>;
  mobile?: Maybe<String>;
  totalOrders?: Maybe<Int>;
  contactSync?: Maybe<Boolean>;
  isBlocked?: Maybe<Boolean>;
  promoCode?: Maybe<String>;
  userPromoCount?: Maybe<Int>;
  typeAccess?: Maybe<String>;
  password?: Maybe<String>;
  installLocation?: Maybe<String>;
  isPremiumUser?: Maybe<String>;
  currentLocation?: Maybe<String>;
  profileImage?: Maybe<String>;
  bookingOtp?: Maybe<String>;
  otpExpires?: Maybe<DateTimeInput>;
  premiumStartDate?: Maybe<DateTimeInput>;
  premiumExpireDate?: Maybe<DateTimeInput>;
}

export interface UserReviewsCreateInput {
  id?: Maybe<ID_Input>;
  review: String;
  rating: Int;
  restaurants?: Maybe<RestaurantsCreateOneWithoutUserReviewsesInput>;
  user?: Maybe<UserCreateOneWithoutUserReviewsesInput>;
}

export interface UserReviewsUpdateInput {
  review?: Maybe<String>;
  rating?: Maybe<Int>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutUserReviewsesInput>;
  user?: Maybe<UserUpdateOneWithoutUserReviewsesInput>;
}

export interface UserReviewsUpdateManyMutationInput {
  review?: Maybe<String>;
  rating?: Maybe<Int>;
}

export interface WednesdayCreateInput {
  exhausted?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  restaurants?: Maybe<RestaurantsCreateOneWithoutWednesdayInput>;
  timeDiscounts?: Maybe<TimeDiscountCreateManyWithoutWednesdayInput>;
  order?: Maybe<Int>;
}

export interface WednesdayUpdateInput {
  exhausted?: Maybe<Boolean>;
  restaurants?: Maybe<RestaurantsUpdateOneWithoutWednesdayInput>;
  timeDiscounts?: Maybe<TimeDiscountUpdateManyWithoutWednesdayInput>;
  order?: Maybe<Int>;
}

export interface WednesdayUpdateManyMutationInput {
  exhausted?: Maybe<Boolean>;
  order?: Maybe<Int>;
}

export interface cityCreateInput {
  city: String;
  isPremium?: Maybe<Boolean>;
  id?: Maybe<ID_Input>;
  premiumAmmount90?: Maybe<Int>;
  premiumAmmount180?: Maybe<Int>;
  premiumAmmount360?: Maybe<Int>;
  imageUrl?: Maybe<String>;
}

export interface cityUpdateInput {
  city?: Maybe<String>;
  isPremium?: Maybe<Boolean>;
  premiumAmmount90?: Maybe<Int>;
  premiumAmmount180?: Maybe<Int>;
  premiumAmmount360?: Maybe<Int>;
  imageUrl?: Maybe<String>;
}

export interface cityUpdateManyMutationInput {
  city?: Maybe<String>;
  isPremium?: Maybe<Boolean>;
  premiumAmmount90?: Maybe<Int>;
  premiumAmmount180?: Maybe<Int>;
  premiumAmmount360?: Maybe<Int>;
  imageUrl?: Maybe<String>;
}

export interface AdsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AdsWhereInput>;
  AND?: Maybe<AdsSubscriptionWhereInput[] | AdsSubscriptionWhereInput>;
  OR?: Maybe<AdsSubscriptionWhereInput[] | AdsSubscriptionWhereInput>;
  NOT?: Maybe<AdsSubscriptionWhereInput[] | AdsSubscriptionWhereInput>;
}

export interface BlogSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BlogWhereInput>;
  AND?: Maybe<BlogSubscriptionWhereInput[] | BlogSubscriptionWhereInput>;
  OR?: Maybe<BlogSubscriptionWhereInput[] | BlogSubscriptionWhereInput>;
  NOT?: Maybe<BlogSubscriptionWhereInput[] | BlogSubscriptionWhereInput>;
}

export interface BrandTileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BrandTileWhereInput>;
  AND?: Maybe<
    BrandTileSubscriptionWhereInput[] | BrandTileSubscriptionWhereInput
  >;
  OR?: Maybe<
    BrandTileSubscriptionWhereInput[] | BrandTileSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BrandTileSubscriptionWhereInput[] | BrandTileSubscriptionWhereInput
  >;
}

export interface ContactsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ContactsWhereInput>;
  AND?: Maybe<
    ContactsSubscriptionWhereInput[] | ContactsSubscriptionWhereInput
  >;
  OR?: Maybe<ContactsSubscriptionWhereInput[] | ContactsSubscriptionWhereInput>;
  NOT?: Maybe<
    ContactsSubscriptionWhereInput[] | ContactsSubscriptionWhereInput
  >;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FileWhereInput>;
  AND?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
  OR?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
  NOT?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
}

export interface FridaySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FridayWhereInput>;
  AND?: Maybe<FridaySubscriptionWhereInput[] | FridaySubscriptionWhereInput>;
  OR?: Maybe<FridaySubscriptionWhereInput[] | FridaySubscriptionWhereInput>;
  NOT?: Maybe<FridaySubscriptionWhereInput[] | FridaySubscriptionWhereInput>;
}

export interface HotDealsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HotDealsWhereInput>;
  AND?: Maybe<
    HotDealsSubscriptionWhereInput[] | HotDealsSubscriptionWhereInput
  >;
  OR?: Maybe<HotDealsSubscriptionWhereInput[] | HotDealsSubscriptionWhereInput>;
  NOT?: Maybe<
    HotDealsSubscriptionWhereInput[] | HotDealsSubscriptionWhereInput
  >;
}

export interface MiscSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MiscWhereInput>;
  AND?: Maybe<MiscSubscriptionWhereInput[] | MiscSubscriptionWhereInput>;
  OR?: Maybe<MiscSubscriptionWhereInput[] | MiscSubscriptionWhereInput>;
  NOT?: Maybe<MiscSubscriptionWhereInput[] | MiscSubscriptionWhereInput>;
}

export interface MondaySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MondayWhereInput>;
  AND?: Maybe<MondaySubscriptionWhereInput[] | MondaySubscriptionWhereInput>;
  OR?: Maybe<MondaySubscriptionWhereInput[] | MondaySubscriptionWhereInput>;
  NOT?: Maybe<MondaySubscriptionWhereInput[] | MondaySubscriptionWhereInput>;
}

export interface OrdersSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrdersWhereInput>;
  AND?: Maybe<OrdersSubscriptionWhereInput[] | OrdersSubscriptionWhereInput>;
  OR?: Maybe<OrdersSubscriptionWhereInput[] | OrdersSubscriptionWhereInput>;
  NOT?: Maybe<OrdersSubscriptionWhereInput[] | OrdersSubscriptionWhereInput>;
}

export interface RestaurantTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RestaurantTypeWhereInput>;
  AND?: Maybe<
    | RestaurantTypeSubscriptionWhereInput[]
    | RestaurantTypeSubscriptionWhereInput
  >;
  OR?: Maybe<
    | RestaurantTypeSubscriptionWhereInput[]
    | RestaurantTypeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | RestaurantTypeSubscriptionWhereInput[]
    | RestaurantTypeSubscriptionWhereInput
  >;
}

export interface RestaurantsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RestaurantsWhereInput>;
  AND?: Maybe<
    RestaurantsSubscriptionWhereInput[] | RestaurantsSubscriptionWhereInput
  >;
  OR?: Maybe<
    RestaurantsSubscriptionWhereInput[] | RestaurantsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    RestaurantsSubscriptionWhereInput[] | RestaurantsSubscriptionWhereInput
  >;
}

export interface SaturdaySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SaturdayWhereInput>;
  AND?: Maybe<
    SaturdaySubscriptionWhereInput[] | SaturdaySubscriptionWhereInput
  >;
  OR?: Maybe<SaturdaySubscriptionWhereInput[] | SaturdaySubscriptionWhereInput>;
  NOT?: Maybe<
    SaturdaySubscriptionWhereInput[] | SaturdaySubscriptionWhereInput
  >;
}

export interface SundaySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SundayWhereInput>;
  AND?: Maybe<SundaySubscriptionWhereInput[] | SundaySubscriptionWhereInput>;
  OR?: Maybe<SundaySubscriptionWhereInput[] | SundaySubscriptionWhereInput>;
  NOT?: Maybe<SundaySubscriptionWhereInput[] | SundaySubscriptionWhereInput>;
}

export interface ThursdaySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ThursdayWhereInput>;
  AND?: Maybe<
    ThursdaySubscriptionWhereInput[] | ThursdaySubscriptionWhereInput
  >;
  OR?: Maybe<ThursdaySubscriptionWhereInput[] | ThursdaySubscriptionWhereInput>;
  NOT?: Maybe<
    ThursdaySubscriptionWhereInput[] | ThursdaySubscriptionWhereInput
  >;
}

export interface TimeDiscountSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TimeDiscountWhereInput>;
  AND?: Maybe<
    TimeDiscountSubscriptionWhereInput[] | TimeDiscountSubscriptionWhereInput
  >;
  OR?: Maybe<
    TimeDiscountSubscriptionWhereInput[] | TimeDiscountSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TimeDiscountSubscriptionWhereInput[] | TimeDiscountSubscriptionWhereInput
  >;
}

export interface TuesdaySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TuesdayWhereInput>;
  AND?: Maybe<TuesdaySubscriptionWhereInput[] | TuesdaySubscriptionWhereInput>;
  OR?: Maybe<TuesdaySubscriptionWhereInput[] | TuesdaySubscriptionWhereInput>;
  NOT?: Maybe<TuesdaySubscriptionWhereInput[] | TuesdaySubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface UserReviewsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserReviewsWhereInput>;
  AND?: Maybe<
    UserReviewsSubscriptionWhereInput[] | UserReviewsSubscriptionWhereInput
  >;
  OR?: Maybe<
    UserReviewsSubscriptionWhereInput[] | UserReviewsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    UserReviewsSubscriptionWhereInput[] | UserReviewsSubscriptionWhereInput
  >;
}

export interface WednesdaySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WednesdayWhereInput>;
  AND?: Maybe<
    WednesdaySubscriptionWhereInput[] | WednesdaySubscriptionWhereInput
  >;
  OR?: Maybe<
    WednesdaySubscriptionWhereInput[] | WednesdaySubscriptionWhereInput
  >;
  NOT?: Maybe<
    WednesdaySubscriptionWhereInput[] | WednesdaySubscriptionWhereInput
  >;
}

export interface citySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<cityWhereInput>;
  AND?: Maybe<citySubscriptionWhereInput[] | citySubscriptionWhereInput>;
  OR?: Maybe<citySubscriptionWhereInput[] | citySubscriptionWhereInput>;
  NOT?: Maybe<citySubscriptionWhereInput[] | citySubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Ads {
  city: String;
  id: ID_Output;
  imageurl: String;
  visible: Boolean;
}

export interface AdsPromise extends Promise<Ads>, Fragmentable {
  city: () => Promise<String>;
  id: () => Promise<ID_Output>;
  imageurl: () => Promise<String>;
  visible: () => Promise<Boolean>;
}

export interface AdsSubscription
  extends Promise<AsyncIterator<Ads>>,
    Fragmentable {
  city: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  imageurl: () => Promise<AsyncIterator<String>>;
  visible: () => Promise<AsyncIterator<Boolean>>;
}

export interface AdsNullablePromise extends Promise<Ads | null>, Fragmentable {
  city: () => Promise<String>;
  id: () => Promise<ID_Output>;
  imageurl: () => Promise<String>;
  visible: () => Promise<Boolean>;
}

export interface AdsConnection {
  pageInfo: PageInfo;
  edges: AdsEdge[];
}

export interface AdsConnectionPromise
  extends Promise<AdsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AdsEdge>>() => T;
  aggregate: <T = AggregateAdsPromise>() => T;
}

export interface AdsConnectionSubscription
  extends Promise<AsyncIterator<AdsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AdsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAdsSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AdsEdge {
  node: Ads;
  cursor: String;
}

export interface AdsEdgePromise extends Promise<AdsEdge>, Fragmentable {
  node: <T = AdsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AdsEdgeSubscription
  extends Promise<AsyncIterator<AdsEdge>>,
    Fragmentable {
  node: <T = AdsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAds {
  count: Int;
}

export interface AggregateAdsPromise
  extends Promise<AggregateAds>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAdsSubscription
  extends Promise<AsyncIterator<AggregateAds>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Blog {
  authorImg: String;
  authorName: String;
  content: String;
  createdon: DateTimeOutput;
  id: ID_Output;
  summary: String;
  title: String;
  titleImg?: String;
}

export interface BlogPromise extends Promise<Blog>, Fragmentable {
  authorImg: () => Promise<String>;
  authorName: () => Promise<String>;
  content: () => Promise<String>;
  createdon: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  summary: () => Promise<String>;
  title: () => Promise<String>;
  titleImg: () => Promise<String>;
}

export interface BlogSubscription
  extends Promise<AsyncIterator<Blog>>,
    Fragmentable {
  authorImg: () => Promise<AsyncIterator<String>>;
  authorName: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  createdon: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  summary: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  titleImg: () => Promise<AsyncIterator<String>>;
}

export interface BlogNullablePromise
  extends Promise<Blog | null>,
    Fragmentable {
  authorImg: () => Promise<String>;
  authorName: () => Promise<String>;
  content: () => Promise<String>;
  createdon: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  summary: () => Promise<String>;
  title: () => Promise<String>;
  titleImg: () => Promise<String>;
}

export interface BlogConnection {
  pageInfo: PageInfo;
  edges: BlogEdge[];
}

export interface BlogConnectionPromise
  extends Promise<BlogConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BlogEdge>>() => T;
  aggregate: <T = AggregateBlogPromise>() => T;
}

export interface BlogConnectionSubscription
  extends Promise<AsyncIterator<BlogConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BlogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBlogSubscription>() => T;
}

export interface BlogEdge {
  node: Blog;
  cursor: String;
}

export interface BlogEdgePromise extends Promise<BlogEdge>, Fragmentable {
  node: <T = BlogPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BlogEdgeSubscription
  extends Promise<AsyncIterator<BlogEdge>>,
    Fragmentable {
  node: <T = BlogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBlog {
  count: Int;
}

export interface AggregateBlogPromise
  extends Promise<AggregateBlog>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBlogSubscription
  extends Promise<AsyncIterator<AggregateBlog>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BrandTile {
  id: ID_Output;
  type: String;
  imageurl?: String;
  order?: Int;
  brandTileName: String;
}

export interface BrandTilePromise extends Promise<BrandTile>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  imageurl: () => Promise<String>;
  order: () => Promise<Int>;
  restaurantses: <T = FragmentableArray<Restaurants>>(args?: {
    where?: RestaurantsWhereInput;
    orderBy?: RestaurantsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  brandTileName: () => Promise<String>;
}

export interface BrandTileSubscription
  extends Promise<AsyncIterator<BrandTile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  imageurl: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  restaurantses: <T = Promise<AsyncIterator<RestaurantsSubscription>>>(args?: {
    where?: RestaurantsWhereInput;
    orderBy?: RestaurantsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  brandTileName: () => Promise<AsyncIterator<String>>;
}

export interface BrandTileNullablePromise
  extends Promise<BrandTile | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  imageurl: () => Promise<String>;
  order: () => Promise<Int>;
  restaurantses: <T = FragmentableArray<Restaurants>>(args?: {
    where?: RestaurantsWhereInput;
    orderBy?: RestaurantsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  brandTileName: () => Promise<String>;
}

export interface Restaurants {
  city: String;
  id: ID_Output;
  enableLoginAccess: Boolean;
  name: String;
  email?: String;
  password?: String;
  rating?: Float;
  imageurl?: String;
  googlemapsurl?: String;
  state: String;
  about?: String;
  address?: String;
  conditions?: String;
  remail?: String;
  rphone: String[];
  latitude?: Float;
  longitude?: Float;
  acceptsRenoPay: Boolean;
  renoCommision: Int;
  menu: Json[];
  restaurantImages: String[];
}

export interface RestaurantsPromise extends Promise<Restaurants>, Fragmentable {
  city: () => Promise<String>;
  id: () => Promise<ID_Output>;
  enableLoginAccess: () => Promise<Boolean>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  orderses: <T = FragmentableArray<Orders>>(args?: {
    where?: OrdersWhereInput;
    orderBy?: OrdersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  rating: () => Promise<Float>;
  imageurl: () => Promise<String>;
  googlemapsurl: () => Promise<String>;
  restaurantTypes: <T = FragmentableArray<RestaurantType>>(args?: {
    where?: RestaurantTypeWhereInput;
    orderBy?: RestaurantTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  state: () => Promise<String>;
  timeDiscounts: <T = FragmentableArray<TimeDiscount>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  about: () => Promise<String>;
  address: () => Promise<String>;
  userReviewses: <T = FragmentableArray<UserReviews>>(args?: {
    where?: UserReviewsWhereInput;
    orderBy?: UserReviewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hotDealses: <T = FragmentableArray<HotDeals>>(args?: {
    where?: HotDealsWhereInput;
    orderBy?: HotDealsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  conditions: () => Promise<String>;
  remail: () => Promise<String>;
  rphone: () => Promise<String[]>;
  friday: <T = FridayPromise>() => T;
  monday: <T = MondayPromise>() => T;
  saturday: <T = SaturdayPromise>() => T;
  sunday: <T = SundayPromise>() => T;
  thursday: <T = ThursdayPromise>() => T;
  tuesday: <T = TuesdayPromise>() => T;
  wednesday: <T = WednesdayPromise>() => T;
  latitude: () => Promise<Float>;
  longitude: () => Promise<Float>;
  acceptsRenoPay: () => Promise<Boolean>;
  renoCommision: () => Promise<Int>;
  menu: () => Promise<Json[]>;
  brandTile: <T = BrandTilePromise>() => T;
  restaurantImages: () => Promise<String[]>;
}

export interface RestaurantsSubscription
  extends Promise<AsyncIterator<Restaurants>>,
    Fragmentable {
  city: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  enableLoginAccess: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  orderses: <T = Promise<AsyncIterator<OrdersSubscription>>>(args?: {
    where?: OrdersWhereInput;
    orderBy?: OrdersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  rating: () => Promise<AsyncIterator<Float>>;
  imageurl: () => Promise<AsyncIterator<String>>;
  googlemapsurl: () => Promise<AsyncIterator<String>>;
  restaurantTypes: <
    T = Promise<AsyncIterator<RestaurantTypeSubscription>>
  >(args?: {
    where?: RestaurantTypeWhereInput;
    orderBy?: RestaurantTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  state: () => Promise<AsyncIterator<String>>;
  timeDiscounts: <T = Promise<AsyncIterator<TimeDiscountSubscription>>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  about: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  userReviewses: <T = Promise<AsyncIterator<UserReviewsSubscription>>>(args?: {
    where?: UserReviewsWhereInput;
    orderBy?: UserReviewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hotDealses: <T = Promise<AsyncIterator<HotDealsSubscription>>>(args?: {
    where?: HotDealsWhereInput;
    orderBy?: HotDealsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  conditions: () => Promise<AsyncIterator<String>>;
  remail: () => Promise<AsyncIterator<String>>;
  rphone: () => Promise<AsyncIterator<String[]>>;
  friday: <T = FridaySubscription>() => T;
  monday: <T = MondaySubscription>() => T;
  saturday: <T = SaturdaySubscription>() => T;
  sunday: <T = SundaySubscription>() => T;
  thursday: <T = ThursdaySubscription>() => T;
  tuesday: <T = TuesdaySubscription>() => T;
  wednesday: <T = WednesdaySubscription>() => T;
  latitude: () => Promise<AsyncIterator<Float>>;
  longitude: () => Promise<AsyncIterator<Float>>;
  acceptsRenoPay: () => Promise<AsyncIterator<Boolean>>;
  renoCommision: () => Promise<AsyncIterator<Int>>;
  menu: () => Promise<AsyncIterator<Json[]>>;
  brandTile: <T = BrandTileSubscription>() => T;
  restaurantImages: () => Promise<AsyncIterator<String[]>>;
}

export interface RestaurantsNullablePromise
  extends Promise<Restaurants | null>,
    Fragmentable {
  city: () => Promise<String>;
  id: () => Promise<ID_Output>;
  enableLoginAccess: () => Promise<Boolean>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  orderses: <T = FragmentableArray<Orders>>(args?: {
    where?: OrdersWhereInput;
    orderBy?: OrdersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  rating: () => Promise<Float>;
  imageurl: () => Promise<String>;
  googlemapsurl: () => Promise<String>;
  restaurantTypes: <T = FragmentableArray<RestaurantType>>(args?: {
    where?: RestaurantTypeWhereInput;
    orderBy?: RestaurantTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  state: () => Promise<String>;
  timeDiscounts: <T = FragmentableArray<TimeDiscount>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  about: () => Promise<String>;
  address: () => Promise<String>;
  userReviewses: <T = FragmentableArray<UserReviews>>(args?: {
    where?: UserReviewsWhereInput;
    orderBy?: UserReviewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hotDealses: <T = FragmentableArray<HotDeals>>(args?: {
    where?: HotDealsWhereInput;
    orderBy?: HotDealsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  conditions: () => Promise<String>;
  remail: () => Promise<String>;
  rphone: () => Promise<String[]>;
  friday: <T = FridayPromise>() => T;
  monday: <T = MondayPromise>() => T;
  saturday: <T = SaturdayPromise>() => T;
  sunday: <T = SundayPromise>() => T;
  thursday: <T = ThursdayPromise>() => T;
  tuesday: <T = TuesdayPromise>() => T;
  wednesday: <T = WednesdayPromise>() => T;
  latitude: () => Promise<Float>;
  longitude: () => Promise<Float>;
  acceptsRenoPay: () => Promise<Boolean>;
  renoCommision: () => Promise<Int>;
  menu: () => Promise<Json[]>;
  brandTile: <T = BrandTilePromise>() => T;
  restaurantImages: () => Promise<String[]>;
}

export interface Orders {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  id: ID_Output;
  date: String;
  totalDiscount: Int;
  people: Int;
  bookingid: String;
  mobile: String;
  unlockActive: Boolean;
  name: String;
  geolocation?: String;
  referrer?: String;
  confirmed?: Boolean;
  cancelled: Boolean;
  amount?: Int;
  receipt?: String;
  paymentId?: String;
  paymentOrderId?: String;
  paymentDescription?: String;
}

export interface OrdersPromise extends Promise<Orders>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  restaurants: <T = RestaurantsPromise>() => T;
  timeDiscount: <T = TimeDiscountPromise>() => T;
  user: <T = UserPromise>() => T;
  date: () => Promise<String>;
  totalDiscount: () => Promise<Int>;
  people: () => Promise<Int>;
  bookingid: () => Promise<String>;
  mobile: () => Promise<String>;
  unlockActive: () => Promise<Boolean>;
  name: () => Promise<String>;
  geolocation: () => Promise<String>;
  referrer: () => Promise<String>;
  confirmed: () => Promise<Boolean>;
  cancelled: () => Promise<Boolean>;
  amount: () => Promise<Int>;
  receipt: () => Promise<String>;
  paymentId: () => Promise<String>;
  paymentOrderId: () => Promise<String>;
  paymentDescription: () => Promise<String>;
}

export interface OrdersSubscription
  extends Promise<AsyncIterator<Orders>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  restaurants: <T = RestaurantsSubscription>() => T;
  timeDiscount: <T = TimeDiscountSubscription>() => T;
  user: <T = UserSubscription>() => T;
  date: () => Promise<AsyncIterator<String>>;
  totalDiscount: () => Promise<AsyncIterator<Int>>;
  people: () => Promise<AsyncIterator<Int>>;
  bookingid: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  unlockActive: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  geolocation: () => Promise<AsyncIterator<String>>;
  referrer: () => Promise<AsyncIterator<String>>;
  confirmed: () => Promise<AsyncIterator<Boolean>>;
  cancelled: () => Promise<AsyncIterator<Boolean>>;
  amount: () => Promise<AsyncIterator<Int>>;
  receipt: () => Promise<AsyncIterator<String>>;
  paymentId: () => Promise<AsyncIterator<String>>;
  paymentOrderId: () => Promise<AsyncIterator<String>>;
  paymentDescription: () => Promise<AsyncIterator<String>>;
}

export interface OrdersNullablePromise
  extends Promise<Orders | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  restaurants: <T = RestaurantsPromise>() => T;
  timeDiscount: <T = TimeDiscountPromise>() => T;
  user: <T = UserPromise>() => T;
  date: () => Promise<String>;
  totalDiscount: () => Promise<Int>;
  people: () => Promise<Int>;
  bookingid: () => Promise<String>;
  mobile: () => Promise<String>;
  unlockActive: () => Promise<Boolean>;
  name: () => Promise<String>;
  geolocation: () => Promise<String>;
  referrer: () => Promise<String>;
  confirmed: () => Promise<Boolean>;
  cancelled: () => Promise<Boolean>;
  amount: () => Promise<Int>;
  receipt: () => Promise<String>;
  paymentId: () => Promise<String>;
  paymentOrderId: () => Promise<String>;
  paymentDescription: () => Promise<String>;
}

export interface TimeDiscount {
  discount: Float;
  id: ID_Output;
  time: String;
  daychange?: Boolean;
  day?: Boolean;
  newtime?: String;
  newdiscount?: String;
  exhausted?: Boolean;
  tueExhaust: Boolean;
  monExhaust: Boolean;
  wedExhaust: Boolean;
  thuExhaust: Boolean;
  friExhaust: Boolean;
  satExhaust: Boolean;
  sunExhaust: Boolean;
  monDiscount: Float;
  tueDiscount: Float;
  wedDiscount: Float;
  thuDiscount: Float;
  friDiscount: Float;
  satDiscount: Float;
  sunDiscount: Float;
}

export interface TimeDiscountPromise
  extends Promise<TimeDiscount>,
    Fragmentable {
  discount: () => Promise<Float>;
  id: () => Promise<ID_Output>;
  orderses: <T = FragmentableArray<Orders>>(args?: {
    where?: OrdersWhereInput;
    orderBy?: OrdersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  restaurants: <T = RestaurantsPromise>() => T;
  time: () => Promise<String>;
  daychange: () => Promise<Boolean>;
  day: () => Promise<Boolean>;
  newtime: () => Promise<String>;
  newdiscount: () => Promise<String>;
  friday: <T = FridayPromise>() => T;
  monday: <T = MondayPromise>() => T;
  saturday: <T = SaturdayPromise>() => T;
  sunday: <T = SundayPromise>() => T;
  thursday: <T = ThursdayPromise>() => T;
  tuesday: <T = TuesdayPromise>() => T;
  wednesday: <T = WednesdayPromise>() => T;
  exhausted: () => Promise<Boolean>;
  tueExhaust: () => Promise<Boolean>;
  monExhaust: () => Promise<Boolean>;
  wedExhaust: () => Promise<Boolean>;
  thuExhaust: () => Promise<Boolean>;
  friExhaust: () => Promise<Boolean>;
  satExhaust: () => Promise<Boolean>;
  sunExhaust: () => Promise<Boolean>;
  monDiscount: () => Promise<Float>;
  tueDiscount: () => Promise<Float>;
  wedDiscount: () => Promise<Float>;
  thuDiscount: () => Promise<Float>;
  friDiscount: () => Promise<Float>;
  satDiscount: () => Promise<Float>;
  sunDiscount: () => Promise<Float>;
}

export interface TimeDiscountSubscription
  extends Promise<AsyncIterator<TimeDiscount>>,
    Fragmentable {
  discount: () => Promise<AsyncIterator<Float>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  orderses: <T = Promise<AsyncIterator<OrdersSubscription>>>(args?: {
    where?: OrdersWhereInput;
    orderBy?: OrdersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  restaurants: <T = RestaurantsSubscription>() => T;
  time: () => Promise<AsyncIterator<String>>;
  daychange: () => Promise<AsyncIterator<Boolean>>;
  day: () => Promise<AsyncIterator<Boolean>>;
  newtime: () => Promise<AsyncIterator<String>>;
  newdiscount: () => Promise<AsyncIterator<String>>;
  friday: <T = FridaySubscription>() => T;
  monday: <T = MondaySubscription>() => T;
  saturday: <T = SaturdaySubscription>() => T;
  sunday: <T = SundaySubscription>() => T;
  thursday: <T = ThursdaySubscription>() => T;
  tuesday: <T = TuesdaySubscription>() => T;
  wednesday: <T = WednesdaySubscription>() => T;
  exhausted: () => Promise<AsyncIterator<Boolean>>;
  tueExhaust: () => Promise<AsyncIterator<Boolean>>;
  monExhaust: () => Promise<AsyncIterator<Boolean>>;
  wedExhaust: () => Promise<AsyncIterator<Boolean>>;
  thuExhaust: () => Promise<AsyncIterator<Boolean>>;
  friExhaust: () => Promise<AsyncIterator<Boolean>>;
  satExhaust: () => Promise<AsyncIterator<Boolean>>;
  sunExhaust: () => Promise<AsyncIterator<Boolean>>;
  monDiscount: () => Promise<AsyncIterator<Float>>;
  tueDiscount: () => Promise<AsyncIterator<Float>>;
  wedDiscount: () => Promise<AsyncIterator<Float>>;
  thuDiscount: () => Promise<AsyncIterator<Float>>;
  friDiscount: () => Promise<AsyncIterator<Float>>;
  satDiscount: () => Promise<AsyncIterator<Float>>;
  sunDiscount: () => Promise<AsyncIterator<Float>>;
}

export interface TimeDiscountNullablePromise
  extends Promise<TimeDiscount | null>,
    Fragmentable {
  discount: () => Promise<Float>;
  id: () => Promise<ID_Output>;
  orderses: <T = FragmentableArray<Orders>>(args?: {
    where?: OrdersWhereInput;
    orderBy?: OrdersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  restaurants: <T = RestaurantsPromise>() => T;
  time: () => Promise<String>;
  daychange: () => Promise<Boolean>;
  day: () => Promise<Boolean>;
  newtime: () => Promise<String>;
  newdiscount: () => Promise<String>;
  friday: <T = FridayPromise>() => T;
  monday: <T = MondayPromise>() => T;
  saturday: <T = SaturdayPromise>() => T;
  sunday: <T = SundayPromise>() => T;
  thursday: <T = ThursdayPromise>() => T;
  tuesday: <T = TuesdayPromise>() => T;
  wednesday: <T = WednesdayPromise>() => T;
  exhausted: () => Promise<Boolean>;
  tueExhaust: () => Promise<Boolean>;
  monExhaust: () => Promise<Boolean>;
  wedExhaust: () => Promise<Boolean>;
  thuExhaust: () => Promise<Boolean>;
  friExhaust: () => Promise<Boolean>;
  satExhaust: () => Promise<Boolean>;
  sunExhaust: () => Promise<Boolean>;
  monDiscount: () => Promise<Float>;
  tueDiscount: () => Promise<Float>;
  wedDiscount: () => Promise<Float>;
  thuDiscount: () => Promise<Float>;
  friDiscount: () => Promise<Float>;
  satDiscount: () => Promise<Float>;
  sunDiscount: () => Promise<Float>;
}

export interface Friday {
  exhausted: Boolean;
  id: ID_Output;
  order?: Int;
}

export interface FridayPromise extends Promise<Friday>, Fragmentable {
  exhausted: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  restaurants: <T = RestaurantsPromise>() => T;
  timeDiscounts: <T = FragmentableArray<TimeDiscount>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: () => Promise<Int>;
}

export interface FridaySubscription
  extends Promise<AsyncIterator<Friday>>,
    Fragmentable {
  exhausted: () => Promise<AsyncIterator<Boolean>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  restaurants: <T = RestaurantsSubscription>() => T;
  timeDiscounts: <T = Promise<AsyncIterator<TimeDiscountSubscription>>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface FridayNullablePromise
  extends Promise<Friday | null>,
    Fragmentable {
  exhausted: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  restaurants: <T = RestaurantsPromise>() => T;
  timeDiscounts: <T = FragmentableArray<TimeDiscount>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: () => Promise<Int>;
}

export interface Monday {
  id: ID_Output;
  exhausted?: Boolean;
  order?: Int;
}

export interface MondayPromise extends Promise<Monday>, Fragmentable {
  id: () => Promise<ID_Output>;
  exhausted: () => Promise<Boolean>;
  restaurants: <T = RestaurantsPromise>() => T;
  timeDiscounts: <T = FragmentableArray<TimeDiscount>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: () => Promise<Int>;
}

export interface MondaySubscription
  extends Promise<AsyncIterator<Monday>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  exhausted: () => Promise<AsyncIterator<Boolean>>;
  restaurants: <T = RestaurantsSubscription>() => T;
  timeDiscounts: <T = Promise<AsyncIterator<TimeDiscountSubscription>>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface MondayNullablePromise
  extends Promise<Monday | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  exhausted: () => Promise<Boolean>;
  restaurants: <T = RestaurantsPromise>() => T;
  timeDiscounts: <T = FragmentableArray<TimeDiscount>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: () => Promise<Int>;
}

export interface Saturday {
  exhausted: Boolean;
  id: ID_Output;
  order?: Int;
}

export interface SaturdayPromise extends Promise<Saturday>, Fragmentable {
  exhausted: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  restaurants: <T = RestaurantsPromise>() => T;
  timeDiscounts: <T = FragmentableArray<TimeDiscount>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: () => Promise<Int>;
}

export interface SaturdaySubscription
  extends Promise<AsyncIterator<Saturday>>,
    Fragmentable {
  exhausted: () => Promise<AsyncIterator<Boolean>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  restaurants: <T = RestaurantsSubscription>() => T;
  timeDiscounts: <T = Promise<AsyncIterator<TimeDiscountSubscription>>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface SaturdayNullablePromise
  extends Promise<Saturday | null>,
    Fragmentable {
  exhausted: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  restaurants: <T = RestaurantsPromise>() => T;
  timeDiscounts: <T = FragmentableArray<TimeDiscount>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: () => Promise<Int>;
}

export interface Sunday {
  exhausted: Boolean;
  id: ID_Output;
  order?: Int;
}

export interface SundayPromise extends Promise<Sunday>, Fragmentable {
  exhausted: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  restaurants: <T = RestaurantsPromise>() => T;
  timeDiscounts: <T = FragmentableArray<TimeDiscount>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: () => Promise<Int>;
}

export interface SundaySubscription
  extends Promise<AsyncIterator<Sunday>>,
    Fragmentable {
  exhausted: () => Promise<AsyncIterator<Boolean>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  restaurants: <T = RestaurantsSubscription>() => T;
  timeDiscounts: <T = Promise<AsyncIterator<TimeDiscountSubscription>>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface SundayNullablePromise
  extends Promise<Sunday | null>,
    Fragmentable {
  exhausted: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  restaurants: <T = RestaurantsPromise>() => T;
  timeDiscounts: <T = FragmentableArray<TimeDiscount>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: () => Promise<Int>;
}

export interface Thursday {
  exhausted: Boolean;
  id: ID_Output;
  order?: Int;
}

export interface ThursdayPromise extends Promise<Thursday>, Fragmentable {
  exhausted: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  restaurants: <T = RestaurantsPromise>() => T;
  timeDiscounts: <T = FragmentableArray<TimeDiscount>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ThursdaySubscription
  extends Promise<AsyncIterator<Thursday>>,
    Fragmentable {
  exhausted: () => Promise<AsyncIterator<Boolean>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
  restaurants: <T = RestaurantsSubscription>() => T;
  timeDiscounts: <T = Promise<AsyncIterator<TimeDiscountSubscription>>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ThursdayNullablePromise
  extends Promise<Thursday | null>,
    Fragmentable {
  exhausted: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  restaurants: <T = RestaurantsPromise>() => T;
  timeDiscounts: <T = FragmentableArray<TimeDiscount>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Tuesday {
  exhausted: Boolean;
  id: ID_Output;
  order?: Int;
}

export interface TuesdayPromise extends Promise<Tuesday>, Fragmentable {
  exhausted: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  restaurants: <T = RestaurantsPromise>() => T;
  timeDiscounts: <T = FragmentableArray<TimeDiscount>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: () => Promise<Int>;
}

export interface TuesdaySubscription
  extends Promise<AsyncIterator<Tuesday>>,
    Fragmentable {
  exhausted: () => Promise<AsyncIterator<Boolean>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  restaurants: <T = RestaurantsSubscription>() => T;
  timeDiscounts: <T = Promise<AsyncIterator<TimeDiscountSubscription>>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface TuesdayNullablePromise
  extends Promise<Tuesday | null>,
    Fragmentable {
  exhausted: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  restaurants: <T = RestaurantsPromise>() => T;
  timeDiscounts: <T = FragmentableArray<TimeDiscount>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: () => Promise<Int>;
}

export interface Wednesday {
  exhausted: Boolean;
  id: ID_Output;
  order?: Int;
}

export interface WednesdayPromise extends Promise<Wednesday>, Fragmentable {
  exhausted: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  restaurants: <T = RestaurantsPromise>() => T;
  timeDiscounts: <T = FragmentableArray<TimeDiscount>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: () => Promise<Int>;
}

export interface WednesdaySubscription
  extends Promise<AsyncIterator<Wednesday>>,
    Fragmentable {
  exhausted: () => Promise<AsyncIterator<Boolean>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  restaurants: <T = RestaurantsSubscription>() => T;
  timeDiscounts: <T = Promise<AsyncIterator<TimeDiscountSubscription>>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface WednesdayNullablePromise
  extends Promise<Wednesday | null>,
    Fragmentable {
  exhausted: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  restaurants: <T = RestaurantsPromise>() => T;
  timeDiscounts: <T = FragmentableArray<TimeDiscount>>(args?: {
    where?: TimeDiscountWhereInput;
    orderBy?: TimeDiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: () => Promise<Int>;
}

export interface User {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email?: String;
  firstname?: String;
  id: ID_Output;
  facebookID: String;
  lastname?: String;
  mobile?: String;
  totalOrders?: Int;
  contactSync?: Boolean;
  isBlocked?: Boolean;
  promoCode?: String;
  userPromoCount?: Int;
  typeAccess: String;
  password?: String;
  installLocation?: String;
  isPremiumUser?: String;
  currentLocation?: String;
  profileImage?: String;
  bookingOtp?: String;
  otpExpires?: DateTimeOutput;
  premiumStartDate?: DateTimeOutput;
  premiumExpireDate?: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  firstname: () => Promise<String>;
  id: () => Promise<ID_Output>;
  facebookID: () => Promise<String>;
  lastname: () => Promise<String>;
  mobile: () => Promise<String>;
  totalOrders: () => Promise<Int>;
  orderses: <T = FragmentableArray<Orders>>(args?: {
    where?: OrdersWhereInput;
    orderBy?: OrdersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contactSync: () => Promise<Boolean>;
  userReviewses: <T = FragmentableArray<UserReviews>>(args?: {
    where?: UserReviewsWhereInput;
    orderBy?: UserReviewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isBlocked: () => Promise<Boolean>;
  promoCode: () => Promise<String>;
  userPromoCount: () => Promise<Int>;
  typeAccess: () => Promise<String>;
  password: () => Promise<String>;
  installLocation: () => Promise<String>;
  isPremiumUser: () => Promise<String>;
  currentLocation: () => Promise<String>;
  profileImage: () => Promise<String>;
  bookingOtp: () => Promise<String>;
  otpExpires: () => Promise<DateTimeOutput>;
  premiumStartDate: () => Promise<DateTimeOutput>;
  premiumExpireDate: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  firstname: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  facebookID: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  totalOrders: () => Promise<AsyncIterator<Int>>;
  orderses: <T = Promise<AsyncIterator<OrdersSubscription>>>(args?: {
    where?: OrdersWhereInput;
    orderBy?: OrdersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contactSync: () => Promise<AsyncIterator<Boolean>>;
  userReviewses: <T = Promise<AsyncIterator<UserReviewsSubscription>>>(args?: {
    where?: UserReviewsWhereInput;
    orderBy?: UserReviewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isBlocked: () => Promise<AsyncIterator<Boolean>>;
  promoCode: () => Promise<AsyncIterator<String>>;
  userPromoCount: () => Promise<AsyncIterator<Int>>;
  typeAccess: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  installLocation: () => Promise<AsyncIterator<String>>;
  isPremiumUser: () => Promise<AsyncIterator<String>>;
  currentLocation: () => Promise<AsyncIterator<String>>;
  profileImage: () => Promise<AsyncIterator<String>>;
  bookingOtp: () => Promise<AsyncIterator<String>>;
  otpExpires: () => Promise<AsyncIterator<DateTimeOutput>>;
  premiumStartDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  premiumExpireDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  firstname: () => Promise<String>;
  id: () => Promise<ID_Output>;
  facebookID: () => Promise<String>;
  lastname: () => Promise<String>;
  mobile: () => Promise<String>;
  totalOrders: () => Promise<Int>;
  orderses: <T = FragmentableArray<Orders>>(args?: {
    where?: OrdersWhereInput;
    orderBy?: OrdersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contactSync: () => Promise<Boolean>;
  userReviewses: <T = FragmentableArray<UserReviews>>(args?: {
    where?: UserReviewsWhereInput;
    orderBy?: UserReviewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isBlocked: () => Promise<Boolean>;
  promoCode: () => Promise<String>;
  userPromoCount: () => Promise<Int>;
  typeAccess: () => Promise<String>;
  password: () => Promise<String>;
  installLocation: () => Promise<String>;
  isPremiumUser: () => Promise<String>;
  currentLocation: () => Promise<String>;
  profileImage: () => Promise<String>;
  bookingOtp: () => Promise<String>;
  otpExpires: () => Promise<DateTimeOutput>;
  premiumStartDate: () => Promise<DateTimeOutput>;
  premiumExpireDate: () => Promise<DateTimeOutput>;
}

export interface UserReviews {
  id: ID_Output;
  review: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  rating: Int;
}

export interface UserReviewsPromise extends Promise<UserReviews>, Fragmentable {
  id: () => Promise<ID_Output>;
  review: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  rating: () => Promise<Int>;
  restaurants: <T = RestaurantsPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface UserReviewsSubscription
  extends Promise<AsyncIterator<UserReviews>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  review: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  rating: () => Promise<AsyncIterator<Int>>;
  restaurants: <T = RestaurantsSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface UserReviewsNullablePromise
  extends Promise<UserReviews | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  review: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  rating: () => Promise<Int>;
  restaurants: <T = RestaurantsPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface RestaurantType {
  id: ID_Output;
  type: String;
  imageurl?: String;
  order?: Int;
  typeName?: String;
  cityImage?: String;
  activatePremium?: Boolean;
  premiumPrice?: Int;
}

export interface RestaurantTypePromise
  extends Promise<RestaurantType>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  restaurantses: <T = FragmentableArray<Restaurants>>(args?: {
    where?: RestaurantsWhereInput;
    orderBy?: RestaurantsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  type: () => Promise<String>;
  imageurl: () => Promise<String>;
  order: () => Promise<Int>;
  typeName: () => Promise<String>;
  cityImage: () => Promise<String>;
  activatePremium: () => Promise<Boolean>;
  premiumPrice: () => Promise<Int>;
}

export interface RestaurantTypeSubscription
  extends Promise<AsyncIterator<RestaurantType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  restaurantses: <T = Promise<AsyncIterator<RestaurantsSubscription>>>(args?: {
    where?: RestaurantsWhereInput;
    orderBy?: RestaurantsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  type: () => Promise<AsyncIterator<String>>;
  imageurl: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  typeName: () => Promise<AsyncIterator<String>>;
  cityImage: () => Promise<AsyncIterator<String>>;
  activatePremium: () => Promise<AsyncIterator<Boolean>>;
  premiumPrice: () => Promise<AsyncIterator<Int>>;
}

export interface RestaurantTypeNullablePromise
  extends Promise<RestaurantType | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  restaurantses: <T = FragmentableArray<Restaurants>>(args?: {
    where?: RestaurantsWhereInput;
    orderBy?: RestaurantsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  type: () => Promise<String>;
  imageurl: () => Promise<String>;
  order: () => Promise<Int>;
  typeName: () => Promise<String>;
  cityImage: () => Promise<String>;
  activatePremium: () => Promise<Boolean>;
  premiumPrice: () => Promise<Int>;
}

export interface HotDeals {
  id: ID_Output;
  type: String;
  imageurl?: String;
}

export interface HotDealsPromise extends Promise<HotDeals>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  restaurantses: <T = FragmentableArray<Restaurants>>(args?: {
    where?: RestaurantsWhereInput;
    orderBy?: RestaurantsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  imageurl: () => Promise<String>;
}

export interface HotDealsSubscription
  extends Promise<AsyncIterator<HotDeals>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  restaurantses: <T = Promise<AsyncIterator<RestaurantsSubscription>>>(args?: {
    where?: RestaurantsWhereInput;
    orderBy?: RestaurantsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  imageurl: () => Promise<AsyncIterator<String>>;
}

export interface HotDealsNullablePromise
  extends Promise<HotDeals | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  restaurantses: <T = FragmentableArray<Restaurants>>(args?: {
    where?: RestaurantsWhereInput;
    orderBy?: RestaurantsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  imageurl: () => Promise<String>;
}

export interface BrandTileConnection {
  pageInfo: PageInfo;
  edges: BrandTileEdge[];
}

export interface BrandTileConnectionPromise
  extends Promise<BrandTileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BrandTileEdge>>() => T;
  aggregate: <T = AggregateBrandTilePromise>() => T;
}

export interface BrandTileConnectionSubscription
  extends Promise<AsyncIterator<BrandTileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BrandTileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBrandTileSubscription>() => T;
}

export interface BrandTileEdge {
  node: BrandTile;
  cursor: String;
}

export interface BrandTileEdgePromise
  extends Promise<BrandTileEdge>,
    Fragmentable {
  node: <T = BrandTilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface BrandTileEdgeSubscription
  extends Promise<AsyncIterator<BrandTileEdge>>,
    Fragmentable {
  node: <T = BrandTileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBrandTile {
  count: Int;
}

export interface AggregateBrandTilePromise
  extends Promise<AggregateBrandTile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBrandTileSubscription
  extends Promise<AsyncIterator<AggregateBrandTile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Contacts {
  id: ID_Output;
  phoneNumber?: String;
  name?: String;
  address?: String;
  email?: String;
}

export interface ContactsPromise extends Promise<Contacts>, Fragmentable {
  id: () => Promise<ID_Output>;
  phoneNumber: () => Promise<String>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  email: () => Promise<String>;
}

export interface ContactsSubscription
  extends Promise<AsyncIterator<Contacts>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface ContactsNullablePromise
  extends Promise<Contacts | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  phoneNumber: () => Promise<String>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  email: () => Promise<String>;
}

export interface ContactsConnection {
  pageInfo: PageInfo;
  edges: ContactsEdge[];
}

export interface ContactsConnectionPromise
  extends Promise<ContactsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContactsEdge>>() => T;
  aggregate: <T = AggregateContactsPromise>() => T;
}

export interface ContactsConnectionSubscription
  extends Promise<AsyncIterator<ContactsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContactsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContactsSubscription>() => T;
}

export interface ContactsEdge {
  node: Contacts;
  cursor: String;
}

export interface ContactsEdgePromise
  extends Promise<ContactsEdge>,
    Fragmentable {
  node: <T = ContactsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContactsEdgeSubscription
  extends Promise<AsyncIterator<ContactsEdge>>,
    Fragmentable {
  node: <T = ContactsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContacts {
  count: Int;
}

export interface AggregateContactsPromise
  extends Promise<AggregateContacts>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContactsSubscription
  extends Promise<AsyncIterator<AggregateContacts>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface File {
  contentType: String;
  createdAt: DateTimeOutput;
  id: ID_Output;
  name: String;
  secret: String;
  size: Int;
  updatedAt: DateTimeOutput;
  url: String;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  contentType: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  secret: () => Promise<String>;
  size: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
  url: () => Promise<String>;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  contentType: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  secret: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface FileNullablePromise
  extends Promise<File | null>,
    Fragmentable {
  contentType: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  secret: () => Promise<String>;
  size: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
  url: () => Promise<String>;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FridayConnection {
  pageInfo: PageInfo;
  edges: FridayEdge[];
}

export interface FridayConnectionPromise
  extends Promise<FridayConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FridayEdge>>() => T;
  aggregate: <T = AggregateFridayPromise>() => T;
}

export interface FridayConnectionSubscription
  extends Promise<AsyncIterator<FridayConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FridayEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFridaySubscription>() => T;
}

export interface FridayEdge {
  node: Friday;
  cursor: String;
}

export interface FridayEdgePromise extends Promise<FridayEdge>, Fragmentable {
  node: <T = FridayPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FridayEdgeSubscription
  extends Promise<AsyncIterator<FridayEdge>>,
    Fragmentable {
  node: <T = FridaySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFriday {
  count: Int;
}

export interface AggregateFridayPromise
  extends Promise<AggregateFriday>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFridaySubscription
  extends Promise<AsyncIterator<AggregateFriday>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HotDealsConnection {
  pageInfo: PageInfo;
  edges: HotDealsEdge[];
}

export interface HotDealsConnectionPromise
  extends Promise<HotDealsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HotDealsEdge>>() => T;
  aggregate: <T = AggregateHotDealsPromise>() => T;
}

export interface HotDealsConnectionSubscription
  extends Promise<AsyncIterator<HotDealsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HotDealsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHotDealsSubscription>() => T;
}

export interface HotDealsEdge {
  node: HotDeals;
  cursor: String;
}

export interface HotDealsEdgePromise
  extends Promise<HotDealsEdge>,
    Fragmentable {
  node: <T = HotDealsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HotDealsEdgeSubscription
  extends Promise<AsyncIterator<HotDealsEdge>>,
    Fragmentable {
  node: <T = HotDealsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateHotDeals {
  count: Int;
}

export interface AggregateHotDealsPromise
  extends Promise<AggregateHotDeals>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHotDealsSubscription
  extends Promise<AsyncIterator<AggregateHotDeals>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Misc {
  faq?: String;
  fup?: String;
  id: ID_Output;
}

export interface MiscPromise extends Promise<Misc>, Fragmentable {
  faq: () => Promise<String>;
  fup: () => Promise<String>;
  id: () => Promise<ID_Output>;
}

export interface MiscSubscription
  extends Promise<AsyncIterator<Misc>>,
    Fragmentable {
  faq: () => Promise<AsyncIterator<String>>;
  fup: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface MiscNullablePromise
  extends Promise<Misc | null>,
    Fragmentable {
  faq: () => Promise<String>;
  fup: () => Promise<String>;
  id: () => Promise<ID_Output>;
}

export interface MiscConnection {
  pageInfo: PageInfo;
  edges: MiscEdge[];
}

export interface MiscConnectionPromise
  extends Promise<MiscConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MiscEdge>>() => T;
  aggregate: <T = AggregateMiscPromise>() => T;
}

export interface MiscConnectionSubscription
  extends Promise<AsyncIterator<MiscConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MiscEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMiscSubscription>() => T;
}

export interface MiscEdge {
  node: Misc;
  cursor: String;
}

export interface MiscEdgePromise extends Promise<MiscEdge>, Fragmentable {
  node: <T = MiscPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MiscEdgeSubscription
  extends Promise<AsyncIterator<MiscEdge>>,
    Fragmentable {
  node: <T = MiscSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMisc {
  count: Int;
}

export interface AggregateMiscPromise
  extends Promise<AggregateMisc>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMiscSubscription
  extends Promise<AsyncIterator<AggregateMisc>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MondayConnection {
  pageInfo: PageInfo;
  edges: MondayEdge[];
}

export interface MondayConnectionPromise
  extends Promise<MondayConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MondayEdge>>() => T;
  aggregate: <T = AggregateMondayPromise>() => T;
}

export interface MondayConnectionSubscription
  extends Promise<AsyncIterator<MondayConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MondayEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMondaySubscription>() => T;
}

export interface MondayEdge {
  node: Monday;
  cursor: String;
}

export interface MondayEdgePromise extends Promise<MondayEdge>, Fragmentable {
  node: <T = MondayPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MondayEdgeSubscription
  extends Promise<AsyncIterator<MondayEdge>>,
    Fragmentable {
  node: <T = MondaySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMonday {
  count: Int;
}

export interface AggregateMondayPromise
  extends Promise<AggregateMonday>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMondaySubscription
  extends Promise<AsyncIterator<AggregateMonday>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrdersConnection {
  pageInfo: PageInfo;
  edges: OrdersEdge[];
}

export interface OrdersConnectionPromise
  extends Promise<OrdersConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrdersEdge>>() => T;
  aggregate: <T = AggregateOrdersPromise>() => T;
}

export interface OrdersConnectionSubscription
  extends Promise<AsyncIterator<OrdersConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrdersEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrdersSubscription>() => T;
}

export interface OrdersEdge {
  node: Orders;
  cursor: String;
}

export interface OrdersEdgePromise extends Promise<OrdersEdge>, Fragmentable {
  node: <T = OrdersPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrdersEdgeSubscription
  extends Promise<AsyncIterator<OrdersEdge>>,
    Fragmentable {
  node: <T = OrdersSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrders {
  count: Int;
}

export interface AggregateOrdersPromise
  extends Promise<AggregateOrders>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrdersSubscription
  extends Promise<AsyncIterator<AggregateOrders>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RestaurantTypeConnection {
  pageInfo: PageInfo;
  edges: RestaurantTypeEdge[];
}

export interface RestaurantTypeConnectionPromise
  extends Promise<RestaurantTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RestaurantTypeEdge>>() => T;
  aggregate: <T = AggregateRestaurantTypePromise>() => T;
}

export interface RestaurantTypeConnectionSubscription
  extends Promise<AsyncIterator<RestaurantTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RestaurantTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRestaurantTypeSubscription>() => T;
}

export interface RestaurantTypeEdge {
  node: RestaurantType;
  cursor: String;
}

export interface RestaurantTypeEdgePromise
  extends Promise<RestaurantTypeEdge>,
    Fragmentable {
  node: <T = RestaurantTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface RestaurantTypeEdgeSubscription
  extends Promise<AsyncIterator<RestaurantTypeEdge>>,
    Fragmentable {
  node: <T = RestaurantTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRestaurantType {
  count: Int;
}

export interface AggregateRestaurantTypePromise
  extends Promise<AggregateRestaurantType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRestaurantTypeSubscription
  extends Promise<AsyncIterator<AggregateRestaurantType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RestaurantsConnection {
  pageInfo: PageInfo;
  edges: RestaurantsEdge[];
}

export interface RestaurantsConnectionPromise
  extends Promise<RestaurantsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RestaurantsEdge>>() => T;
  aggregate: <T = AggregateRestaurantsPromise>() => T;
}

export interface RestaurantsConnectionSubscription
  extends Promise<AsyncIterator<RestaurantsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RestaurantsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRestaurantsSubscription>() => T;
}

export interface RestaurantsEdge {
  node: Restaurants;
  cursor: String;
}

export interface RestaurantsEdgePromise
  extends Promise<RestaurantsEdge>,
    Fragmentable {
  node: <T = RestaurantsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RestaurantsEdgeSubscription
  extends Promise<AsyncIterator<RestaurantsEdge>>,
    Fragmentable {
  node: <T = RestaurantsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRestaurants {
  count: Int;
}

export interface AggregateRestaurantsPromise
  extends Promise<AggregateRestaurants>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRestaurantsSubscription
  extends Promise<AsyncIterator<AggregateRestaurants>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SaturdayConnection {
  pageInfo: PageInfo;
  edges: SaturdayEdge[];
}

export interface SaturdayConnectionPromise
  extends Promise<SaturdayConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SaturdayEdge>>() => T;
  aggregate: <T = AggregateSaturdayPromise>() => T;
}

export interface SaturdayConnectionSubscription
  extends Promise<AsyncIterator<SaturdayConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SaturdayEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSaturdaySubscription>() => T;
}

export interface SaturdayEdge {
  node: Saturday;
  cursor: String;
}

export interface SaturdayEdgePromise
  extends Promise<SaturdayEdge>,
    Fragmentable {
  node: <T = SaturdayPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SaturdayEdgeSubscription
  extends Promise<AsyncIterator<SaturdayEdge>>,
    Fragmentable {
  node: <T = SaturdaySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSaturday {
  count: Int;
}

export interface AggregateSaturdayPromise
  extends Promise<AggregateSaturday>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSaturdaySubscription
  extends Promise<AsyncIterator<AggregateSaturday>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SundayConnection {
  pageInfo: PageInfo;
  edges: SundayEdge[];
}

export interface SundayConnectionPromise
  extends Promise<SundayConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SundayEdge>>() => T;
  aggregate: <T = AggregateSundayPromise>() => T;
}

export interface SundayConnectionSubscription
  extends Promise<AsyncIterator<SundayConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SundayEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSundaySubscription>() => T;
}

export interface SundayEdge {
  node: Sunday;
  cursor: String;
}

export interface SundayEdgePromise extends Promise<SundayEdge>, Fragmentable {
  node: <T = SundayPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SundayEdgeSubscription
  extends Promise<AsyncIterator<SundayEdge>>,
    Fragmentable {
  node: <T = SundaySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSunday {
  count: Int;
}

export interface AggregateSundayPromise
  extends Promise<AggregateSunday>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSundaySubscription
  extends Promise<AsyncIterator<AggregateSunday>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ThursdayConnection {
  pageInfo: PageInfo;
  edges: ThursdayEdge[];
}

export interface ThursdayConnectionPromise
  extends Promise<ThursdayConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ThursdayEdge>>() => T;
  aggregate: <T = AggregateThursdayPromise>() => T;
}

export interface ThursdayConnectionSubscription
  extends Promise<AsyncIterator<ThursdayConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ThursdayEdgeSubscription>>>() => T;
  aggregate: <T = AggregateThursdaySubscription>() => T;
}

export interface ThursdayEdge {
  node: Thursday;
  cursor: String;
}

export interface ThursdayEdgePromise
  extends Promise<ThursdayEdge>,
    Fragmentable {
  node: <T = ThursdayPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ThursdayEdgeSubscription
  extends Promise<AsyncIterator<ThursdayEdge>>,
    Fragmentable {
  node: <T = ThursdaySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateThursday {
  count: Int;
}

export interface AggregateThursdayPromise
  extends Promise<AggregateThursday>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateThursdaySubscription
  extends Promise<AsyncIterator<AggregateThursday>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TimeDiscountConnection {
  pageInfo: PageInfo;
  edges: TimeDiscountEdge[];
}

export interface TimeDiscountConnectionPromise
  extends Promise<TimeDiscountConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TimeDiscountEdge>>() => T;
  aggregate: <T = AggregateTimeDiscountPromise>() => T;
}

export interface TimeDiscountConnectionSubscription
  extends Promise<AsyncIterator<TimeDiscountConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TimeDiscountEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTimeDiscountSubscription>() => T;
}

export interface TimeDiscountEdge {
  node: TimeDiscount;
  cursor: String;
}

export interface TimeDiscountEdgePromise
  extends Promise<TimeDiscountEdge>,
    Fragmentable {
  node: <T = TimeDiscountPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TimeDiscountEdgeSubscription
  extends Promise<AsyncIterator<TimeDiscountEdge>>,
    Fragmentable {
  node: <T = TimeDiscountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTimeDiscount {
  count: Int;
}

export interface AggregateTimeDiscountPromise
  extends Promise<AggregateTimeDiscount>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTimeDiscountSubscription
  extends Promise<AsyncIterator<AggregateTimeDiscount>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TuesdayConnection {
  pageInfo: PageInfo;
  edges: TuesdayEdge[];
}

export interface TuesdayConnectionPromise
  extends Promise<TuesdayConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TuesdayEdge>>() => T;
  aggregate: <T = AggregateTuesdayPromise>() => T;
}

export interface TuesdayConnectionSubscription
  extends Promise<AsyncIterator<TuesdayConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TuesdayEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTuesdaySubscription>() => T;
}

export interface TuesdayEdge {
  node: Tuesday;
  cursor: String;
}

export interface TuesdayEdgePromise extends Promise<TuesdayEdge>, Fragmentable {
  node: <T = TuesdayPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TuesdayEdgeSubscription
  extends Promise<AsyncIterator<TuesdayEdge>>,
    Fragmentable {
  node: <T = TuesdaySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTuesday {
  count: Int;
}

export interface AggregateTuesdayPromise
  extends Promise<AggregateTuesday>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTuesdaySubscription
  extends Promise<AsyncIterator<AggregateTuesday>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserReviewsConnection {
  pageInfo: PageInfo;
  edges: UserReviewsEdge[];
}

export interface UserReviewsConnectionPromise
  extends Promise<UserReviewsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserReviewsEdge>>() => T;
  aggregate: <T = AggregateUserReviewsPromise>() => T;
}

export interface UserReviewsConnectionSubscription
  extends Promise<AsyncIterator<UserReviewsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserReviewsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserReviewsSubscription>() => T;
}

export interface UserReviewsEdge {
  node: UserReviews;
  cursor: String;
}

export interface UserReviewsEdgePromise
  extends Promise<UserReviewsEdge>,
    Fragmentable {
  node: <T = UserReviewsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserReviewsEdgeSubscription
  extends Promise<AsyncIterator<UserReviewsEdge>>,
    Fragmentable {
  node: <T = UserReviewsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserReviews {
  count: Int;
}

export interface AggregateUserReviewsPromise
  extends Promise<AggregateUserReviews>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserReviewsSubscription
  extends Promise<AsyncIterator<AggregateUserReviews>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WednesdayConnection {
  pageInfo: PageInfo;
  edges: WednesdayEdge[];
}

export interface WednesdayConnectionPromise
  extends Promise<WednesdayConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WednesdayEdge>>() => T;
  aggregate: <T = AggregateWednesdayPromise>() => T;
}

export interface WednesdayConnectionSubscription
  extends Promise<AsyncIterator<WednesdayConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WednesdayEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWednesdaySubscription>() => T;
}

export interface WednesdayEdge {
  node: Wednesday;
  cursor: String;
}

export interface WednesdayEdgePromise
  extends Promise<WednesdayEdge>,
    Fragmentable {
  node: <T = WednesdayPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WednesdayEdgeSubscription
  extends Promise<AsyncIterator<WednesdayEdge>>,
    Fragmentable {
  node: <T = WednesdaySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWednesday {
  count: Int;
}

export interface AggregateWednesdayPromise
  extends Promise<AggregateWednesday>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWednesdaySubscription
  extends Promise<AsyncIterator<AggregateWednesday>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface city {
  city: String;
  isPremium: Boolean;
  id: ID_Output;
  premiumAmmount90: Int;
  premiumAmmount180: Int;
  premiumAmmount360: Int;
  imageUrl?: String;
}

export interface cityPromise extends Promise<city>, Fragmentable {
  city: () => Promise<String>;
  isPremium: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  premiumAmmount90: () => Promise<Int>;
  premiumAmmount180: () => Promise<Int>;
  premiumAmmount360: () => Promise<Int>;
  imageUrl: () => Promise<String>;
}

export interface citySubscription
  extends Promise<AsyncIterator<city>>,
    Fragmentable {
  city: () => Promise<AsyncIterator<String>>;
  isPremium: () => Promise<AsyncIterator<Boolean>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  premiumAmmount90: () => Promise<AsyncIterator<Int>>;
  premiumAmmount180: () => Promise<AsyncIterator<Int>>;
  premiumAmmount360: () => Promise<AsyncIterator<Int>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
}

export interface cityNullablePromise
  extends Promise<city | null>,
    Fragmentable {
  city: () => Promise<String>;
  isPremium: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  premiumAmmount90: () => Promise<Int>;
  premiumAmmount180: () => Promise<Int>;
  premiumAmmount360: () => Promise<Int>;
  imageUrl: () => Promise<String>;
}

export interface cityConnection {
  pageInfo: PageInfo;
  edges: cityEdge[];
}

export interface cityConnectionPromise
  extends Promise<cityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<cityEdge>>() => T;
  aggregate: <T = AggregatecityPromise>() => T;
}

export interface cityConnectionSubscription
  extends Promise<AsyncIterator<cityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<cityEdgeSubscription>>>() => T;
  aggregate: <T = AggregatecitySubscription>() => T;
}

export interface cityEdge {
  node: city;
  cursor: String;
}

export interface cityEdgePromise extends Promise<cityEdge>, Fragmentable {
  node: <T = cityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface cityEdgeSubscription
  extends Promise<AsyncIterator<cityEdge>>,
    Fragmentable {
  node: <T = citySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Aggregatecity {
  count: Int;
}

export interface AggregatecityPromise
  extends Promise<Aggregatecity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatecitySubscription
  extends Promise<AsyncIterator<Aggregatecity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AdsSubscriptionPayload {
  mutation: MutationType;
  node: Ads;
  updatedFields: String[];
  previousValues: AdsPreviousValues;
}

export interface AdsSubscriptionPayloadPromise
  extends Promise<AdsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AdsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AdsPreviousValuesPromise>() => T;
}

export interface AdsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AdsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AdsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AdsPreviousValuesSubscription>() => T;
}

export interface AdsPreviousValues {
  city: String;
  id: ID_Output;
  imageurl: String;
  visible: Boolean;
}

export interface AdsPreviousValuesPromise
  extends Promise<AdsPreviousValues>,
    Fragmentable {
  city: () => Promise<String>;
  id: () => Promise<ID_Output>;
  imageurl: () => Promise<String>;
  visible: () => Promise<Boolean>;
}

export interface AdsPreviousValuesSubscription
  extends Promise<AsyncIterator<AdsPreviousValues>>,
    Fragmentable {
  city: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  imageurl: () => Promise<AsyncIterator<String>>;
  visible: () => Promise<AsyncIterator<Boolean>>;
}

export interface BlogSubscriptionPayload {
  mutation: MutationType;
  node: Blog;
  updatedFields: String[];
  previousValues: BlogPreviousValues;
}

export interface BlogSubscriptionPayloadPromise
  extends Promise<BlogSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BlogPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BlogPreviousValuesPromise>() => T;
}

export interface BlogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BlogSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BlogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BlogPreviousValuesSubscription>() => T;
}

export interface BlogPreviousValues {
  authorImg: String;
  authorName: String;
  content: String;
  createdon: DateTimeOutput;
  id: ID_Output;
  summary: String;
  title: String;
  titleImg?: String;
}

export interface BlogPreviousValuesPromise
  extends Promise<BlogPreviousValues>,
    Fragmentable {
  authorImg: () => Promise<String>;
  authorName: () => Promise<String>;
  content: () => Promise<String>;
  createdon: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  summary: () => Promise<String>;
  title: () => Promise<String>;
  titleImg: () => Promise<String>;
}

export interface BlogPreviousValuesSubscription
  extends Promise<AsyncIterator<BlogPreviousValues>>,
    Fragmentable {
  authorImg: () => Promise<AsyncIterator<String>>;
  authorName: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  createdon: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  summary: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  titleImg: () => Promise<AsyncIterator<String>>;
}

export interface BrandTileSubscriptionPayload {
  mutation: MutationType;
  node: BrandTile;
  updatedFields: String[];
  previousValues: BrandTilePreviousValues;
}

export interface BrandTileSubscriptionPayloadPromise
  extends Promise<BrandTileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BrandTilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BrandTilePreviousValuesPromise>() => T;
}

export interface BrandTileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BrandTileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BrandTileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BrandTilePreviousValuesSubscription>() => T;
}

export interface BrandTilePreviousValues {
  id: ID_Output;
  type: String;
  imageurl?: String;
  order?: Int;
  brandTileName: String;
}

export interface BrandTilePreviousValuesPromise
  extends Promise<BrandTilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  imageurl: () => Promise<String>;
  order: () => Promise<Int>;
  brandTileName: () => Promise<String>;
}

export interface BrandTilePreviousValuesSubscription
  extends Promise<AsyncIterator<BrandTilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  imageurl: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  brandTileName: () => Promise<AsyncIterator<String>>;
}

export interface ContactsSubscriptionPayload {
  mutation: MutationType;
  node: Contacts;
  updatedFields: String[];
  previousValues: ContactsPreviousValues;
}

export interface ContactsSubscriptionPayloadPromise
  extends Promise<ContactsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContactsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContactsPreviousValuesPromise>() => T;
}

export interface ContactsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContactsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContactsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContactsPreviousValuesSubscription>() => T;
}

export interface ContactsPreviousValues {
  id: ID_Output;
  phoneNumber?: String;
  name?: String;
  address?: String;
  email?: String;
}

export interface ContactsPreviousValuesPromise
  extends Promise<ContactsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  phoneNumber: () => Promise<String>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  email: () => Promise<String>;
}

export interface ContactsPreviousValuesSubscription
  extends Promise<AsyncIterator<ContactsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface FilePreviousValues {
  contentType: String;
  createdAt: DateTimeOutput;
  id: ID_Output;
  name: String;
  secret: String;
  size: Int;
  updatedAt: DateTimeOutput;
  url: String;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  contentType: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  secret: () => Promise<String>;
  size: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
  url: () => Promise<String>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  contentType: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  secret: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface FridaySubscriptionPayload {
  mutation: MutationType;
  node: Friday;
  updatedFields: String[];
  previousValues: FridayPreviousValues;
}

export interface FridaySubscriptionPayloadPromise
  extends Promise<FridaySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FridayPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FridayPreviousValuesPromise>() => T;
}

export interface FridaySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FridaySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FridaySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FridayPreviousValuesSubscription>() => T;
}

export interface FridayPreviousValues {
  exhausted: Boolean;
  id: ID_Output;
  order?: Int;
}

export interface FridayPreviousValuesPromise
  extends Promise<FridayPreviousValues>,
    Fragmentable {
  exhausted: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
}

export interface FridayPreviousValuesSubscription
  extends Promise<AsyncIterator<FridayPreviousValues>>,
    Fragmentable {
  exhausted: () => Promise<AsyncIterator<Boolean>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface HotDealsSubscriptionPayload {
  mutation: MutationType;
  node: HotDeals;
  updatedFields: String[];
  previousValues: HotDealsPreviousValues;
}

export interface HotDealsSubscriptionPayloadPromise
  extends Promise<HotDealsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HotDealsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HotDealsPreviousValuesPromise>() => T;
}

export interface HotDealsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HotDealsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HotDealsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HotDealsPreviousValuesSubscription>() => T;
}

export interface HotDealsPreviousValues {
  id: ID_Output;
  type: String;
  imageurl?: String;
}

export interface HotDealsPreviousValuesPromise
  extends Promise<HotDealsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  imageurl: () => Promise<String>;
}

export interface HotDealsPreviousValuesSubscription
  extends Promise<AsyncIterator<HotDealsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  imageurl: () => Promise<AsyncIterator<String>>;
}

export interface MiscSubscriptionPayload {
  mutation: MutationType;
  node: Misc;
  updatedFields: String[];
  previousValues: MiscPreviousValues;
}

export interface MiscSubscriptionPayloadPromise
  extends Promise<MiscSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MiscPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MiscPreviousValuesPromise>() => T;
}

export interface MiscSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MiscSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MiscSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MiscPreviousValuesSubscription>() => T;
}

export interface MiscPreviousValues {
  faq?: String;
  fup?: String;
  id: ID_Output;
}

export interface MiscPreviousValuesPromise
  extends Promise<MiscPreviousValues>,
    Fragmentable {
  faq: () => Promise<String>;
  fup: () => Promise<String>;
  id: () => Promise<ID_Output>;
}

export interface MiscPreviousValuesSubscription
  extends Promise<AsyncIterator<MiscPreviousValues>>,
    Fragmentable {
  faq: () => Promise<AsyncIterator<String>>;
  fup: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface MondaySubscriptionPayload {
  mutation: MutationType;
  node: Monday;
  updatedFields: String[];
  previousValues: MondayPreviousValues;
}

export interface MondaySubscriptionPayloadPromise
  extends Promise<MondaySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MondayPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MondayPreviousValuesPromise>() => T;
}

export interface MondaySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MondaySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MondaySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MondayPreviousValuesSubscription>() => T;
}

export interface MondayPreviousValues {
  id: ID_Output;
  exhausted?: Boolean;
  order?: Int;
}

export interface MondayPreviousValuesPromise
  extends Promise<MondayPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  exhausted: () => Promise<Boolean>;
  order: () => Promise<Int>;
}

export interface MondayPreviousValuesSubscription
  extends Promise<AsyncIterator<MondayPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  exhausted: () => Promise<AsyncIterator<Boolean>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface OrdersSubscriptionPayload {
  mutation: MutationType;
  node: Orders;
  updatedFields: String[];
  previousValues: OrdersPreviousValues;
}

export interface OrdersSubscriptionPayloadPromise
  extends Promise<OrdersSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrdersPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrdersPreviousValuesPromise>() => T;
}

export interface OrdersSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrdersSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrdersSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrdersPreviousValuesSubscription>() => T;
}

export interface OrdersPreviousValues {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  id: ID_Output;
  date: String;
  totalDiscount: Int;
  people: Int;
  bookingid: String;
  mobile: String;
  unlockActive: Boolean;
  name: String;
  geolocation?: String;
  referrer?: String;
  confirmed?: Boolean;
  cancelled: Boolean;
  amount?: Int;
  receipt?: String;
  paymentId?: String;
  paymentOrderId?: String;
  paymentDescription?: String;
}

export interface OrdersPreviousValuesPromise
  extends Promise<OrdersPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  date: () => Promise<String>;
  totalDiscount: () => Promise<Int>;
  people: () => Promise<Int>;
  bookingid: () => Promise<String>;
  mobile: () => Promise<String>;
  unlockActive: () => Promise<Boolean>;
  name: () => Promise<String>;
  geolocation: () => Promise<String>;
  referrer: () => Promise<String>;
  confirmed: () => Promise<Boolean>;
  cancelled: () => Promise<Boolean>;
  amount: () => Promise<Int>;
  receipt: () => Promise<String>;
  paymentId: () => Promise<String>;
  paymentOrderId: () => Promise<String>;
  paymentDescription: () => Promise<String>;
}

export interface OrdersPreviousValuesSubscription
  extends Promise<AsyncIterator<OrdersPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<String>>;
  totalDiscount: () => Promise<AsyncIterator<Int>>;
  people: () => Promise<AsyncIterator<Int>>;
  bookingid: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  unlockActive: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  geolocation: () => Promise<AsyncIterator<String>>;
  referrer: () => Promise<AsyncIterator<String>>;
  confirmed: () => Promise<AsyncIterator<Boolean>>;
  cancelled: () => Promise<AsyncIterator<Boolean>>;
  amount: () => Promise<AsyncIterator<Int>>;
  receipt: () => Promise<AsyncIterator<String>>;
  paymentId: () => Promise<AsyncIterator<String>>;
  paymentOrderId: () => Promise<AsyncIterator<String>>;
  paymentDescription: () => Promise<AsyncIterator<String>>;
}

export interface RestaurantTypeSubscriptionPayload {
  mutation: MutationType;
  node: RestaurantType;
  updatedFields: String[];
  previousValues: RestaurantTypePreviousValues;
}

export interface RestaurantTypeSubscriptionPayloadPromise
  extends Promise<RestaurantTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RestaurantTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RestaurantTypePreviousValuesPromise>() => T;
}

export interface RestaurantTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RestaurantTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RestaurantTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RestaurantTypePreviousValuesSubscription>() => T;
}

export interface RestaurantTypePreviousValues {
  id: ID_Output;
  type: String;
  imageurl?: String;
  order?: Int;
  typeName?: String;
  cityImage?: String;
  activatePremium?: Boolean;
  premiumPrice?: Int;
}

export interface RestaurantTypePreviousValuesPromise
  extends Promise<RestaurantTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  imageurl: () => Promise<String>;
  order: () => Promise<Int>;
  typeName: () => Promise<String>;
  cityImage: () => Promise<String>;
  activatePremium: () => Promise<Boolean>;
  premiumPrice: () => Promise<Int>;
}

export interface RestaurantTypePreviousValuesSubscription
  extends Promise<AsyncIterator<RestaurantTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  imageurl: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  typeName: () => Promise<AsyncIterator<String>>;
  cityImage: () => Promise<AsyncIterator<String>>;
  activatePremium: () => Promise<AsyncIterator<Boolean>>;
  premiumPrice: () => Promise<AsyncIterator<Int>>;
}

export interface RestaurantsSubscriptionPayload {
  mutation: MutationType;
  node: Restaurants;
  updatedFields: String[];
  previousValues: RestaurantsPreviousValues;
}

export interface RestaurantsSubscriptionPayloadPromise
  extends Promise<RestaurantsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RestaurantsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RestaurantsPreviousValuesPromise>() => T;
}

export interface RestaurantsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RestaurantsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RestaurantsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RestaurantsPreviousValuesSubscription>() => T;
}

export interface RestaurantsPreviousValues {
  city: String;
  id: ID_Output;
  enableLoginAccess: Boolean;
  name: String;
  email?: String;
  password?: String;
  rating?: Float;
  imageurl?: String;
  googlemapsurl?: String;
  state: String;
  about?: String;
  address?: String;
  conditions?: String;
  remail?: String;
  rphone: String[];
  latitude?: Float;
  longitude?: Float;
  acceptsRenoPay: Boolean;
  renoCommision: Int;
  menu: Json[];
  restaurantImages: String[];
}

export interface RestaurantsPreviousValuesPromise
  extends Promise<RestaurantsPreviousValues>,
    Fragmentable {
  city: () => Promise<String>;
  id: () => Promise<ID_Output>;
  enableLoginAccess: () => Promise<Boolean>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  rating: () => Promise<Float>;
  imageurl: () => Promise<String>;
  googlemapsurl: () => Promise<String>;
  state: () => Promise<String>;
  about: () => Promise<String>;
  address: () => Promise<String>;
  conditions: () => Promise<String>;
  remail: () => Promise<String>;
  rphone: () => Promise<String[]>;
  latitude: () => Promise<Float>;
  longitude: () => Promise<Float>;
  acceptsRenoPay: () => Promise<Boolean>;
  renoCommision: () => Promise<Int>;
  menu: () => Promise<Json[]>;
  restaurantImages: () => Promise<String[]>;
}

export interface RestaurantsPreviousValuesSubscription
  extends Promise<AsyncIterator<RestaurantsPreviousValues>>,
    Fragmentable {
  city: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  enableLoginAccess: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  rating: () => Promise<AsyncIterator<Float>>;
  imageurl: () => Promise<AsyncIterator<String>>;
  googlemapsurl: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  about: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  conditions: () => Promise<AsyncIterator<String>>;
  remail: () => Promise<AsyncIterator<String>>;
  rphone: () => Promise<AsyncIterator<String[]>>;
  latitude: () => Promise<AsyncIterator<Float>>;
  longitude: () => Promise<AsyncIterator<Float>>;
  acceptsRenoPay: () => Promise<AsyncIterator<Boolean>>;
  renoCommision: () => Promise<AsyncIterator<Int>>;
  menu: () => Promise<AsyncIterator<Json[]>>;
  restaurantImages: () => Promise<AsyncIterator<String[]>>;
}

export interface SaturdaySubscriptionPayload {
  mutation: MutationType;
  node: Saturday;
  updatedFields: String[];
  previousValues: SaturdayPreviousValues;
}

export interface SaturdaySubscriptionPayloadPromise
  extends Promise<SaturdaySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SaturdayPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SaturdayPreviousValuesPromise>() => T;
}

export interface SaturdaySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SaturdaySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SaturdaySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SaturdayPreviousValuesSubscription>() => T;
}

export interface SaturdayPreviousValues {
  exhausted: Boolean;
  id: ID_Output;
  order?: Int;
}

export interface SaturdayPreviousValuesPromise
  extends Promise<SaturdayPreviousValues>,
    Fragmentable {
  exhausted: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
}

export interface SaturdayPreviousValuesSubscription
  extends Promise<AsyncIterator<SaturdayPreviousValues>>,
    Fragmentable {
  exhausted: () => Promise<AsyncIterator<Boolean>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface SundaySubscriptionPayload {
  mutation: MutationType;
  node: Sunday;
  updatedFields: String[];
  previousValues: SundayPreviousValues;
}

export interface SundaySubscriptionPayloadPromise
  extends Promise<SundaySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SundayPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SundayPreviousValuesPromise>() => T;
}

export interface SundaySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SundaySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SundaySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SundayPreviousValuesSubscription>() => T;
}

export interface SundayPreviousValues {
  exhausted: Boolean;
  id: ID_Output;
  order?: Int;
}

export interface SundayPreviousValuesPromise
  extends Promise<SundayPreviousValues>,
    Fragmentable {
  exhausted: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
}

export interface SundayPreviousValuesSubscription
  extends Promise<AsyncIterator<SundayPreviousValues>>,
    Fragmentable {
  exhausted: () => Promise<AsyncIterator<Boolean>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface ThursdaySubscriptionPayload {
  mutation: MutationType;
  node: Thursday;
  updatedFields: String[];
  previousValues: ThursdayPreviousValues;
}

export interface ThursdaySubscriptionPayloadPromise
  extends Promise<ThursdaySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ThursdayPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ThursdayPreviousValuesPromise>() => T;
}

export interface ThursdaySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ThursdaySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ThursdaySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ThursdayPreviousValuesSubscription>() => T;
}

export interface ThursdayPreviousValues {
  exhausted: Boolean;
  id: ID_Output;
  order?: Int;
}

export interface ThursdayPreviousValuesPromise
  extends Promise<ThursdayPreviousValues>,
    Fragmentable {
  exhausted: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
}

export interface ThursdayPreviousValuesSubscription
  extends Promise<AsyncIterator<ThursdayPreviousValues>>,
    Fragmentable {
  exhausted: () => Promise<AsyncIterator<Boolean>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface TimeDiscountSubscriptionPayload {
  mutation: MutationType;
  node: TimeDiscount;
  updatedFields: String[];
  previousValues: TimeDiscountPreviousValues;
}

export interface TimeDiscountSubscriptionPayloadPromise
  extends Promise<TimeDiscountSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TimeDiscountPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TimeDiscountPreviousValuesPromise>() => T;
}

export interface TimeDiscountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TimeDiscountSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TimeDiscountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TimeDiscountPreviousValuesSubscription>() => T;
}

export interface TimeDiscountPreviousValues {
  discount: Float;
  id: ID_Output;
  time: String;
  daychange?: Boolean;
  day?: Boolean;
  newtime?: String;
  newdiscount?: String;
  exhausted?: Boolean;
  tueExhaust: Boolean;
  monExhaust: Boolean;
  wedExhaust: Boolean;
  thuExhaust: Boolean;
  friExhaust: Boolean;
  satExhaust: Boolean;
  sunExhaust: Boolean;
  monDiscount: Float;
  tueDiscount: Float;
  wedDiscount: Float;
  thuDiscount: Float;
  friDiscount: Float;
  satDiscount: Float;
  sunDiscount: Float;
}

export interface TimeDiscountPreviousValuesPromise
  extends Promise<TimeDiscountPreviousValues>,
    Fragmentable {
  discount: () => Promise<Float>;
  id: () => Promise<ID_Output>;
  time: () => Promise<String>;
  daychange: () => Promise<Boolean>;
  day: () => Promise<Boolean>;
  newtime: () => Promise<String>;
  newdiscount: () => Promise<String>;
  exhausted: () => Promise<Boolean>;
  tueExhaust: () => Promise<Boolean>;
  monExhaust: () => Promise<Boolean>;
  wedExhaust: () => Promise<Boolean>;
  thuExhaust: () => Promise<Boolean>;
  friExhaust: () => Promise<Boolean>;
  satExhaust: () => Promise<Boolean>;
  sunExhaust: () => Promise<Boolean>;
  monDiscount: () => Promise<Float>;
  tueDiscount: () => Promise<Float>;
  wedDiscount: () => Promise<Float>;
  thuDiscount: () => Promise<Float>;
  friDiscount: () => Promise<Float>;
  satDiscount: () => Promise<Float>;
  sunDiscount: () => Promise<Float>;
}

export interface TimeDiscountPreviousValuesSubscription
  extends Promise<AsyncIterator<TimeDiscountPreviousValues>>,
    Fragmentable {
  discount: () => Promise<AsyncIterator<Float>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  time: () => Promise<AsyncIterator<String>>;
  daychange: () => Promise<AsyncIterator<Boolean>>;
  day: () => Promise<AsyncIterator<Boolean>>;
  newtime: () => Promise<AsyncIterator<String>>;
  newdiscount: () => Promise<AsyncIterator<String>>;
  exhausted: () => Promise<AsyncIterator<Boolean>>;
  tueExhaust: () => Promise<AsyncIterator<Boolean>>;
  monExhaust: () => Promise<AsyncIterator<Boolean>>;
  wedExhaust: () => Promise<AsyncIterator<Boolean>>;
  thuExhaust: () => Promise<AsyncIterator<Boolean>>;
  friExhaust: () => Promise<AsyncIterator<Boolean>>;
  satExhaust: () => Promise<AsyncIterator<Boolean>>;
  sunExhaust: () => Promise<AsyncIterator<Boolean>>;
  monDiscount: () => Promise<AsyncIterator<Float>>;
  tueDiscount: () => Promise<AsyncIterator<Float>>;
  wedDiscount: () => Promise<AsyncIterator<Float>>;
  thuDiscount: () => Promise<AsyncIterator<Float>>;
  friDiscount: () => Promise<AsyncIterator<Float>>;
  satDiscount: () => Promise<AsyncIterator<Float>>;
  sunDiscount: () => Promise<AsyncIterator<Float>>;
}

export interface TuesdaySubscriptionPayload {
  mutation: MutationType;
  node: Tuesday;
  updatedFields: String[];
  previousValues: TuesdayPreviousValues;
}

export interface TuesdaySubscriptionPayloadPromise
  extends Promise<TuesdaySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TuesdayPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TuesdayPreviousValuesPromise>() => T;
}

export interface TuesdaySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TuesdaySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TuesdaySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TuesdayPreviousValuesSubscription>() => T;
}

export interface TuesdayPreviousValues {
  exhausted: Boolean;
  id: ID_Output;
  order?: Int;
}

export interface TuesdayPreviousValuesPromise
  extends Promise<TuesdayPreviousValues>,
    Fragmentable {
  exhausted: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
}

export interface TuesdayPreviousValuesSubscription
  extends Promise<AsyncIterator<TuesdayPreviousValues>>,
    Fragmentable {
  exhausted: () => Promise<AsyncIterator<Boolean>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email?: String;
  firstname?: String;
  id: ID_Output;
  facebookID: String;
  lastname?: String;
  mobile?: String;
  totalOrders?: Int;
  contactSync?: Boolean;
  isBlocked?: Boolean;
  promoCode?: String;
  userPromoCount?: Int;
  typeAccess: String;
  password?: String;
  installLocation?: String;
  isPremiumUser?: String;
  currentLocation?: String;
  profileImage?: String;
  bookingOtp?: String;
  otpExpires?: DateTimeOutput;
  premiumStartDate?: DateTimeOutput;
  premiumExpireDate?: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  firstname: () => Promise<String>;
  id: () => Promise<ID_Output>;
  facebookID: () => Promise<String>;
  lastname: () => Promise<String>;
  mobile: () => Promise<String>;
  totalOrders: () => Promise<Int>;
  contactSync: () => Promise<Boolean>;
  isBlocked: () => Promise<Boolean>;
  promoCode: () => Promise<String>;
  userPromoCount: () => Promise<Int>;
  typeAccess: () => Promise<String>;
  password: () => Promise<String>;
  installLocation: () => Promise<String>;
  isPremiumUser: () => Promise<String>;
  currentLocation: () => Promise<String>;
  profileImage: () => Promise<String>;
  bookingOtp: () => Promise<String>;
  otpExpires: () => Promise<DateTimeOutput>;
  premiumStartDate: () => Promise<DateTimeOutput>;
  premiumExpireDate: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  firstname: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  facebookID: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  totalOrders: () => Promise<AsyncIterator<Int>>;
  contactSync: () => Promise<AsyncIterator<Boolean>>;
  isBlocked: () => Promise<AsyncIterator<Boolean>>;
  promoCode: () => Promise<AsyncIterator<String>>;
  userPromoCount: () => Promise<AsyncIterator<Int>>;
  typeAccess: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  installLocation: () => Promise<AsyncIterator<String>>;
  isPremiumUser: () => Promise<AsyncIterator<String>>;
  currentLocation: () => Promise<AsyncIterator<String>>;
  profileImage: () => Promise<AsyncIterator<String>>;
  bookingOtp: () => Promise<AsyncIterator<String>>;
  otpExpires: () => Promise<AsyncIterator<DateTimeOutput>>;
  premiumStartDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  premiumExpireDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserReviewsSubscriptionPayload {
  mutation: MutationType;
  node: UserReviews;
  updatedFields: String[];
  previousValues: UserReviewsPreviousValues;
}

export interface UserReviewsSubscriptionPayloadPromise
  extends Promise<UserReviewsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserReviewsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserReviewsPreviousValuesPromise>() => T;
}

export interface UserReviewsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserReviewsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserReviewsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserReviewsPreviousValuesSubscription>() => T;
}

export interface UserReviewsPreviousValues {
  id: ID_Output;
  review: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  rating: Int;
}

export interface UserReviewsPreviousValuesPromise
  extends Promise<UserReviewsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  review: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  rating: () => Promise<Int>;
}

export interface UserReviewsPreviousValuesSubscription
  extends Promise<AsyncIterator<UserReviewsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  review: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  rating: () => Promise<AsyncIterator<Int>>;
}

export interface WednesdaySubscriptionPayload {
  mutation: MutationType;
  node: Wednesday;
  updatedFields: String[];
  previousValues: WednesdayPreviousValues;
}

export interface WednesdaySubscriptionPayloadPromise
  extends Promise<WednesdaySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WednesdayPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WednesdayPreviousValuesPromise>() => T;
}

export interface WednesdaySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WednesdaySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WednesdaySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WednesdayPreviousValuesSubscription>() => T;
}

export interface WednesdayPreviousValues {
  exhausted: Boolean;
  id: ID_Output;
  order?: Int;
}

export interface WednesdayPreviousValuesPromise
  extends Promise<WednesdayPreviousValues>,
    Fragmentable {
  exhausted: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
}

export interface WednesdayPreviousValuesSubscription
  extends Promise<AsyncIterator<WednesdayPreviousValues>>,
    Fragmentable {
  exhausted: () => Promise<AsyncIterator<Boolean>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface citySubscriptionPayload {
  mutation: MutationType;
  node: city;
  updatedFields: String[];
  previousValues: cityPreviousValues;
}

export interface citySubscriptionPayloadPromise
  extends Promise<citySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = cityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = cityPreviousValuesPromise>() => T;
}

export interface citySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<citySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = citySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = cityPreviousValuesSubscription>() => T;
}

export interface cityPreviousValues {
  city: String;
  isPremium: Boolean;
  id: ID_Output;
  premiumAmmount90: Int;
  premiumAmmount180: Int;
  premiumAmmount360: Int;
  imageUrl?: String;
}

export interface cityPreviousValuesPromise
  extends Promise<cityPreviousValues>,
    Fragmentable {
  city: () => Promise<String>;
  isPremium: () => Promise<Boolean>;
  id: () => Promise<ID_Output>;
  premiumAmmount90: () => Promise<Int>;
  premiumAmmount180: () => Promise<Int>;
  premiumAmmount360: () => Promise<Int>;
  imageUrl: () => Promise<String>;
}

export interface cityPreviousValuesSubscription
  extends Promise<AsyncIterator<cityPreviousValues>>,
    Fragmentable {
  city: () => Promise<AsyncIterator<String>>;
  isPremium: () => Promise<AsyncIterator<Boolean>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  premiumAmmount90: () => Promise<AsyncIterator<Int>>;
  premiumAmmount180: () => Promise<AsyncIterator<Int>>;
  premiumAmmount360: () => Promise<AsyncIterator<Int>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

export type Json = any;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Ads",
    embedded: false
  },
  {
    name: "Blog",
    embedded: false
  },
  {
    name: "BrandTile",
    embedded: false
  },
  {
    name: "Contacts",
    embedded: false
  },
  {
    name: "File",
    embedded: false
  },
  {
    name: "Friday",
    embedded: false
  },
  {
    name: "HotDeals",
    embedded: false
  },
  {
    name: "Misc",
    embedded: false
  },
  {
    name: "Monday",
    embedded: false
  },
  {
    name: "Orders",
    embedded: false
  },
  {
    name: "RestaurantType",
    embedded: false
  },
  {
    name: "Restaurants",
    embedded: false
  },
  {
    name: "Saturday",
    embedded: false
  },
  {
    name: "Sunday",
    embedded: false
  },
  {
    name: "Thursday",
    embedded: false
  },
  {
    name: "TimeDiscount",
    embedded: false
  },
  {
    name: "Tuesday",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserReviews",
    embedded: false
  },
  {
    name: "Wednesday",
    embedded: false
  },
  {
    name: "city",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
